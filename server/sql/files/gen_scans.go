package files

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"registro/sql/camps"
	"registro/sql/personnes"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneDemande(row scanner) (Demande, error) {
	var item Demande
	err := row.Scan(
		&item.Id,
		&item.IdFile,
		&item.IdDirecteur,
		&item.Categorie,
		&item.Description,
		&item.MaxDocs,
		&item.JoursValide,
	)
	return item, err
}

func ScanDemande(row *sql.Row) (Demande, error) { return scanOneDemande(row) }

// SelectAll returns all the items in the demandes table.
func SelectAllDemandes(db DB) (Demandes, error) {
	rows, err := db.Query("SELECT id, idfile, iddirecteur, categorie, description, maxdocs, joursvalide FROM demandes")
	if err != nil {
		return nil, err
	}
	return ScanDemandes(rows)
}

// SelectDemande returns the entry matching 'id'.
func SelectDemande(tx DB, id IdDemande) (Demande, error) {
	row := tx.QueryRow("SELECT id, idfile, iddirecteur, categorie, description, maxdocs, joursvalide FROM demandes WHERE id = $1", id)
	return ScanDemande(row)
}

// SelectDemandes returns the entry matching the given 'ids'.
func SelectDemandes(tx DB, ids ...IdDemande) (Demandes, error) {
	rows, err := tx.Query("SELECT id, idfile, iddirecteur, categorie, description, maxdocs, joursvalide FROM demandes WHERE id = ANY($1)", IdDemandeArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanDemandes(rows)
}

type Demandes map[IdDemande]Demande

func (m Demandes) IDs() []IdDemande {
	out := make([]IdDemande, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanDemandes(rs *sql.Rows) (Demandes, error) {
	var (
		s   Demande
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Demandes, 16)
	for rs.Next() {
		s, err = scanOneDemande(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Demande in the database and returns the item with id filled.
func (item Demande) Insert(tx DB) (out Demande, err error) {
	row := tx.QueryRow(`INSERT INTO demandes (
		idfile, iddirecteur, categorie, description, maxdocs, joursvalide
		) VALUES (
		$1, $2, $3, $4, $5, $6
		) RETURNING id, idfile, iddirecteur, categorie, description, maxdocs, joursvalide;
		`, item.IdFile, item.IdDirecteur, item.Categorie, item.Description, item.MaxDocs, item.JoursValide)
	return ScanDemande(row)
}

// Update Demande in the database and returns the new version.
func (item Demande) Update(tx DB) (out Demande, err error) {
	row := tx.QueryRow(`UPDATE demandes SET (
		idfile, iddirecteur, categorie, description, maxdocs, joursvalide
		) = (
		$1, $2, $3, $4, $5, $6
		) WHERE id = $7 RETURNING id, idfile, iddirecteur, categorie, description, maxdocs, joursvalide;
		`, item.IdFile, item.IdDirecteur, item.Categorie, item.Description, item.MaxDocs, item.JoursValide, item.Id)
	return ScanDemande(row)
}

// Deletes the Demande and returns the item
func DeleteDemandeById(tx DB, id IdDemande) (Demande, error) {
	row := tx.QueryRow("DELETE FROM demandes WHERE id = $1 RETURNING id, idfile, iddirecteur, categorie, description, maxdocs, joursvalide;", id)
	return ScanDemande(row)
}

// Deletes the Demande in the database and returns the ids.
func DeleteDemandesByIDs(tx DB, ids ...IdDemande) ([]IdDemande, error) {
	rows, err := tx.Query("DELETE FROM demandes WHERE id = ANY($1) RETURNING id", IdDemandeArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdDemandeArray(rows)
}

func SelectDemandesByIdFiles(tx DB, idFiles_ ...IdFile) (Demandes, error) {
	rows, err := tx.Query("SELECT id, idfile, iddirecteur, categorie, description, maxdocs, joursvalide FROM demandes WHERE idfile = ANY($1)", IdFileArrayToPQ(idFiles_))
	if err != nil {
		return nil, err
	}
	return ScanDemandes(rows)
}

func DeleteDemandesByIdFiles(tx DB, idFiles_ ...IdFile) ([]IdDemande, error) {
	rows, err := tx.Query("DELETE FROM demandes WHERE idfile = ANY($1) RETURNING id", IdFileArrayToPQ(idFiles_))
	if err != nil {
		return nil, err
	}
	return ScanIdDemandeArray(rows)
}

func SelectDemandesByIdDirecteurs(tx DB, idDirecteurs_ ...personnes.IdPersonne) (Demandes, error) {
	rows, err := tx.Query("SELECT id, idfile, iddirecteur, categorie, description, maxdocs, joursvalide FROM demandes WHERE iddirecteur = ANY($1)", personnes.IdPersonneArrayToPQ(idDirecteurs_))
	if err != nil {
		return nil, err
	}
	return ScanDemandes(rows)
}

func DeleteDemandesByIdDirecteurs(tx DB, idDirecteurs_ ...personnes.IdPersonne) ([]IdDemande, error) {
	rows, err := tx.Query("DELETE FROM demandes WHERE iddirecteur = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(idDirecteurs_))
	if err != nil {
		return nil, err
	}
	return ScanIdDemandeArray(rows)
}

func scanOneDemandeCamp(row scanner) (DemandeCamp, error) {
	var item DemandeCamp
	err := row.Scan(
		&item.IdCamp,
		&item.IdDemande,
	)
	return item, err
}

func ScanDemandeCamp(row *sql.Row) (DemandeCamp, error) { return scanOneDemandeCamp(row) }

// SelectAll returns all the items in the demande_camps table.
func SelectAllDemandeCamps(db DB) (DemandeCamps, error) {
	rows, err := db.Query("SELECT idcamp, iddemande FROM demande_camps")
	if err != nil {
		return nil, err
	}
	return ScanDemandeCamps(rows)
}

type DemandeCamps []DemandeCamp

func ScanDemandeCamps(rs *sql.Rows) (DemandeCamps, error) {
	var (
		item DemandeCamp
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(DemandeCamps, 0, 16)
	for rs.Next() {
		item, err = scanOneDemandeCamp(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item DemandeCamp) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO demande_camps (
			idcamp, iddemande
			) VALUES (
			$1, $2
			);
			`, item.IdCamp, item.IdDemande)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links DemandeCamp in the database.
// It is a no-op if 'items' is empty.
func InsertManyDemandeCamps(tx *sql.Tx, items ...DemandeCamp) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("demande_camps",
		"idcamp",
		"iddemande",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdCamp, item.IdDemande)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link DemandeCamp from the database.
// Only the foreign keys IdCamp, IdDemande fields are used in 'item'.
func (item DemandeCamp) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM demande_camps WHERE IdCamp = $1 AND IdDemande = $2;`, item.IdCamp, item.IdDemande)
	return err
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items DemandeCamps) ByIdCamp() map[camps.IdCamp]DemandeCamps {
	out := make(map[camps.IdCamp]DemandeCamps)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this link table.
// They are not garanteed to be distinct.
func (items DemandeCamps) IdCamps() []camps.IdCamp {
	out := make([]camps.IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

func SelectDemandeCampsByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (DemandeCamps, error) {
	rows, err := tx.Query("SELECT idcamp, iddemande FROM demande_camps WHERE idcamp = ANY($1)", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanDemandeCamps(rows)
}

func DeleteDemandeCampsByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (DemandeCamps, error) {
	rows, err := tx.Query("DELETE FROM demande_camps WHERE idcamp = ANY($1) RETURNING idcamp, iddemande", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanDemandeCamps(rows)
}

// ByIdDemande returns a map with 'IdDemande' as keys.
func (items DemandeCamps) ByIdDemande() map[IdDemande]DemandeCamps {
	out := make(map[IdDemande]DemandeCamps)
	for _, target := range items {
		out[target.IdDemande] = append(out[target.IdDemande], target)
	}
	return out
}

// IdDemandes returns the list of ids of IdDemande
// contained in this link table.
// They are not garanteed to be distinct.
func (items DemandeCamps) IdDemandes() []IdDemande {
	out := make([]IdDemande, len(items))
	for index, target := range items {
		out[index] = target.IdDemande
	}
	return out
}

func SelectDemandeCampsByIdDemandes(tx DB, idDemandes_ ...IdDemande) (DemandeCamps, error) {
	rows, err := tx.Query("SELECT idcamp, iddemande FROM demande_camps WHERE iddemande = ANY($1)", IdDemandeArrayToPQ(idDemandes_))
	if err != nil {
		return nil, err
	}
	return ScanDemandeCamps(rows)
}

func DeleteDemandeCampsByIdDemandes(tx DB, idDemandes_ ...IdDemande) (DemandeCamps, error) {
	rows, err := tx.Query("DELETE FROM demande_camps WHERE iddemande = ANY($1) RETURNING idcamp, iddemande", IdDemandeArrayToPQ(idDemandes_))
	if err != nil {
		return nil, err
	}
	return ScanDemandeCamps(rows)
}

// SelectDemandeCampByIdCampAndIdDemande return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectDemandeCampByIdCampAndIdDemande(tx DB, idCamp camps.IdCamp, idDemande IdDemande) (item DemandeCamp, found bool, err error) {
	row := tx.QueryRow("SELECT idcamp, iddemande FROM demande_camps WHERE IdCamp = $1 AND IdDemande = $2", idCamp, idDemande)
	item, err = ScanDemandeCamp(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneDemandeEquipier(row scanner) (DemandeEquipier, error) {
	var item DemandeEquipier
	err := row.Scan(
		&item.IdEquipier,
		&item.IdDemande,
		&item.Optionnel,
	)
	return item, err
}

func ScanDemandeEquipier(row *sql.Row) (DemandeEquipier, error) { return scanOneDemandeEquipier(row) }

// SelectAll returns all the items in the demande_equipiers table.
func SelectAllDemandeEquipiers(db DB) (DemandeEquipiers, error) {
	rows, err := db.Query("SELECT idequipier, iddemande, optionnel FROM demande_equipiers")
	if err != nil {
		return nil, err
	}
	return ScanDemandeEquipiers(rows)
}

type DemandeEquipiers []DemandeEquipier

func ScanDemandeEquipiers(rs *sql.Rows) (DemandeEquipiers, error) {
	var (
		item DemandeEquipier
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(DemandeEquipiers, 0, 16)
	for rs.Next() {
		item, err = scanOneDemandeEquipier(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item DemandeEquipier) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO demande_equipiers (
			idequipier, iddemande, optionnel
			) VALUES (
			$1, $2, $3
			);
			`, item.IdEquipier, item.IdDemande, item.Optionnel)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links DemandeEquipier in the database.
// It is a no-op if 'items' is empty.
func InsertManyDemandeEquipiers(tx *sql.Tx, items ...DemandeEquipier) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("demande_equipiers",
		"idequipier",
		"iddemande",
		"optionnel",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdEquipier, item.IdDemande, item.Optionnel)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link DemandeEquipier from the database.
// Only the foreign keys IdEquipier, IdDemande fields are used in 'item'.
func (item DemandeEquipier) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM demande_equipiers WHERE IdEquipier = $1 AND IdDemande = $2;`, item.IdEquipier, item.IdDemande)
	return err
}

// ByIdEquipier returns a map with 'IdEquipier' as keys.
func (items DemandeEquipiers) ByIdEquipier() map[camps.IdEquipier]DemandeEquipiers {
	out := make(map[camps.IdEquipier]DemandeEquipiers)
	for _, target := range items {
		out[target.IdEquipier] = append(out[target.IdEquipier], target)
	}
	return out
}

// IdEquipiers returns the list of ids of IdEquipier
// contained in this link table.
// They are not garanteed to be distinct.
func (items DemandeEquipiers) IdEquipiers() []camps.IdEquipier {
	out := make([]camps.IdEquipier, len(items))
	for index, target := range items {
		out[index] = target.IdEquipier
	}
	return out
}

func SelectDemandeEquipiersByIdEquipiers(tx DB, idEquipiers_ ...camps.IdEquipier) (DemandeEquipiers, error) {
	rows, err := tx.Query("SELECT idequipier, iddemande, optionnel FROM demande_equipiers WHERE idequipier = ANY($1)", camps.IdEquipierArrayToPQ(idEquipiers_))
	if err != nil {
		return nil, err
	}
	return ScanDemandeEquipiers(rows)
}

func DeleteDemandeEquipiersByIdEquipiers(tx DB, idEquipiers_ ...camps.IdEquipier) (DemandeEquipiers, error) {
	rows, err := tx.Query("DELETE FROM demande_equipiers WHERE idequipier = ANY($1) RETURNING idequipier, iddemande, optionnel", camps.IdEquipierArrayToPQ(idEquipiers_))
	if err != nil {
		return nil, err
	}
	return ScanDemandeEquipiers(rows)
}

// ByIdDemande returns a map with 'IdDemande' as keys.
func (items DemandeEquipiers) ByIdDemande() map[IdDemande]DemandeEquipiers {
	out := make(map[IdDemande]DemandeEquipiers)
	for _, target := range items {
		out[target.IdDemande] = append(out[target.IdDemande], target)
	}
	return out
}

// IdDemandes returns the list of ids of IdDemande
// contained in this link table.
// They are not garanteed to be distinct.
func (items DemandeEquipiers) IdDemandes() []IdDemande {
	out := make([]IdDemande, len(items))
	for index, target := range items {
		out[index] = target.IdDemande
	}
	return out
}

func SelectDemandeEquipiersByIdDemandes(tx DB, idDemandes_ ...IdDemande) (DemandeEquipiers, error) {
	rows, err := tx.Query("SELECT idequipier, iddemande, optionnel FROM demande_equipiers WHERE iddemande = ANY($1)", IdDemandeArrayToPQ(idDemandes_))
	if err != nil {
		return nil, err
	}
	return ScanDemandeEquipiers(rows)
}

func DeleteDemandeEquipiersByIdDemandes(tx DB, idDemandes_ ...IdDemande) (DemandeEquipiers, error) {
	rows, err := tx.Query("DELETE FROM demande_equipiers WHERE iddemande = ANY($1) RETURNING idequipier, iddemande, optionnel", IdDemandeArrayToPQ(idDemandes_))
	if err != nil {
		return nil, err
	}
	return ScanDemandeEquipiers(rows)
}

// SelectDemandeEquipierByIdEquipierAndIdDemande return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectDemandeEquipierByIdEquipierAndIdDemande(tx DB, idEquipier camps.IdEquipier, idDemande IdDemande) (item DemandeEquipier, found bool, err error) {
	row := tx.QueryRow("SELECT idequipier, iddemande, optionnel FROM demande_equipiers WHERE IdEquipier = $1 AND IdDemande = $2", idEquipier, idDemande)
	item, err = ScanDemandeEquipier(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneFile(row scanner) (File, error) {
	var item File
	err := row.Scan(
		&item.Id,
		&item.Taille,
		&item.NomClient,
		&item.DateHeureModif,
	)
	return item, err
}

func ScanFile(row *sql.Row) (File, error) { return scanOneFile(row) }

// SelectAll returns all the items in the files table.
func SelectAllFiles(db DB) (Files, error) {
	rows, err := db.Query("SELECT id, taille, nomclient, dateheuremodif FROM files")
	if err != nil {
		return nil, err
	}
	return ScanFiles(rows)
}

// SelectFile returns the entry matching 'id'.
func SelectFile(tx DB, id IdFile) (File, error) {
	row := tx.QueryRow("SELECT id, taille, nomclient, dateheuremodif FROM files WHERE id = $1", id)
	return ScanFile(row)
}

// SelectFiles returns the entry matching the given 'ids'.
func SelectFiles(tx DB, ids ...IdFile) (Files, error) {
	rows, err := tx.Query("SELECT id, taille, nomclient, dateheuremodif FROM files WHERE id = ANY($1)", IdFileArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanFiles(rows)
}

type Files map[IdFile]File

func (m Files) IDs() []IdFile {
	out := make([]IdFile, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanFiles(rs *sql.Rows) (Files, error) {
	var (
		s   File
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Files, 16)
	for rs.Next() {
		s, err = scanOneFile(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one File in the database and returns the item with id filled.
func (item File) Insert(tx DB) (out File, err error) {
	row := tx.QueryRow(`INSERT INTO files (
		taille, nomclient, dateheuremodif
		) VALUES (
		$1, $2, $3
		) RETURNING id, taille, nomclient, dateheuremodif;
		`, item.Taille, item.NomClient, item.DateHeureModif)
	return ScanFile(row)
}

// Update File in the database and returns the new version.
func (item File) Update(tx DB) (out File, err error) {
	row := tx.QueryRow(`UPDATE files SET (
		taille, nomclient, dateheuremodif
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING id, taille, nomclient, dateheuremodif;
		`, item.Taille, item.NomClient, item.DateHeureModif, item.Id)
	return ScanFile(row)
}

// Deletes the File and returns the item
func DeleteFileById(tx DB, id IdFile) (File, error) {
	row := tx.QueryRow("DELETE FROM files WHERE id = $1 RETURNING id, taille, nomclient, dateheuremodif;", id)
	return ScanFile(row)
}

// Deletes the File in the database and returns the ids.
func DeleteFilesByIDs(tx DB, ids ...IdFile) ([]IdFile, error) {
	rows, err := tx.Query("DELETE FROM files WHERE id = ANY($1) RETURNING id", IdFileArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdFileArray(rows)
}

func scanOneFileAide(row scanner) (FileAide, error) {
	var item FileAide
	err := row.Scan(
		&item.IdFile,
		&item.IdAide,
	)
	return item, err
}

func ScanFileAide(row *sql.Row) (FileAide, error) { return scanOneFileAide(row) }

// SelectAll returns all the items in the file_aides table.
func SelectAllFileAides(db DB) (FileAides, error) {
	rows, err := db.Query("SELECT idfile, idaide FROM file_aides")
	if err != nil {
		return nil, err
	}
	return ScanFileAides(rows)
}

type FileAides []FileAide

func ScanFileAides(rs *sql.Rows) (FileAides, error) {
	var (
		item FileAide
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(FileAides, 0, 16)
	for rs.Next() {
		item, err = scanOneFileAide(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item FileAide) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO file_aides (
			idfile, idaide
			) VALUES (
			$1, $2
			);
			`, item.IdFile, item.IdAide)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links FileAide in the database.
// It is a no-op if 'items' is empty.
func InsertManyFileAides(tx *sql.Tx, items ...FileAide) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("file_aides",
		"idfile",
		"idaide",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdFile, item.IdAide)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link FileAide from the database.
// Only the foreign keys IdFile, IdAide fields are used in 'item'.
func (item FileAide) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM file_aides WHERE IdFile = $1 AND IdAide = $2;`, item.IdFile, item.IdAide)
	return err
}

// ByIdFile returns a map with 'IdFile' as keys.
func (items FileAides) ByIdFile() map[IdFile]FileAide {
	out := make(map[IdFile]FileAide, len(items))
	for _, target := range items {
		out[target.IdFile] = target
	}
	return out
}

// IdFiles returns the list of ids of IdFile
// contained in this link table.
// They are not garanteed to be distinct.
func (items FileAides) IdFiles() []IdFile {
	out := make([]IdFile, len(items))
	for index, target := range items {
		out[index] = target.IdFile
	}
	return out
}

// SelectFileAideByIdFile return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectFileAideByIdFile(tx DB, idFile IdFile) (item FileAide, found bool, err error) {
	row := tx.QueryRow("SELECT idfile, idaide FROM file_aides WHERE idfile = $1", idFile)
	item, err = ScanFileAide(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectFileAidesByIdFiles(tx DB, idFiles_ ...IdFile) (FileAides, error) {
	rows, err := tx.Query("SELECT idfile, idaide FROM file_aides WHERE idfile = ANY($1)", IdFileArrayToPQ(idFiles_))
	if err != nil {
		return nil, err
	}
	return ScanFileAides(rows)
}

func DeleteFileAidesByIdFiles(tx DB, idFiles_ ...IdFile) (FileAides, error) {
	rows, err := tx.Query("DELETE FROM file_aides WHERE idfile = ANY($1) RETURNING idfile, idaide", IdFileArrayToPQ(idFiles_))
	if err != nil {
		return nil, err
	}
	return ScanFileAides(rows)
}

// ByIdAide returns a map with 'IdAide' as keys.
func (items FileAides) ByIdAide() map[camps.IdAide]FileAide {
	out := make(map[camps.IdAide]FileAide, len(items))
	for _, target := range items {
		out[target.IdAide] = target
	}
	return out
}

// IdAides returns the list of ids of IdAide
// contained in this link table.
// They are not garanteed to be distinct.
func (items FileAides) IdAides() []camps.IdAide {
	out := make([]camps.IdAide, len(items))
	for index, target := range items {
		out[index] = target.IdAide
	}
	return out
}

// SelectFileAideByIdAide return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectFileAideByIdAide(tx DB, idAide camps.IdAide) (item FileAide, found bool, err error) {
	row := tx.QueryRow("SELECT idfile, idaide FROM file_aides WHERE idaide = $1", idAide)
	item, err = ScanFileAide(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectFileAidesByIdAides(tx DB, idAides_ ...camps.IdAide) (FileAides, error) {
	rows, err := tx.Query("SELECT idfile, idaide FROM file_aides WHERE idaide = ANY($1)", camps.IdAideArrayToPQ(idAides_))
	if err != nil {
		return nil, err
	}
	return ScanFileAides(rows)
}

func DeleteFileAidesByIdAides(tx DB, idAides_ ...camps.IdAide) (FileAides, error) {
	rows, err := tx.Query("DELETE FROM file_aides WHERE idaide = ANY($1) RETURNING idfile, idaide", camps.IdAideArrayToPQ(idAides_))
	if err != nil {
		return nil, err
	}
	return ScanFileAides(rows)
}

func scanOneFileCamp(row scanner) (FileCamp, error) {
	var item FileCamp
	err := row.Scan(
		&item.IdFile,
		&item.IdCamp,
		&item.IsLettre,
	)
	return item, err
}

func ScanFileCamp(row *sql.Row) (FileCamp, error) { return scanOneFileCamp(row) }

// SelectAll returns all the items in the file_camps table.
func SelectAllFileCamps(db DB) (FileCamps, error) {
	rows, err := db.Query("SELECT idfile, idcamp, islettre FROM file_camps")
	if err != nil {
		return nil, err
	}
	return ScanFileCamps(rows)
}

type FileCamps []FileCamp

func ScanFileCamps(rs *sql.Rows) (FileCamps, error) {
	var (
		item FileCamp
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(FileCamps, 0, 16)
	for rs.Next() {
		item, err = scanOneFileCamp(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item FileCamp) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO file_camps (
			idfile, idcamp, islettre
			) VALUES (
			$1, $2, $3
			);
			`, item.IdFile, item.IdCamp, item.IsLettre)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links FileCamp in the database.
// It is a no-op if 'items' is empty.
func InsertManyFileCamps(tx *sql.Tx, items ...FileCamp) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("file_camps",
		"idfile",
		"idcamp",
		"islettre",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdFile, item.IdCamp, item.IsLettre)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link FileCamp from the database.
// Only the foreign keys IdFile, IdCamp fields are used in 'item'.
func (item FileCamp) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM file_camps WHERE IdFile = $1 AND IdCamp = $2;`, item.IdFile, item.IdCamp)
	return err
}

// ByIdFile returns a map with 'IdFile' as keys.
func (items FileCamps) ByIdFile() map[IdFile]FileCamp {
	out := make(map[IdFile]FileCamp, len(items))
	for _, target := range items {
		out[target.IdFile] = target
	}
	return out
}

// IdFiles returns the list of ids of IdFile
// contained in this link table.
// They are not garanteed to be distinct.
func (items FileCamps) IdFiles() []IdFile {
	out := make([]IdFile, len(items))
	for index, target := range items {
		out[index] = target.IdFile
	}
	return out
}

// SelectFileCampByIdFile return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectFileCampByIdFile(tx DB, idFile IdFile) (item FileCamp, found bool, err error) {
	row := tx.QueryRow("SELECT idfile, idcamp, islettre FROM file_camps WHERE idfile = $1", idFile)
	item, err = ScanFileCamp(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectFileCampsByIdFiles(tx DB, idFiles_ ...IdFile) (FileCamps, error) {
	rows, err := tx.Query("SELECT idfile, idcamp, islettre FROM file_camps WHERE idfile = ANY($1)", IdFileArrayToPQ(idFiles_))
	if err != nil {
		return nil, err
	}
	return ScanFileCamps(rows)
}

func DeleteFileCampsByIdFiles(tx DB, idFiles_ ...IdFile) (FileCamps, error) {
	rows, err := tx.Query("DELETE FROM file_camps WHERE idfile = ANY($1) RETURNING idfile, idcamp, islettre", IdFileArrayToPQ(idFiles_))
	if err != nil {
		return nil, err
	}
	return ScanFileCamps(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items FileCamps) ByIdCamp() map[camps.IdCamp]FileCamps {
	out := make(map[camps.IdCamp]FileCamps)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this link table.
// They are not garanteed to be distinct.
func (items FileCamps) IdCamps() []camps.IdCamp {
	out := make([]camps.IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

func SelectFileCampsByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (FileCamps, error) {
	rows, err := tx.Query("SELECT idfile, idcamp, islettre FROM file_camps WHERE idcamp = ANY($1)", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanFileCamps(rows)
}

func DeleteFileCampsByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (FileCamps, error) {
	rows, err := tx.Query("DELETE FROM file_camps WHERE idcamp = ANY($1) RETURNING idfile, idcamp, islettre", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanFileCamps(rows)
}

func scanOneFilePersonne(row scanner) (FilePersonne, error) {
	var item FilePersonne
	err := row.Scan(
		&item.IdFile,
		&item.IdPersonne,
		&item.IdDemande,
	)
	return item, err
}

func ScanFilePersonne(row *sql.Row) (FilePersonne, error) { return scanOneFilePersonne(row) }

// SelectAll returns all the items in the file_personnes table.
func SelectAllFilePersonnes(db DB) (FilePersonnes, error) {
	rows, err := db.Query("SELECT idfile, idpersonne, iddemande FROM file_personnes")
	if err != nil {
		return nil, err
	}
	return ScanFilePersonnes(rows)
}

type FilePersonnes []FilePersonne

func ScanFilePersonnes(rs *sql.Rows) (FilePersonnes, error) {
	var (
		item FilePersonne
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(FilePersonnes, 0, 16)
	for rs.Next() {
		item, err = scanOneFilePersonne(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item FilePersonne) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO file_personnes (
			idfile, idpersonne, iddemande
			) VALUES (
			$1, $2, $3
			);
			`, item.IdFile, item.IdPersonne, item.IdDemande)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links FilePersonne in the database.
// It is a no-op if 'items' is empty.
func InsertManyFilePersonnes(tx *sql.Tx, items ...FilePersonne) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("file_personnes",
		"idfile",
		"idpersonne",
		"iddemande",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdFile, item.IdPersonne, item.IdDemande)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link FilePersonne from the database.
// Only the foreign keys IdFile, IdPersonne, IdDemande fields are used in 'item'.
func (item FilePersonne) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM file_personnes WHERE IdFile = $1 AND IdPersonne = $2 AND IdDemande = $3;`, item.IdFile, item.IdPersonne, item.IdDemande)
	return err
}

// ByIdFile returns a map with 'IdFile' as keys.
func (items FilePersonnes) ByIdFile() map[IdFile]FilePersonne {
	out := make(map[IdFile]FilePersonne, len(items))
	for _, target := range items {
		out[target.IdFile] = target
	}
	return out
}

// IdFiles returns the list of ids of IdFile
// contained in this link table.
// They are not garanteed to be distinct.
func (items FilePersonnes) IdFiles() []IdFile {
	out := make([]IdFile, len(items))
	for index, target := range items {
		out[index] = target.IdFile
	}
	return out
}

// SelectFilePersonneByIdFile return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectFilePersonneByIdFile(tx DB, idFile IdFile) (item FilePersonne, found bool, err error) {
	row := tx.QueryRow("SELECT idfile, idpersonne, iddemande FROM file_personnes WHERE idfile = $1", idFile)
	item, err = ScanFilePersonne(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectFilePersonnesByIdFiles(tx DB, idFiles_ ...IdFile) (FilePersonnes, error) {
	rows, err := tx.Query("SELECT idfile, idpersonne, iddemande FROM file_personnes WHERE idfile = ANY($1)", IdFileArrayToPQ(idFiles_))
	if err != nil {
		return nil, err
	}
	return ScanFilePersonnes(rows)
}

func DeleteFilePersonnesByIdFiles(tx DB, idFiles_ ...IdFile) (FilePersonnes, error) {
	rows, err := tx.Query("DELETE FROM file_personnes WHERE idfile = ANY($1) RETURNING idfile, idpersonne, iddemande", IdFileArrayToPQ(idFiles_))
	if err != nil {
		return nil, err
	}
	return ScanFilePersonnes(rows)
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items FilePersonnes) ByIdPersonne() map[personnes.IdPersonne]FilePersonnes {
	out := make(map[personnes.IdPersonne]FilePersonnes)
	for _, target := range items {
		out[target.IdPersonne] = append(out[target.IdPersonne], target)
	}
	return out
}

// IdPersonnes returns the list of ids of IdPersonne
// contained in this link table.
// They are not garanteed to be distinct.
func (items FilePersonnes) IdPersonnes() []personnes.IdPersonne {
	out := make([]personnes.IdPersonne, len(items))
	for index, target := range items {
		out[index] = target.IdPersonne
	}
	return out
}

func SelectFilePersonnesByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) (FilePersonnes, error) {
	rows, err := tx.Query("SELECT idfile, idpersonne, iddemande FROM file_personnes WHERE idpersonne = ANY($1)", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanFilePersonnes(rows)
}

func DeleteFilePersonnesByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) (FilePersonnes, error) {
	rows, err := tx.Query("DELETE FROM file_personnes WHERE idpersonne = ANY($1) RETURNING idfile, idpersonne, iddemande", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanFilePersonnes(rows)
}

// ByIdDemande returns a map with 'IdDemande' as keys.
func (items FilePersonnes) ByIdDemande() map[IdDemande]FilePersonnes {
	out := make(map[IdDemande]FilePersonnes)
	for _, target := range items {
		out[target.IdDemande] = append(out[target.IdDemande], target)
	}
	return out
}

// IdDemandes returns the list of ids of IdDemande
// contained in this link table.
// They are not garanteed to be distinct.
func (items FilePersonnes) IdDemandes() []IdDemande {
	out := make([]IdDemande, len(items))
	for index, target := range items {
		out[index] = target.IdDemande
	}
	return out
}

func SelectFilePersonnesByIdDemandes(tx DB, idDemandes_ ...IdDemande) (FilePersonnes, error) {
	rows, err := tx.Query("SELECT idfile, idpersonne, iddemande FROM file_personnes WHERE iddemande = ANY($1)", IdDemandeArrayToPQ(idDemandes_))
	if err != nil {
		return nil, err
	}
	return ScanFilePersonnes(rows)
}

func DeleteFilePersonnesByIdDemandes(tx DB, idDemandes_ ...IdDemande) (FilePersonnes, error) {
	rows, err := tx.Query("DELETE FROM file_personnes WHERE iddemande = ANY($1) RETURNING idfile, idpersonne, iddemande", IdDemandeArrayToPQ(idDemandes_))
	if err != nil {
		return nil, err
	}
	return ScanFilePersonnes(rows)
}

func IdDemandeArrayToPQ(ids []IdDemande) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdDemandeArray scans the result of a query returning a
// list of ID's.
func ScanIdDemandeArray(rs *sql.Rows) ([]IdDemande, error) {
	defer rs.Close()
	ints := make([]IdDemande, 0, 16)
	var err error
	for rs.Next() {
		var s IdDemande
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdDemandeSet map[IdDemande]bool

func NewIdDemandeSetFrom(ids []IdDemande) IdDemandeSet {
	out := make(IdDemandeSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdDemandeSet) Add(id IdDemande) { s[id] = true }

func (s IdDemandeSet) Has(id IdDemande) bool { return s[id] }

func (s IdDemandeSet) Keys() []IdDemande {
	out := make([]IdDemande, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdFileArrayToPQ(ids []IdFile) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdFileArray scans the result of a query returning a
// list of ID's.
func ScanIdFileArray(rs *sql.Rows) ([]IdFile, error) {
	defer rs.Close()
	ints := make([]IdFile, 0, 16)
	var err error
	for rs.Next() {
		var s IdFile
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdFileSet map[IdFile]bool

func NewIdFileSetFrom(ids []IdFile) IdFileSet {
	out := make(IdFileSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdFileSet) Add(id IdFile) { s[id] = true }

func (s IdFileSet) Has(id IdFile) bool { return s[id] }

func (s IdFileSet) Keys() []IdFile {
	out := make([]IdFile, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *OptIdFile) Scan(src interface{}) error {
	var tmp sql.NullInt64
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = OptIdFile{
		Valid: tmp.Valid,
		Id:    IdFile(tmp.Int64),
	}
	return nil
}

func (s OptIdFile) Value() (driver.Value, error) {
	return sql.NullInt64{
		Int64: int64(s.Id),
		Valid: s.Valid}.Value()
}

func SwitchDemandePersonne(db DB, target personnes.OptIdPersonne, temporaire personnes.OptIdPersonne) error {
	_, err := db.Exec("UPDATE demandes SET IdDirecteur = $1 WHERE IdDirecteur = $2;", target, temporaire)
	return err
}

func SwitchFilePersonnePersonne(db DB, target personnes.IdPersonne, temporaire personnes.IdPersonne) error {
	_, err := db.Exec("UPDATE file_personnes SET IdPersonne = $1 WHERE IdPersonne = $2;", target, temporaire)
	return err
}
