package dons

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneDon(row scanner) (Don, error) {
	var item Don
	err := row.Scan(
		&item.Id,
		&item.Valeur,
		&item.ModePaiement,
		&item.Date,
		&item.Affectation,
		&item.Details,
		&item.Remercie,
		&item.IdPaiementHelloasso,
	)
	return item, err
}

func ScanDon(row *sql.Row) (Don, error) { return scanOneDon(row) }

// SelectAll returns all the items in the dons table.
func SelectAllDons(db DB) (Dons, error) {
	rows, err := db.Query("SELECT id, valeur, modepaiement, date, affectation, details, remercie, idpaiementhelloasso FROM dons")
	if err != nil {
		return nil, err
	}
	return ScanDons(rows)
}

// SelectDon returns the entry matching 'id'.
func SelectDon(tx DB, id IdDon) (Don, error) {
	row := tx.QueryRow("SELECT id, valeur, modepaiement, date, affectation, details, remercie, idpaiementhelloasso FROM dons WHERE id = $1", id)
	return ScanDon(row)
}

// SelectDons returns the entry matching the given 'ids'.
func SelectDons(tx DB, ids ...IdDon) (Dons, error) {
	rows, err := tx.Query("SELECT id, valeur, modepaiement, date, affectation, details, remercie, idpaiementhelloasso FROM dons WHERE id = ANY($1)", IdDonArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanDons(rows)
}

type Dons map[IdDon]Don

func (m Dons) IDs() []IdDon {
	out := make([]IdDon, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanDons(rs *sql.Rows) (Dons, error) {
	var (
		s   Don
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Dons, 16)
	for rs.Next() {
		s, err = scanOneDon(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Don in the database and returns the item with id filled.
func (item Don) Insert(tx DB) (out Don, err error) {
	row := tx.QueryRow(`INSERT INTO dons (
		valeur, modepaiement, date, affectation, details, remercie, idpaiementhelloasso
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7
		) RETURNING id, valeur, modepaiement, date, affectation, details, remercie, idpaiementhelloasso;
		`, item.Valeur, item.ModePaiement, item.Date, item.Affectation, item.Details, item.Remercie, item.IdPaiementHelloasso)
	return ScanDon(row)
}

// Update Don in the database and returns the new version.
func (item Don) Update(tx DB) (out Don, err error) {
	row := tx.QueryRow(`UPDATE dons SET (
		valeur, modepaiement, date, affectation, details, remercie, idpaiementhelloasso
		) = (
		$1, $2, $3, $4, $5, $6, $7
		) WHERE id = $8 RETURNING id, valeur, modepaiement, date, affectation, details, remercie, idpaiementhelloasso;
		`, item.Valeur, item.ModePaiement, item.Date, item.Affectation, item.Details, item.Remercie, item.IdPaiementHelloasso, item.Id)
	return ScanDon(row)
}

// Deletes the Don and returns the item
func DeleteDonById(tx DB, id IdDon) (Don, error) {
	row := tx.QueryRow("DELETE FROM dons WHERE id = $1 RETURNING id, valeur, modepaiement, date, affectation, details, remercie, idpaiementhelloasso;", id)
	return ScanDon(row)
}

// Deletes the Don in the database and returns the ids.
func DeleteDonsByIDs(tx DB, ids ...IdDon) ([]IdDon, error) {
	rows, err := tx.Query("DELETE FROM dons WHERE id = ANY($1) RETURNING id", IdDonArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdDonArray(rows)
}

func IdDonArrayToPQ(ids []IdDon) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdDonArray scans the result of a query returning a
// list of ID's.
func ScanIdDonArray(rs *sql.Rows) ([]IdDon, error) {
	defer rs.Close()
	ints := make([]IdDon, 0, 16)
	var err error
	for rs.Next() {
		var s IdDon
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdDonSet map[IdDon]bool

func NewIdDonSetFrom(ids []IdDon) IdDonSet {
	out := make(IdDonSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdDonSet) Add(id IdDon) { s[id] = true }

func (s IdDonSet) Has(id IdDon) bool { return s[id] }

func (s IdDonSet) Keys() []IdDon {
	out := make([]IdDon, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}
