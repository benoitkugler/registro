package events

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"

	"registro/sql/camps"
	"registro/sql/dossiers"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...any) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...any) (sql.Result, error)
	Query(query string, args ...any) (*sql.Rows, error)
	QueryRow(query string, args ...any) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneEvent(row scanner) (Event, error) {
	var item Event
	err := row.Scan(
		&item.Id,
		&item.IdDossier,
		&item.Kind,
		&item.Created,
	)
	return item, err
}

func ScanEvent(row *sql.Row) (Event, error) { return scanOneEvent(row) }

// SelectAll returns all the items in the events table.
func SelectAllEvents(db DB) (Events, error) {
	rows, err := db.Query("SELECT id, iddossier, kind, created FROM events")
	if err != nil {
		return nil, err
	}
	return ScanEvents(rows)
}

// SelectEvent returns the entry matching 'id'.
func SelectEvent(tx DB, id IdEvent) (Event, error) {
	row := tx.QueryRow("SELECT id, iddossier, kind, created FROM events WHERE id = $1", id)
	return ScanEvent(row)
}

// SelectEvents returns the entry matching the given 'ids'.
func SelectEvents(tx DB, ids ...IdEvent) (Events, error) {
	rows, err := tx.Query("SELECT id, iddossier, kind, created FROM events WHERE id = ANY($1)", IdEventArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanEvents(rows)
}

type Events map[IdEvent]Event

func (m Events) IDs() []IdEvent {
	out := make([]IdEvent, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanEvents(rs *sql.Rows) (Events, error) {
	var (
		s   Event
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Events, 16)
	for rs.Next() {
		s, err = scanOneEvent(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Event in the database and returns the item with id filled.
func (item Event) Insert(tx DB) (out Event, err error) {
	row := tx.QueryRow(`INSERT INTO events (
		iddossier, kind, created
		) VALUES (
		$1, $2, $3
		) RETURNING id, iddossier, kind, created;
		`, item.IdDossier, item.Kind, item.Created)
	return ScanEvent(row)
}

// Update Event in the database and returns the new version.
func (item Event) Update(tx DB) (out Event, err error) {
	row := tx.QueryRow(`UPDATE events SET (
		iddossier, kind, created
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING id, iddossier, kind, created;
		`, item.IdDossier, item.Kind, item.Created, item.Id)
	return ScanEvent(row)
}

// Deletes the Event and returns the item
func DeleteEventById(tx DB, id IdEvent) (Event, error) {
	row := tx.QueryRow("DELETE FROM events WHERE id = $1 RETURNING id, iddossier, kind, created;", id)
	return ScanEvent(row)
}

// Deletes the Event in the database and returns the ids.
func DeleteEventsByIDs(tx DB, ids ...IdEvent) ([]IdEvent, error) {
	rows, err := tx.Query("DELETE FROM events WHERE id = ANY($1) RETURNING id", IdEventArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdEventArray(rows)
}

func scanOneEventAttestation(row scanner) (EventAttestation, error) {
	var item EventAttestation
	err := row.Scan(
		&item.IdEvent,
		&item.Distribution,
		&item.IsPresence,
	)
	return item, err
}

func ScanEventAttestation(row *sql.Row) (EventAttestation, error) {
	return scanOneEventAttestation(row)
}

// SelectAll returns all the items in the event_attestations table.
func SelectAllEventAttestations(db DB) (EventAttestations, error) {
	rows, err := db.Query("SELECT idevent, distribution, ispresence FROM event_attestations")
	if err != nil {
		return nil, err
	}
	return ScanEventAttestations(rows)
}

type EventAttestations []EventAttestation

func ScanEventAttestations(rs *sql.Rows) (EventAttestations, error) {
	var (
		item EventAttestation
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(EventAttestations, 0, 16)
	for rs.Next() {
		item, err = scanOneEventAttestation(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item EventAttestation) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO event_attestations (
			idevent, distribution, ispresence
			) VALUES (
			$1, $2, $3
			);
			`, item.IdEvent, item.Distribution, item.IsPresence)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links EventAttestation in the database.
// It is a no-op if 'items' is empty.
func InsertManyEventAttestations(tx *sql.Tx, items ...EventAttestation) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("event_attestations",
		"idevent",
		"distribution",
		"ispresence",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdEvent, item.Distribution, item.IsPresence)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link EventAttestation from the database.
// Only the foreign keys IdEvent fields are used in 'item'.
func (item EventAttestation) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM event_attestations WHERE IdEvent = $1;`, item.IdEvent)
	return err
}

// ByIdEvent returns a map with 'IdEvent' as keys.
func (items EventAttestations) ByIdEvent() map[IdEvent]EventAttestation {
	out := make(map[IdEvent]EventAttestation, len(items))
	for _, target := range items {
		out[target.IdEvent] = target
	}
	return out
}

// IdEvents returns the list of ids of IdEvent
// contained in this table.
// They are not garanteed to be distinct.
func (items EventAttestations) IdEvents() []IdEvent {
	out := make([]IdEvent, len(items))
	for index, target := range items {
		out[index] = target.IdEvent
	}
	return out
}

// SelectEventAttestationByIdEvent return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEventAttestationByIdEvent(tx DB, idEvent IdEvent) (item EventAttestation, found bool, err error) {
	row := tx.QueryRow("SELECT idevent, distribution, ispresence FROM event_attestations WHERE idevent = $1", idEvent)
	item, err = ScanEventAttestation(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectEventAttestationsByIdEvents(tx DB, idEvents_ ...IdEvent) (EventAttestations, error) {
	rows, err := tx.Query("SELECT idevent, distribution, ispresence FROM event_attestations WHERE idevent = ANY($1)", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventAttestations(rows)
}

func DeleteEventAttestationsByIdEvents(tx DB, idEvents_ ...IdEvent) (EventAttestations, error) {
	rows, err := tx.Query("DELETE FROM event_attestations WHERE idevent = ANY($1) RETURNING idevent, distribution, ispresence", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventAttestations(rows)
}

func scanOneEventCampDocs(row scanner) (EventCampDocs, error) {
	var item EventCampDocs
	err := row.Scan(
		&item.IdEvent,
		&item.IdCamp,
	)
	return item, err
}

func ScanEventCampDocs(row *sql.Row) (EventCampDocs, error) { return scanOneEventCampDocs(row) }

// SelectAll returns all the items in the event_camp_docss table.
func SelectAllEventCampDocss(db DB) (EventCampDocss, error) {
	rows, err := db.Query("SELECT idevent, idcamp FROM event_camp_docss")
	if err != nil {
		return nil, err
	}
	return ScanEventCampDocss(rows)
}

type EventCampDocss []EventCampDocs

func ScanEventCampDocss(rs *sql.Rows) (EventCampDocss, error) {
	var (
		item EventCampDocs
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(EventCampDocss, 0, 16)
	for rs.Next() {
		item, err = scanOneEventCampDocs(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item EventCampDocs) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO event_camp_docss (
			idevent, idcamp
			) VALUES (
			$1, $2
			);
			`, item.IdEvent, item.IdCamp)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links EventCampDocs in the database.
// It is a no-op if 'items' is empty.
func InsertManyEventCampDocss(tx *sql.Tx, items ...EventCampDocs) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("event_camp_docss",
		"idevent",
		"idcamp",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdEvent, item.IdCamp)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link EventCampDocs from the database.
// Only the foreign keys IdEvent, IdCamp fields are used in 'item'.
func (item EventCampDocs) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM event_camp_docss WHERE IdEvent = $1 AND IdCamp = $2;`, item.IdEvent, item.IdCamp)
	return err
}

// ByIdEvent returns a map with 'IdEvent' as keys.
func (items EventCampDocss) ByIdEvent() map[IdEvent]EventCampDocs {
	out := make(map[IdEvent]EventCampDocs, len(items))
	for _, target := range items {
		out[target.IdEvent] = target
	}
	return out
}

// IdEvents returns the list of ids of IdEvent
// contained in this table.
// They are not garanteed to be distinct.
func (items EventCampDocss) IdEvents() []IdEvent {
	out := make([]IdEvent, len(items))
	for index, target := range items {
		out[index] = target.IdEvent
	}
	return out
}

// SelectEventCampDocsByIdEvent return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEventCampDocsByIdEvent(tx DB, idEvent IdEvent) (item EventCampDocs, found bool, err error) {
	row := tx.QueryRow("SELECT idevent, idcamp FROM event_camp_docss WHERE idevent = $1", idEvent)
	item, err = ScanEventCampDocs(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectEventCampDocssByIdEvents(tx DB, idEvents_ ...IdEvent) (EventCampDocss, error) {
	rows, err := tx.Query("SELECT idevent, idcamp FROM event_camp_docss WHERE idevent = ANY($1)", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventCampDocss(rows)
}

func DeleteEventCampDocssByIdEvents(tx DB, idEvents_ ...IdEvent) (EventCampDocss, error) {
	rows, err := tx.Query("DELETE FROM event_camp_docss WHERE idevent = ANY($1) RETURNING idevent, idcamp", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventCampDocss(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items EventCampDocss) ByIdCamp() map[camps.IdCamp]EventCampDocss {
	out := make(map[camps.IdCamp]EventCampDocss)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this table.
// They are not garanteed to be distinct.
func (items EventCampDocss) IdCamps() []camps.IdCamp {
	out := make([]camps.IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

func SelectEventCampDocssByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (EventCampDocss, error) {
	rows, err := tx.Query("SELECT idevent, idcamp FROM event_camp_docss WHERE idcamp = ANY($1)", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEventCampDocss(rows)
}

func DeleteEventCampDocssByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (EventCampDocss, error) {
	rows, err := tx.Query("DELETE FROM event_camp_docss WHERE idcamp = ANY($1) RETURNING idevent, idcamp", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEventCampDocss(rows)
}

func scanOneEventMessage(row scanner) (EventMessage, error) {
	var item EventMessage
	err := row.Scan(
		&item.IdEvent,
		&item.Contenu,
		&item.Origine,
		&item.OrigineCamp,
		&item.VuBackoffice,
		&item.VuEspaceperso,
		&item.VuFondSoutien,
		&item.OnlyToFondSoutien,
	)
	return item, err
}

func ScanEventMessage(row *sql.Row) (EventMessage, error) { return scanOneEventMessage(row) }

// SelectAll returns all the items in the event_messages table.
func SelectAllEventMessages(db DB) (EventMessages, error) {
	rows, err := db.Query("SELECT idevent, contenu, origine, originecamp, vubackoffice, vuespaceperso, vufondsoutien, onlytofondsoutien FROM event_messages")
	if err != nil {
		return nil, err
	}
	return ScanEventMessages(rows)
}

type EventMessages []EventMessage

func ScanEventMessages(rs *sql.Rows) (EventMessages, error) {
	var (
		item EventMessage
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(EventMessages, 0, 16)
	for rs.Next() {
		item, err = scanOneEventMessage(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item EventMessage) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO event_messages (
			idevent, contenu, origine, originecamp, vubackoffice, vuespaceperso, vufondsoutien, onlytofondsoutien
			) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8
			);
			`, item.IdEvent, item.Contenu, item.Origine, item.OrigineCamp, item.VuBackoffice, item.VuEspaceperso, item.VuFondSoutien, item.OnlyToFondSoutien)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links EventMessage in the database.
// It is a no-op if 'items' is empty.
func InsertManyEventMessages(tx *sql.Tx, items ...EventMessage) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("event_messages",
		"idevent",
		"contenu",
		"origine",
		"originecamp",
		"vubackoffice",
		"vuespaceperso",
		"vufondsoutien",
		"onlytofondsoutien",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdEvent, item.Contenu, item.Origine, item.OrigineCamp, item.VuBackoffice, item.VuEspaceperso, item.VuFondSoutien, item.OnlyToFondSoutien)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link EventMessage from the database.
// Only the foreign keys IdEvent, OrigineCamp fields are used in 'item'.
func (item EventMessage) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM event_messages WHERE IdEvent = $1 AND ((OrigineCamp IS NULL AND $2 IS NULL) OR OrigineCamp = $2);`, item.IdEvent, item.OrigineCamp)
	return err
}

func scanOneEventMessageVu(row scanner) (EventMessageVu, error) {
	var item EventMessageVu
	err := row.Scan(
		&item.IdEvent,
		&item.IdCamp,
	)
	return item, err
}

func ScanEventMessageVu(row *sql.Row) (EventMessageVu, error) { return scanOneEventMessageVu(row) }

// SelectAll returns all the items in the event_message_vus table.
func SelectAllEventMessageVus(db DB) (EventMessageVus, error) {
	rows, err := db.Query("SELECT idevent, idcamp FROM event_message_vus")
	if err != nil {
		return nil, err
	}
	return ScanEventMessageVus(rows)
}

type EventMessageVus []EventMessageVu

func ScanEventMessageVus(rs *sql.Rows) (EventMessageVus, error) {
	var (
		item EventMessageVu
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(EventMessageVus, 0, 16)
	for rs.Next() {
		item, err = scanOneEventMessageVu(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item EventMessageVu) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO event_message_vus (
			idevent, idcamp
			) VALUES (
			$1, $2
			);
			`, item.IdEvent, item.IdCamp)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links EventMessageVu in the database.
// It is a no-op if 'items' is empty.
func InsertManyEventMessageVus(tx *sql.Tx, items ...EventMessageVu) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("event_message_vus",
		"idevent",
		"idcamp",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdEvent, item.IdCamp)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link EventMessageVu from the database.
// Only the foreign keys IdEvent, IdCamp fields are used in 'item'.
func (item EventMessageVu) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM event_message_vus WHERE IdEvent = $1 AND IdCamp = $2;`, item.IdEvent, item.IdCamp)
	return err
}

// ByIdEvent returns a map with 'IdEvent' as keys.
func (items EventMessageVus) ByIdEvent() map[IdEvent]EventMessageVus {
	out := make(map[IdEvent]EventMessageVus)
	for _, target := range items {
		out[target.IdEvent] = append(out[target.IdEvent], target)
	}
	return out
}

// IdEvents returns the list of ids of IdEvent
// contained in this table.
// They are not garanteed to be distinct.
func (items EventMessageVus) IdEvents() []IdEvent {
	out := make([]IdEvent, len(items))
	for index, target := range items {
		out[index] = target.IdEvent
	}
	return out
}

func SelectEventMessageVusByIdEvents(tx DB, idEvents_ ...IdEvent) (EventMessageVus, error) {
	rows, err := tx.Query("SELECT idevent, idcamp FROM event_message_vus WHERE idevent = ANY($1)", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventMessageVus(rows)
}

func DeleteEventMessageVusByIdEvents(tx DB, idEvents_ ...IdEvent) (EventMessageVus, error) {
	rows, err := tx.Query("DELETE FROM event_message_vus WHERE idevent = ANY($1) RETURNING idevent, idcamp", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventMessageVus(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items EventMessageVus) ByIdCamp() map[camps.IdCamp]EventMessageVus {
	out := make(map[camps.IdCamp]EventMessageVus)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this table.
// They are not garanteed to be distinct.
func (items EventMessageVus) IdCamps() []camps.IdCamp {
	out := make([]camps.IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

func SelectEventMessageVusByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (EventMessageVus, error) {
	rows, err := tx.Query("SELECT idevent, idcamp FROM event_message_vus WHERE idcamp = ANY($1)", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEventMessageVus(rows)
}

func DeleteEventMessageVusByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (EventMessageVus, error) {
	rows, err := tx.Query("DELETE FROM event_message_vus WHERE idcamp = ANY($1) RETURNING idevent, idcamp", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEventMessageVus(rows)
}

// SelectEventMessageVuByIdEventAndIdCamp return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEventMessageVuByIdEventAndIdCamp(tx DB, idEvent IdEvent, idCamp camps.IdCamp) (item EventMessageVu, found bool, err error) {
	row := tx.QueryRow("SELECT idevent, idcamp FROM event_message_vus WHERE IdEvent = $1 AND IdCamp = $2", idEvent, idCamp)
	item, err = ScanEventMessageVu(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

// ByIdEvent returns a map with 'IdEvent' as keys.
func (items EventMessages) ByIdEvent() map[IdEvent]EventMessage {
	out := make(map[IdEvent]EventMessage, len(items))
	for _, target := range items {
		out[target.IdEvent] = target
	}
	return out
}

// IdEvents returns the list of ids of IdEvent
// contained in this table.
// They are not garanteed to be distinct.
func (items EventMessages) IdEvents() []IdEvent {
	out := make([]IdEvent, len(items))
	for index, target := range items {
		out[index] = target.IdEvent
	}
	return out
}

// SelectEventMessageByIdEvent return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEventMessageByIdEvent(tx DB, idEvent IdEvent) (item EventMessage, found bool, err error) {
	row := tx.QueryRow("SELECT idevent, contenu, origine, originecamp, vubackoffice, vuespaceperso, vufondsoutien, onlytofondsoutien FROM event_messages WHERE idevent = $1", idEvent)
	item, err = ScanEventMessage(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectEventMessagesByIdEvents(tx DB, idEvents_ ...IdEvent) (EventMessages, error) {
	rows, err := tx.Query("SELECT idevent, contenu, origine, originecamp, vubackoffice, vuespaceperso, vufondsoutien, onlytofondsoutien FROM event_messages WHERE idevent = ANY($1)", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventMessages(rows)
}

func DeleteEventMessagesByIdEvents(tx DB, idEvents_ ...IdEvent) (EventMessages, error) {
	rows, err := tx.Query("DELETE FROM event_messages WHERE idevent = ANY($1) RETURNING idevent, contenu, origine, originecamp, vubackoffice, vuespaceperso, vufondsoutien, onlytofondsoutien", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventMessages(rows)
}

func SelectEventMessagesByOrigineCamps(tx DB, origineCamps_ ...camps.IdCamp) (EventMessages, error) {
	rows, err := tx.Query("SELECT idevent, contenu, origine, originecamp, vubackoffice, vuespaceperso, vufondsoutien, onlytofondsoutien FROM event_messages WHERE originecamp = ANY($1)", camps.IdCampArrayToPQ(origineCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEventMessages(rows)
}

func DeleteEventMessagesByOrigineCamps(tx DB, origineCamps_ ...camps.IdCamp) (EventMessages, error) {
	rows, err := tx.Query("DELETE FROM event_messages WHERE originecamp = ANY($1) RETURNING idevent, contenu, origine, originecamp, vubackoffice, vuespaceperso, vufondsoutien, onlytofondsoutien", camps.IdCampArrayToPQ(origineCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEventMessages(rows)
}

func scanOneEventPlaceLiberee(row scanner) (EventPlaceLiberee, error) {
	var item EventPlaceLiberee
	err := row.Scan(
		&item.IdEvent,
		&item.IdParticipant,
		&item.Accepted,
	)
	return item, err
}

func ScanEventPlaceLiberee(row *sql.Row) (EventPlaceLiberee, error) {
	return scanOneEventPlaceLiberee(row)
}

// SelectAll returns all the items in the event_place_liberees table.
func SelectAllEventPlaceLiberees(db DB) (EventPlaceLiberees, error) {
	rows, err := db.Query("SELECT idevent, idparticipant, accepted FROM event_place_liberees")
	if err != nil {
		return nil, err
	}
	return ScanEventPlaceLiberees(rows)
}

type EventPlaceLiberees []EventPlaceLiberee

func ScanEventPlaceLiberees(rs *sql.Rows) (EventPlaceLiberees, error) {
	var (
		item EventPlaceLiberee
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(EventPlaceLiberees, 0, 16)
	for rs.Next() {
		item, err = scanOneEventPlaceLiberee(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item EventPlaceLiberee) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO event_place_liberees (
			idevent, idparticipant, accepted
			) VALUES (
			$1, $2, $3
			);
			`, item.IdEvent, item.IdParticipant, item.Accepted)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links EventPlaceLiberee in the database.
// It is a no-op if 'items' is empty.
func InsertManyEventPlaceLiberees(tx *sql.Tx, items ...EventPlaceLiberee) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("event_place_liberees",
		"idevent",
		"idparticipant",
		"accepted",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdEvent, item.IdParticipant, item.Accepted)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link EventPlaceLiberee from the database.
// Only the foreign keys IdEvent, IdParticipant fields are used in 'item'.
func (item EventPlaceLiberee) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM event_place_liberees WHERE IdEvent = $1 AND IdParticipant = $2;`, item.IdEvent, item.IdParticipant)
	return err
}

// ByIdEvent returns a map with 'IdEvent' as keys.
func (items EventPlaceLiberees) ByIdEvent() map[IdEvent]EventPlaceLiberee {
	out := make(map[IdEvent]EventPlaceLiberee, len(items))
	for _, target := range items {
		out[target.IdEvent] = target
	}
	return out
}

// IdEvents returns the list of ids of IdEvent
// contained in this table.
// They are not garanteed to be distinct.
func (items EventPlaceLiberees) IdEvents() []IdEvent {
	out := make([]IdEvent, len(items))
	for index, target := range items {
		out[index] = target.IdEvent
	}
	return out
}

// SelectEventPlaceLibereeByIdEvent return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEventPlaceLibereeByIdEvent(tx DB, idEvent IdEvent) (item EventPlaceLiberee, found bool, err error) {
	row := tx.QueryRow("SELECT idevent, idparticipant, accepted FROM event_place_liberees WHERE idevent = $1", idEvent)
	item, err = ScanEventPlaceLiberee(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectEventPlaceLibereesByIdEvents(tx DB, idEvents_ ...IdEvent) (EventPlaceLiberees, error) {
	rows, err := tx.Query("SELECT idevent, idparticipant, accepted FROM event_place_liberees WHERE idevent = ANY($1)", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventPlaceLiberees(rows)
}

func DeleteEventPlaceLibereesByIdEvents(tx DB, idEvents_ ...IdEvent) (EventPlaceLiberees, error) {
	rows, err := tx.Query("DELETE FROM event_place_liberees WHERE idevent = ANY($1) RETURNING idevent, idparticipant, accepted", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventPlaceLiberees(rows)
}

// ByIdParticipant returns a map with 'IdParticipant' as keys.
func (items EventPlaceLiberees) ByIdParticipant() map[camps.IdParticipant]EventPlaceLiberees {
	out := make(map[camps.IdParticipant]EventPlaceLiberees)
	for _, target := range items {
		out[target.IdParticipant] = append(out[target.IdParticipant], target)
	}
	return out
}

// IdParticipants returns the list of ids of IdParticipant
// contained in this table.
// They are not garanteed to be distinct.
func (items EventPlaceLiberees) IdParticipants() []camps.IdParticipant {
	out := make([]camps.IdParticipant, len(items))
	for index, target := range items {
		out[index] = target.IdParticipant
	}
	return out
}

func SelectEventPlaceLibereesByIdParticipants(tx DB, idParticipants_ ...camps.IdParticipant) (EventPlaceLiberees, error) {
	rows, err := tx.Query("SELECT idevent, idparticipant, accepted FROM event_place_liberees WHERE idparticipant = ANY($1)", camps.IdParticipantArrayToPQ(idParticipants_))
	if err != nil {
		return nil, err
	}
	return ScanEventPlaceLiberees(rows)
}

func DeleteEventPlaceLibereesByIdParticipants(tx DB, idParticipants_ ...camps.IdParticipant) (EventPlaceLiberees, error) {
	rows, err := tx.Query("DELETE FROM event_place_liberees WHERE idparticipant = ANY($1) RETURNING idevent, idparticipant, accepted", camps.IdParticipantArrayToPQ(idParticipants_))
	if err != nil {
		return nil, err
	}
	return ScanEventPlaceLiberees(rows)
}

func scanOneEventSondage(row scanner) (EventSondage, error) {
	var item EventSondage
	err := row.Scan(
		&item.IdEvent,
		&item.IdCamp,
	)
	return item, err
}

func ScanEventSondage(row *sql.Row) (EventSondage, error) { return scanOneEventSondage(row) }

// SelectAll returns all the items in the event_sondages table.
func SelectAllEventSondages(db DB) (EventSondages, error) {
	rows, err := db.Query("SELECT idevent, idcamp FROM event_sondages")
	if err != nil {
		return nil, err
	}
	return ScanEventSondages(rows)
}

type EventSondages []EventSondage

func ScanEventSondages(rs *sql.Rows) (EventSondages, error) {
	var (
		item EventSondage
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(EventSondages, 0, 16)
	for rs.Next() {
		item, err = scanOneEventSondage(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item EventSondage) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO event_sondages (
			idevent, idcamp
			) VALUES (
			$1, $2
			);
			`, item.IdEvent, item.IdCamp)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links EventSondage in the database.
// It is a no-op if 'items' is empty.
func InsertManyEventSondages(tx *sql.Tx, items ...EventSondage) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("event_sondages",
		"idevent",
		"idcamp",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdEvent, item.IdCamp)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link EventSondage from the database.
// Only the foreign keys IdEvent, IdCamp fields are used in 'item'.
func (item EventSondage) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM event_sondages WHERE IdEvent = $1 AND IdCamp = $2;`, item.IdEvent, item.IdCamp)
	return err
}

// ByIdEvent returns a map with 'IdEvent' as keys.
func (items EventSondages) ByIdEvent() map[IdEvent]EventSondage {
	out := make(map[IdEvent]EventSondage, len(items))
	for _, target := range items {
		out[target.IdEvent] = target
	}
	return out
}

// IdEvents returns the list of ids of IdEvent
// contained in this table.
// They are not garanteed to be distinct.
func (items EventSondages) IdEvents() []IdEvent {
	out := make([]IdEvent, len(items))
	for index, target := range items {
		out[index] = target.IdEvent
	}
	return out
}

// SelectEventSondageByIdEvent return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEventSondageByIdEvent(tx DB, idEvent IdEvent) (item EventSondage, found bool, err error) {
	row := tx.QueryRow("SELECT idevent, idcamp FROM event_sondages WHERE idevent = $1", idEvent)
	item, err = ScanEventSondage(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectEventSondagesByIdEvents(tx DB, idEvents_ ...IdEvent) (EventSondages, error) {
	rows, err := tx.Query("SELECT idevent, idcamp FROM event_sondages WHERE idevent = ANY($1)", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventSondages(rows)
}

func DeleteEventSondagesByIdEvents(tx DB, idEvents_ ...IdEvent) (EventSondages, error) {
	rows, err := tx.Query("DELETE FROM event_sondages WHERE idevent = ANY($1) RETURNING idevent, idcamp", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventSondages(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items EventSondages) ByIdCamp() map[camps.IdCamp]EventSondages {
	out := make(map[camps.IdCamp]EventSondages)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this table.
// They are not garanteed to be distinct.
func (items EventSondages) IdCamps() []camps.IdCamp {
	out := make([]camps.IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

func SelectEventSondagesByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (EventSondages, error) {
	rows, err := tx.Query("SELECT idevent, idcamp FROM event_sondages WHERE idcamp = ANY($1)", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEventSondages(rows)
}

func DeleteEventSondagesByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (EventSondages, error) {
	rows, err := tx.Query("DELETE FROM event_sondages WHERE idcamp = ANY($1) RETURNING idevent, idcamp", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEventSondages(rows)
}

func scanOneEventValidation(row scanner) (EventValidation, error) {
	var item EventValidation
	err := row.Scan(
		&item.IdEvent,
		&item.IdCamp,
	)
	return item, err
}

func ScanEventValidation(row *sql.Row) (EventValidation, error) { return scanOneEventValidation(row) }

// SelectAll returns all the items in the event_validations table.
func SelectAllEventValidations(db DB) (EventValidations, error) {
	rows, err := db.Query("SELECT idevent, idcamp FROM event_validations")
	if err != nil {
		return nil, err
	}
	return ScanEventValidations(rows)
}

type EventValidations []EventValidation

func ScanEventValidations(rs *sql.Rows) (EventValidations, error) {
	var (
		item EventValidation
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(EventValidations, 0, 16)
	for rs.Next() {
		item, err = scanOneEventValidation(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item EventValidation) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO event_validations (
			idevent, idcamp
			) VALUES (
			$1, $2
			);
			`, item.IdEvent, item.IdCamp)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links EventValidation in the database.
// It is a no-op if 'items' is empty.
func InsertManyEventValidations(tx *sql.Tx, items ...EventValidation) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("event_validations",
		"idevent",
		"idcamp",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdEvent, item.IdCamp)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link EventValidation from the database.
// Only the foreign keys IdEvent fields are used in 'item'.
func (item EventValidation) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM event_validations WHERE IdEvent = $1;`, item.IdEvent)
	return err
}

// ByIdEvent returns a map with 'IdEvent' as keys.
func (items EventValidations) ByIdEvent() map[IdEvent]EventValidation {
	out := make(map[IdEvent]EventValidation, len(items))
	for _, target := range items {
		out[target.IdEvent] = target
	}
	return out
}

// IdEvents returns the list of ids of IdEvent
// contained in this table.
// They are not garanteed to be distinct.
func (items EventValidations) IdEvents() []IdEvent {
	out := make([]IdEvent, len(items))
	for index, target := range items {
		out[index] = target.IdEvent
	}
	return out
}

// SelectEventValidationByIdEvent return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEventValidationByIdEvent(tx DB, idEvent IdEvent) (item EventValidation, found bool, err error) {
	row := tx.QueryRow("SELECT idevent, idcamp FROM event_validations WHERE idevent = $1", idEvent)
	item, err = ScanEventValidation(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectEventValidationsByIdEvents(tx DB, idEvents_ ...IdEvent) (EventValidations, error) {
	rows, err := tx.Query("SELECT idevent, idcamp FROM event_validations WHERE idevent = ANY($1)", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventValidations(rows)
}

func DeleteEventValidationsByIdEvents(tx DB, idEvents_ ...IdEvent) (EventValidations, error) {
	rows, err := tx.Query("DELETE FROM event_validations WHERE idevent = ANY($1) RETURNING idevent, idcamp", IdEventArrayToPQ(idEvents_))
	if err != nil {
		return nil, err
	}
	return ScanEventValidations(rows)
}

// ByIdDossier returns a map with 'IdDossier' as keys.
func (items Events) ByIdDossier() map[dossiers.IdDossier]Events {
	out := make(map[dossiers.IdDossier]Events)
	for _, target := range items {
		dict := out[target.IdDossier]
		if dict == nil {
			dict = make(Events)
		}
		dict[target.Id] = target
		out[target.IdDossier] = dict
	}
	return out
}

// IdDossiers returns the list of ids of IdDossier
// contained in this table.
// They are not garanteed to be distinct.
func (items Events) IdDossiers() []dossiers.IdDossier {
	out := make([]dossiers.IdDossier, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdDossier)
	}
	return out
}

func SelectEventsByIdDossiers(tx DB, idDossiers_ ...dossiers.IdDossier) (Events, error) {
	rows, err := tx.Query("SELECT id, iddossier, kind, created FROM events WHERE iddossier = ANY($1)", dossiers.IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanEvents(rows)
}

func DeleteEventsByIdDossiers(tx DB, idDossiers_ ...dossiers.IdDossier) (Events, error) {
	rows, err := tx.Query("DELETE FROM events WHERE iddossier = ANY($1) RETURNING id, iddossier, kind, created", dossiers.IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanEvents(rows)
}

// SelectEventByIdAndKind return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEventByIdAndKind(tx DB, id IdEvent, kind EventKind) (item Event, found bool, err error) {
	row := tx.QueryRow("SELECT id, iddossier, kind, created FROM events WHERE Id = $1 AND Kind = $2", id, kind)
	item, err = ScanEvent(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func IdEventArrayToPQ(ids []IdEvent) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdEventArray scans the result of a query returning a
// list of ID's.
func ScanIdEventArray(rs *sql.Rows) ([]IdEvent, error) {
	defer rs.Close()
	ints := make([]IdEvent, 0, 16)
	var err error
	for rs.Next() {
		var s IdEvent
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func SwitchEventMessageDossier(db DB, to dossiers.IdDossier, from dossiers.IdDossier) error {
	_, err := db.Exec("UPDATE events SET IdDossier = $1 WHERE IdDossier = $2 AND Kind = 2 /* EventKind.Message */;", to, from)
	return err
}
