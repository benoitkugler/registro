package personnes

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...any) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...any) (sql.Result, error)
	Query(query string, args ...any) (*sql.Rows, error)
	QueryRow(query string, args ...any) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneFichesanitaire(row scanner) (Fichesanitaire, error) {
	var item Fichesanitaire
	err := row.Scan(
		&item.IdPersonne,
		&item.TraitementMedical,
		&item.Maladies,
		&item.Allergies,
		&item.DifficultesSante,
		&item.Recommandations,
		&item.Handicap,
		&item.Tel,
		&item.Medecin,
		&item.LastModif,
		&item.Mails,
	)
	return item, err
}

func ScanFichesanitaire(row *sql.Row) (Fichesanitaire, error) { return scanOneFichesanitaire(row) }

// SelectAll returns all the items in the fichesanitaires table.
func SelectAllFichesanitaires(db DB) (Fichesanitaires, error) {
	rows, err := db.Query("SELECT idpersonne, traitementmedical, maladies, allergies, difficultessante, recommandations, handicap, tel, medecin, lastmodif, mails FROM fichesanitaires")
	if err != nil {
		return nil, err
	}
	return ScanFichesanitaires(rows)
}

type Fichesanitaires []Fichesanitaire

func ScanFichesanitaires(rs *sql.Rows) (Fichesanitaires, error) {
	var (
		item Fichesanitaire
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Fichesanitaires, 0, 16)
	for rs.Next() {
		item, err = scanOneFichesanitaire(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item Fichesanitaire) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO fichesanitaires (
			idpersonne, traitementmedical, maladies, allergies, difficultessante, recommandations, handicap, tel, medecin, lastmodif, mails
			) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
			);
			`, item.IdPersonne, item.TraitementMedical, item.Maladies, item.Allergies, item.DifficultesSante, item.Recommandations, item.Handicap, item.Tel, item.Medecin, item.LastModif, item.Mails)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links Fichesanitaire in the database.
// It is a no-op if 'items' is empty.
func InsertManyFichesanitaires(tx *sql.Tx, items ...Fichesanitaire) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("fichesanitaires",
		"idpersonne",
		"traitementmedical",
		"maladies",
		"allergies",
		"difficultessante",
		"recommandations",
		"handicap",
		"tel",
		"medecin",
		"lastmodif",
		"mails",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdPersonne, item.TraitementMedical, item.Maladies, item.Allergies, item.DifficultesSante, item.Recommandations, item.Handicap, item.Tel, item.Medecin, item.LastModif, item.Mails)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Fichesanitaire from the database.
// Only the foreign keys IdPersonne fields are used in 'item'.
func (item Fichesanitaire) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM fichesanitaires WHERE IdPersonne = $1;`, item.IdPersonne)
	return err
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items Fichesanitaires) ByIdPersonne() map[IdPersonne]Fichesanitaire {
	out := make(map[IdPersonne]Fichesanitaire, len(items))
	for _, target := range items {
		out[target.IdPersonne] = target
	}
	return out
}

// IdPersonnes returns the list of ids of IdPersonne
// contained in this link table.
// They are not garanteed to be distinct.
func (items Fichesanitaires) IdPersonnes() []IdPersonne {
	out := make([]IdPersonne, len(items))
	for index, target := range items {
		out[index] = target.IdPersonne
	}
	return out
}

// SelectFichesanitaireByIdPersonne return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectFichesanitaireByIdPersonne(tx DB, idPersonne IdPersonne) (item Fichesanitaire, found bool, err error) {
	row := tx.QueryRow("SELECT idpersonne, traitementmedical, maladies, allergies, difficultessante, recommandations, handicap, tel, medecin, lastmodif, mails FROM fichesanitaires WHERE idpersonne = $1", idPersonne)
	item, err = ScanFichesanitaire(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectFichesanitairesByIdPersonnes(tx DB, idPersonnes_ ...IdPersonne) (Fichesanitaires, error) {
	rows, err := tx.Query("SELECT idpersonne, traitementmedical, maladies, allergies, difficultessante, recommandations, handicap, tel, medecin, lastmodif, mails FROM fichesanitaires WHERE idpersonne = ANY($1)", IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanFichesanitaires(rows)
}

func DeleteFichesanitairesByIdPersonnes(tx DB, idPersonnes_ ...IdPersonne) (Fichesanitaires, error) {
	rows, err := tx.Query("DELETE FROM fichesanitaires WHERE idpersonne = ANY($1) RETURNING idpersonne, traitementmedical, maladies, allergies, difficultessante, recommandations, handicap, tel, medecin, lastmodif, mails", IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanFichesanitaires(rows)
}

func scanOnePersonne(row scanner) (Personne, error) {
	var item Personne
	err := row.Scan(
		&item.Id,
		&item.Nom,
		&item.Prenom,
		&item.Sexe,
		&item.DateNaissance,
		&item.VilleNaissance,
		&item.DepartementNaissance,
		&item.Nationnalite,
		&item.Tels,
		&item.Mail,
		&item.Adresse,
		&item.CodePostal,
		&item.Ville,
		&item.Pays,
		&item.SecuriteSociale,
		&item.NomJeuneFille,
		&item.Profession,
		&item.Etudiant,
		&item.Fonctionnaire,
		&item.Diplome,
		&item.Approfondissement,
		&item.Publicite,
		&item.IsTemp,
	)
	return item, err
}

func ScanPersonne(row *sql.Row) (Personne, error) { return scanOnePersonne(row) }

// SelectAll returns all the items in the personnes table.
func SelectAllPersonnes(db DB) (Personnes, error) {
	rows, err := db.Query("SELECT id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, securitesociale, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, istemp FROM personnes")
	if err != nil {
		return nil, err
	}
	return ScanPersonnes(rows)
}

// SelectPersonne returns the entry matching 'id'.
func SelectPersonne(tx DB, id IdPersonne) (Personne, error) {
	row := tx.QueryRow("SELECT id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, securitesociale, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, istemp FROM personnes WHERE id = $1", id)
	return ScanPersonne(row)
}

// SelectPersonnes returns the entry matching the given 'ids'.
func SelectPersonnes(tx DB, ids ...IdPersonne) (Personnes, error) {
	rows, err := tx.Query("SELECT id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, securitesociale, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, istemp FROM personnes WHERE id = ANY($1)", IdPersonneArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanPersonnes(rows)
}

type Personnes map[IdPersonne]Personne

func (m Personnes) IDs() []IdPersonne {
	out := make([]IdPersonne, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanPersonnes(rs *sql.Rows) (Personnes, error) {
	var (
		s   Personne
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Personnes, 16)
	for rs.Next() {
		s, err = scanOnePersonne(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Personne in the database and returns the item with id filled.
func (item Personne) Insert(tx DB) (out Personne, err error) {
	row := tx.QueryRow(`INSERT INTO personnes (
		nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, securitesociale, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, istemp
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22
		) RETURNING id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, securitesociale, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, istemp;
		`, item.Nom, item.Prenom, item.Sexe, item.DateNaissance, item.VilleNaissance, item.DepartementNaissance, item.Nationnalite, item.Tels, item.Mail, item.Adresse, item.CodePostal, item.Ville, item.Pays, item.SecuriteSociale, item.NomJeuneFille, item.Profession, item.Etudiant, item.Fonctionnaire, item.Diplome, item.Approfondissement, item.Publicite, item.IsTemp)
	return ScanPersonne(row)
}

// Update Personne in the database and returns the new version.
func (item Personne) Update(tx DB) (out Personne, err error) {
	row := tx.QueryRow(`UPDATE personnes SET (
		nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, securitesociale, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, istemp
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22
		) WHERE id = $23 RETURNING id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, securitesociale, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, istemp;
		`, item.Nom, item.Prenom, item.Sexe, item.DateNaissance, item.VilleNaissance, item.DepartementNaissance, item.Nationnalite, item.Tels, item.Mail, item.Adresse, item.CodePostal, item.Ville, item.Pays, item.SecuriteSociale, item.NomJeuneFille, item.Profession, item.Etudiant, item.Fonctionnaire, item.Diplome, item.Approfondissement, item.Publicite, item.IsTemp, item.Id)
	return ScanPersonne(row)
}

// Deletes the Personne and returns the item
func DeletePersonneById(tx DB, id IdPersonne) (Personne, error) {
	row := tx.QueryRow("DELETE FROM personnes WHERE id = $1 RETURNING id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, securitesociale, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, istemp;", id)
	return ScanPersonne(row)
}

// Deletes the Personne in the database and returns the ids.
func DeletePersonnesByIDs(tx DB, ids ...IdPersonne) ([]IdPersonne, error) {
	rows, err := tx.Query("DELETE FROM personnes WHERE id = ANY($1) RETURNING id", IdPersonneArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdPersonneArray(rows)
}

// SelectPersonneByIdAndIsTemp return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectPersonneByIdAndIsTemp(tx DB, id IdPersonne, isTemp bool) (item Personne, found bool, err error) {
	row := tx.QueryRow("SELECT id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, securitesociale, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, istemp FROM personnes WHERE Id = $1 AND IsTemp = $2", id, isTemp)
	item, err = ScanPersonne(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out any, src any) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s any) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *Mails) Scan(src any) error {
	return (*pq.StringArray)(s).Scan(src)
}
func (s Mails) Value() (driver.Value, error) {
	return pq.StringArray(s).Value()
}

func (s *Tels) Scan(src any) error {
	return (*pq.StringArray)(s).Scan(src)
}
func (s Tels) Value() (driver.Value, error) {
	return pq.StringArray(s).Value()
}

func IdPersonneArrayToPQ(ids []IdPersonne) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdPersonneArray scans the result of a query returning a
// list of ID's.
func ScanIdPersonneArray(rs *sql.Rows) ([]IdPersonne, error) {
	defer rs.Close()
	ints := make([]IdPersonne, 0, 16)
	var err error
	for rs.Next() {
		var s IdPersonne
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func (s *Allergies) Scan(src any) error          { return loadJSON(s, src) }
func (s Allergies) Value() (driver.Value, error) { return dumpJSON(s) }

func (s *Maladies) Scan(src any) error          { return loadJSON(s, src) }
func (s Maladies) Value() (driver.Value, error) { return dumpJSON(s) }

func (s *Medecin) Scan(src any) error          { return loadJSON(s, src) }
func (s Medecin) Value() (driver.Value, error) { return dumpJSON(s) }

func (s *Publicite) Scan(src any) error          { return loadJSON(s, src) }
func (s Publicite) Value() (driver.Value, error) { return dumpJSON(s) }
