package personnes

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...any) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...any) (sql.Result, error)
	Query(query string, args ...any) (*sql.Rows, error)
	QueryRow(query string, args ...any) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneFichesanitaire(row scanner) (Fichesanitaire, error) {
	var item Fichesanitaire
	err := row.Scan(
		&item.IdPersonne,
		&item.DifficultesSante,
		&item.AllergiesAlimentaires,
		&item.TraitementMedical,
		&item.Medecin,
		&item.AutreContact,
		&item.Modified,
		&item.Owners,
	)
	return item, err
}

func ScanFichesanitaire(row *sql.Row) (Fichesanitaire, error) { return scanOneFichesanitaire(row) }

// SelectAll returns all the items in the fichesanitaires table.
func SelectAllFichesanitaires(db DB) (Fichesanitaires, error) {
	rows, err := db.Query("SELECT idpersonne, difficultessante, allergiesalimentaires, traitementmedical, medecin, autrecontact, modified, owners FROM fichesanitaires")
	if err != nil {
		return nil, err
	}
	return ScanFichesanitaires(rows)
}

type Fichesanitaires []Fichesanitaire

func ScanFichesanitaires(rs *sql.Rows) (Fichesanitaires, error) {
	var (
		item Fichesanitaire
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Fichesanitaires, 0, 16)
	for rs.Next() {
		item, err = scanOneFichesanitaire(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item Fichesanitaire) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO fichesanitaires (
			idpersonne, difficultessante, allergiesalimentaires, traitementmedical, medecin, autrecontact, modified, owners
			) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8
			);
			`, item.IdPersonne, item.DifficultesSante, item.AllergiesAlimentaires, item.TraitementMedical, item.Medecin, item.AutreContact, item.Modified, item.Owners)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links Fichesanitaire in the database.
// It is a no-op if 'items' is empty.
func InsertManyFichesanitaires(tx *sql.Tx, items ...Fichesanitaire) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("fichesanitaires",
		"idpersonne",
		"difficultessante",
		"allergiesalimentaires",
		"traitementmedical",
		"medecin",
		"autrecontact",
		"modified",
		"owners",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdPersonne, item.DifficultesSante, item.AllergiesAlimentaires, item.TraitementMedical, item.Medecin, item.AutreContact, item.Modified, item.Owners)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Fichesanitaire from the database.
// Only the foreign keys IdPersonne fields are used in 'item'.
func (item Fichesanitaire) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM fichesanitaires WHERE IdPersonne = $1;`, item.IdPersonne)
	return err
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items Fichesanitaires) ByIdPersonne() map[IdPersonne]Fichesanitaire {
	out := make(map[IdPersonne]Fichesanitaire, len(items))
	for _, target := range items {
		out[target.IdPersonne] = target
	}
	return out
}

// IdPersonnes returns the list of ids of IdPersonne
// contained in this table.
// They are not garanteed to be distinct.
func (items Fichesanitaires) IdPersonnes() []IdPersonne {
	out := make([]IdPersonne, len(items))
	for index, target := range items {
		out[index] = target.IdPersonne
	}
	return out
}

// SelectFichesanitaireByIdPersonne return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectFichesanitaireByIdPersonne(tx DB, idPersonne IdPersonne) (item Fichesanitaire, found bool, err error) {
	row := tx.QueryRow("SELECT idpersonne, difficultessante, allergiesalimentaires, traitementmedical, medecin, autrecontact, modified, owners FROM fichesanitaires WHERE idpersonne = $1", idPersonne)
	item, err = ScanFichesanitaire(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectFichesanitairesByIdPersonnes(tx DB, idPersonnes_ ...IdPersonne) (Fichesanitaires, error) {
	rows, err := tx.Query("SELECT idpersonne, difficultessante, allergiesalimentaires, traitementmedical, medecin, autrecontact, modified, owners FROM fichesanitaires WHERE idpersonne = ANY($1)", IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanFichesanitaires(rows)
}

func DeleteFichesanitairesByIdPersonnes(tx DB, idPersonnes_ ...IdPersonne) (Fichesanitaires, error) {
	rows, err := tx.Query("DELETE FROM fichesanitaires WHERE idpersonne = ANY($1) RETURNING idpersonne, difficultessante, allergiesalimentaires, traitementmedical, medecin, autrecontact, modified, owners", IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanFichesanitaires(rows)
}

func scanOnePersonne(row scanner) (Personne, error) {
	var item Personne
	err := row.Scan(
		&item.Id,
		&item.Nom,
		&item.Prenom,
		&item.Sexe,
		&item.DateNaissance,
		&item.VilleNaissance,
		&item.DepartementNaissance,
		&item.Nationnalite,
		&item.Tels,
		&item.Mail,
		&item.Adresse,
		&item.CodePostal,
		&item.Ville,
		&item.Pays,
		&item.NomJeuneFille,
		&item.Profession,
		&item.Etudiant,
		&item.Fonctionnaire,
		&item.Diplome,
		&item.Approfondissement,
		&item.Publicite,
		&item.CharteAccepted,
		&item.IsTemp,
	)
	return item, err
}

func ScanPersonne(row *sql.Row) (Personne, error) { return scanOnePersonne(row) }

// SelectAll returns all the items in the personnes table.
func SelectAllPersonnes(db DB) (Personnes, error) {
	rows, err := db.Query("SELECT id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, charteaccepted, istemp FROM personnes")
	if err != nil {
		return nil, err
	}
	return ScanPersonnes(rows)
}

// SelectPersonne returns the entry matching 'id'.
func SelectPersonne(tx DB, id IdPersonne) (Personne, error) {
	row := tx.QueryRow("SELECT id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, charteaccepted, istemp FROM personnes WHERE id = $1", id)
	return ScanPersonne(row)
}

// SelectPersonnes returns the entry matching the given 'ids'.
func SelectPersonnes(tx DB, ids ...IdPersonne) (Personnes, error) {
	rows, err := tx.Query("SELECT id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, charteaccepted, istemp FROM personnes WHERE id = ANY($1)", IdPersonneArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanPersonnes(rows)
}

type Personnes map[IdPersonne]Personne

func (m Personnes) IDs() []IdPersonne {
	out := make([]IdPersonne, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanPersonnes(rs *sql.Rows) (Personnes, error) {
	var (
		s   Personne
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Personnes, 16)
	for rs.Next() {
		s, err = scanOnePersonne(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Personne in the database and returns the item with id filled.
func (item Personne) Insert(tx DB) (out Personne, err error) {
	row := tx.QueryRow(`INSERT INTO personnes (
		nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, charteaccepted, istemp
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22
		) RETURNING id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, charteaccepted, istemp;
		`, item.Nom, item.Prenom, item.Sexe, item.DateNaissance, item.VilleNaissance, item.DepartementNaissance, item.Nationnalite, item.Tels, item.Mail, item.Adresse, item.CodePostal, item.Ville, item.Pays, item.NomJeuneFille, item.Profession, item.Etudiant, item.Fonctionnaire, item.Diplome, item.Approfondissement, item.Publicite, item.CharteAccepted, item.IsTemp)
	return ScanPersonne(row)
}

// Update Personne in the database and returns the new version.
func (item Personne) Update(tx DB) (out Personne, err error) {
	row := tx.QueryRow(`UPDATE personnes SET (
		nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, charteaccepted, istemp
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22
		) WHERE id = $23 RETURNING id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, charteaccepted, istemp;
		`, item.Nom, item.Prenom, item.Sexe, item.DateNaissance, item.VilleNaissance, item.DepartementNaissance, item.Nationnalite, item.Tels, item.Mail, item.Adresse, item.CodePostal, item.Ville, item.Pays, item.NomJeuneFille, item.Profession, item.Etudiant, item.Fonctionnaire, item.Diplome, item.Approfondissement, item.Publicite, item.CharteAccepted, item.IsTemp, item.Id)
	return ScanPersonne(row)
}

// Deletes the Personne and returns the item
func DeletePersonneById(tx DB, id IdPersonne) (Personne, error) {
	row := tx.QueryRow("DELETE FROM personnes WHERE id = $1 RETURNING id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, charteaccepted, istemp;", id)
	return ScanPersonne(row)
}

// Deletes the Personne in the database and returns the ids.
func DeletePersonnesByIDs(tx DB, ids ...IdPersonne) ([]IdPersonne, error) {
	rows, err := tx.Query("DELETE FROM personnes WHERE id = ANY($1) RETURNING id", IdPersonneArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdPersonneArray(rows)
}

// SelectPersonneByIdAndIsTemp return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectPersonneByIdAndIsTemp(tx DB, id IdPersonne, isTemp bool) (item Personne, found bool, err error) {
	row := tx.QueryRow("SELECT id, nom, prenom, sexe, datenaissance, villenaissance, departementnaissance, nationnalite, tels, mail, adresse, codepostal, ville, pays, nomjeunefille, profession, etudiant, fonctionnaire, diplome, approfondissement, publicite, charteaccepted, istemp FROM personnes WHERE Id = $1 AND IsTemp = $2", id, isTemp)
	item, err = ScanPersonne(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out any, src any) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s any) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *Mails) Scan(src any) error {
	return (*pq.StringArray)(s).Scan(src)
}
func (s Mails) Value() (driver.Value, error) {
	return pq.StringArray(s).Value()
}

func (s *Tels) Scan(src any) error {
	return (*pq.StringArray)(s).Scan(src)
}
func (s Tels) Value() (driver.Value, error) {
	return pq.StringArray(s).Value()
}

func (s *Nationnalite) Scan(src any) error {
	bs, ok := src.([]byte)
	if !ok {
		return fmt.Errorf("unsupported type %T", src)
	}
	fields := strings.Split(string(bs[1:len(bs)-1]), ",")
	if len(fields) != 1 {
		return fmt.Errorf("unsupported number of fields %d", len(fields))
	}

	s.IsSuisse = bool(fields[0] == "t")

	return nil
}
func (s Nationnalite) Value() (driver.Value, error) {
	bs := fmt.Sprintf("(%t)", s.IsSuisse)
	return driver.Value(bs), nil
}

func (s *Publicite) Scan(src any) error {
	bs, ok := src.([]byte)
	if !ok {
		return fmt.Errorf("unsupported type %T", src)
	}
	fields := strings.Split(string(bs[1:len(bs)-1]), ",")
	if len(fields) != 5 {
		return fmt.Errorf("unsupported number of fields %d", len(fields))
	}

	s.VersionPapier = bool(fields[0] == "t")

	s.PubHiver = bool(fields[1] == "t")

	s.PubEte = bool(fields[2] == "t")

	s.EchoRocher = bool(fields[3] == "t")

	s.Eonews = bool(fields[4] == "t")

	return nil
}
func (s Publicite) Value() (driver.Value, error) {
	bs := fmt.Sprintf("(%t, %t, %t, %t, %t)", s.VersionPapier, s.PubHiver, s.PubEte, s.EchoRocher, s.Eonews)
	return driver.Value(bs), nil
}

func IdPersonneArrayToPQ(ids []IdPersonne) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdPersonneArray scans the result of a query returning a
// list of ID's.
func ScanIdPersonneArray(rs *sql.Rows) ([]IdPersonne, error) {
	defer rs.Close()
	ints := make([]IdPersonne, 0, 16)
	var err error
	for rs.Next() {
		var s IdPersonne
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func (s *NomTel) Scan(src any) error          { return loadJSON(s, src) }
func (s NomTel) Value() (driver.Value, error) { return dumpJSON(s) }
