package camps

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"registro/sql/dossiers"
	"registro/sql/personnes"
	"strconv"
	"strings"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...any) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...any) (sql.Result, error)
	Query(query string, args ...any) (*sql.Rows, error)
	QueryRow(query string, args ...any) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneAide(row scanner) (Aide, error) {
	var item Aide
	err := row.Scan(
		&item.Id,
		&item.IdStructureaide,
		&item.IdParticipant,
		&item.Valide,
		&item.Valeur,
		&item.ParJour,
		&item.NbJoursMax,
	)
	return item, err
}

func ScanAide(row *sql.Row) (Aide, error) { return scanOneAide(row) }

// SelectAll returns all the items in the aides table.
func SelectAllAides(db DB) (Aides, error) {
	rows, err := db.Query("SELECT id, idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax FROM aides")
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

// SelectAide returns the entry matching 'id'.
func SelectAide(tx DB, id IdAide) (Aide, error) {
	row := tx.QueryRow("SELECT id, idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax FROM aides WHERE id = $1", id)
	return ScanAide(row)
}

// SelectAides returns the entry matching the given 'ids'.
func SelectAides(tx DB, ids ...IdAide) (Aides, error) {
	rows, err := tx.Query("SELECT id, idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax FROM aides WHERE id = ANY($1)", IdAideArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

type Aides map[IdAide]Aide

func (m Aides) IDs() []IdAide {
	out := make([]IdAide, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanAides(rs *sql.Rows) (Aides, error) {
	var (
		s   Aide
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Aides, 16)
	for rs.Next() {
		s, err = scanOneAide(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Aide in the database and returns the item with id filled.
func (item Aide) Insert(tx DB) (out Aide, err error) {
	row := tx.QueryRow(`INSERT INTO aides (
		idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax
		) VALUES (
		$1, $2, $3, $4, $5, $6
		) RETURNING id, idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax;
		`, item.IdStructureaide, item.IdParticipant, item.Valide, item.Valeur, item.ParJour, item.NbJoursMax)
	return ScanAide(row)
}

// Update Aide in the database and returns the new version.
func (item Aide) Update(tx DB) (out Aide, err error) {
	row := tx.QueryRow(`UPDATE aides SET (
		idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax
		) = (
		$1, $2, $3, $4, $5, $6
		) WHERE id = $7 RETURNING id, idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax;
		`, item.IdStructureaide, item.IdParticipant, item.Valide, item.Valeur, item.ParJour, item.NbJoursMax, item.Id)
	return ScanAide(row)
}

// Deletes the Aide and returns the item
func DeleteAideById(tx DB, id IdAide) (Aide, error) {
	row := tx.QueryRow("DELETE FROM aides WHERE id = $1 RETURNING id, idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax;", id)
	return ScanAide(row)
}

// Deletes the Aide in the database and returns the ids.
func DeleteAidesByIDs(tx DB, ids ...IdAide) ([]IdAide, error) {
	rows, err := tx.Query("DELETE FROM aides WHERE id = ANY($1) RETURNING id", IdAideArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdAideArray(rows)
}

// ByIdStructureaide returns a map with 'IdStructureaide' as keys.
func (items Aides) ByIdStructureaide() map[IdStructureaide]Aides {
	out := make(map[IdStructureaide]Aides)
	for _, target := range items {
		dict := out[target.IdStructureaide]
		if dict == nil {
			dict = make(Aides)
		}
		dict[target.Id] = target
		out[target.IdStructureaide] = dict
	}
	return out
}

// IdStructureaides returns the list of ids of IdStructureaide
// contained in this table.
// They are not garanteed to be distinct.
func (items Aides) IdStructureaides() []IdStructureaide {
	out := make([]IdStructureaide, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdStructureaide)
	}
	return out
}

func SelectAidesByIdStructureaides(tx DB, idStructureaides_ ...IdStructureaide) (Aides, error) {
	rows, err := tx.Query("SELECT id, idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax FROM aides WHERE idstructureaide = ANY($1)", IdStructureaideArrayToPQ(idStructureaides_))
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

func DeleteAidesByIdStructureaides(tx DB, idStructureaides_ ...IdStructureaide) ([]IdAide, error) {
	rows, err := tx.Query("DELETE FROM aides WHERE idstructureaide = ANY($1) RETURNING id", IdStructureaideArrayToPQ(idStructureaides_))
	if err != nil {
		return nil, err
	}
	return ScanIdAideArray(rows)
}

// ByIdParticipant returns a map with 'IdParticipant' as keys.
func (items Aides) ByIdParticipant() map[IdParticipant]Aides {
	out := make(map[IdParticipant]Aides)
	for _, target := range items {
		dict := out[target.IdParticipant]
		if dict == nil {
			dict = make(Aides)
		}
		dict[target.Id] = target
		out[target.IdParticipant] = dict
	}
	return out
}

// IdParticipants returns the list of ids of IdParticipant
// contained in this table.
// They are not garanteed to be distinct.
func (items Aides) IdParticipants() []IdParticipant {
	out := make([]IdParticipant, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdParticipant)
	}
	return out
}

func SelectAidesByIdParticipants(tx DB, idParticipants_ ...IdParticipant) (Aides, error) {
	rows, err := tx.Query("SELECT id, idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax FROM aides WHERE idparticipant = ANY($1)", IdParticipantArrayToPQ(idParticipants_))
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

func DeleteAidesByIdParticipants(tx DB, idParticipants_ ...IdParticipant) ([]IdAide, error) {
	rows, err := tx.Query("DELETE FROM aides WHERE idparticipant = ANY($1) RETURNING id", IdParticipantArrayToPQ(idParticipants_))
	if err != nil {
		return nil, err
	}
	return ScanIdAideArray(rows)
}

func scanOneCamp(row scanner) (Camp, error) {
	var item Camp
	err := row.Scan(
		&item.Id,
		&item.IdTaux,
		&item.Nom,
		&item.DateDebut,
		&item.Duree,
		&item.Lieu,
		&item.Agrement,
		&item.ImageURL,
		&item.Description,
		&item.Navette,
		&item.Places,
		&item.AgeMin,
		&item.AgeMax,
		&item.NeedEquilibreGF,
		&item.Ouvert,
		&item.Prix,
		&item.OptionPrix,
		&item.OptionQuotientFamilial,
		&item.Password,
	)
	return item, err
}

func ScanCamp(row *sql.Row) (Camp, error) { return scanOneCamp(row) }

// SelectAll returns all the items in the camps table.
func SelectAllCamps(db DB) (Camps, error) {
	rows, err := db.Query("SELECT id, idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password FROM camps")
	if err != nil {
		return nil, err
	}
	return ScanCamps(rows)
}

// SelectCamp returns the entry matching 'id'.
func SelectCamp(tx DB, id IdCamp) (Camp, error) {
	row := tx.QueryRow("SELECT id, idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password FROM camps WHERE id = $1", id)
	return ScanCamp(row)
}

// SelectCamps returns the entry matching the given 'ids'.
func SelectCamps(tx DB, ids ...IdCamp) (Camps, error) {
	rows, err := tx.Query("SELECT id, idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password FROM camps WHERE id = ANY($1)", IdCampArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanCamps(rows)
}

type Camps map[IdCamp]Camp

func (m Camps) IDs() []IdCamp {
	out := make([]IdCamp, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanCamps(rs *sql.Rows) (Camps, error) {
	var (
		s   Camp
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Camps, 16)
	for rs.Next() {
		s, err = scanOneCamp(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Camp in the database and returns the item with id filled.
func (item Camp) Insert(tx DB) (out Camp, err error) {
	row := tx.QueryRow(`INSERT INTO camps (
		idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
		) RETURNING id, idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password;
		`, item.IdTaux, item.Nom, item.DateDebut, item.Duree, item.Lieu, item.Agrement, item.ImageURL, item.Description, item.Navette, item.Places, item.AgeMin, item.AgeMax, item.NeedEquilibreGF, item.Ouvert, item.Prix, item.OptionPrix, item.OptionQuotientFamilial, item.Password)
	return ScanCamp(row)
}

// Update Camp in the database and returns the new version.
func (item Camp) Update(tx DB) (out Camp, err error) {
	row := tx.QueryRow(`UPDATE camps SET (
		idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
		) WHERE id = $19 RETURNING id, idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password;
		`, item.IdTaux, item.Nom, item.DateDebut, item.Duree, item.Lieu, item.Agrement, item.ImageURL, item.Description, item.Navette, item.Places, item.AgeMin, item.AgeMax, item.NeedEquilibreGF, item.Ouvert, item.Prix, item.OptionPrix, item.OptionQuotientFamilial, item.Password, item.Id)
	return ScanCamp(row)
}

// Deletes the Camp and returns the item
func DeleteCampById(tx DB, id IdCamp) (Camp, error) {
	row := tx.QueryRow("DELETE FROM camps WHERE id = $1 RETURNING id, idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password;", id)
	return ScanCamp(row)
}

// Deletes the Camp in the database and returns the ids.
func DeleteCampsByIDs(tx DB, ids ...IdCamp) ([]IdCamp, error) {
	rows, err := tx.Query("DELETE FROM camps WHERE id = ANY($1) RETURNING id", IdCampArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdCampArray(rows)
}

// ByIdTaux returns a map with 'IdTaux' as keys.
func (items Camps) ByIdTaux() map[dossiers.IdTaux]Camps {
	out := make(map[dossiers.IdTaux]Camps)
	for _, target := range items {
		dict := out[target.IdTaux]
		if dict == nil {
			dict = make(Camps)
		}
		dict[target.Id] = target
		out[target.IdTaux] = dict
	}
	return out
}

// IdTauxs returns the list of ids of IdTaux
// contained in this table.
// They are not garanteed to be distinct.
func (items Camps) IdTauxs() []dossiers.IdTaux {
	out := make([]dossiers.IdTaux, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTaux)
	}
	return out
}

func SelectCampsByIdTauxs(tx DB, idTauxs_ ...dossiers.IdTaux) (Camps, error) {
	rows, err := tx.Query("SELECT id, idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password FROM camps WHERE idtaux = ANY($1)", dossiers.IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanCamps(rows)
}

func DeleteCampsByIdTauxs(tx DB, idTauxs_ ...dossiers.IdTaux) ([]IdCamp, error) {
	rows, err := tx.Query("DELETE FROM camps WHERE idtaux = ANY($1) RETURNING id", dossiers.IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanIdCampArray(rows)
}

// SelectCampByIdAndIdTaux return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectCampByIdAndIdTaux(tx DB, id IdCamp, idTaux dossiers.IdTaux) (item Camp, found bool, err error) {
	row := tx.QueryRow("SELECT id, idtaux, nom, datedebut, duree, lieu, agrement, imageurl, description, navette, places, agemin, agemax, needequilibregf, ouvert, prix, optionprix, optionquotientfamilial, password FROM camps WHERE Id = $1 AND IdTaux = $2", id, idTaux)
	item, err = ScanCamp(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneEquipier(row scanner) (Equipier, error) {
	var item Equipier
	err := row.Scan(
		&item.Id,
		&item.IdCamp,
		&item.IdPersonne,
		&item.Roles,
		&item.Presence,
		&item.FormStatus,
		&item.AccepteCharte,
	)
	return item, err
}

func ScanEquipier(row *sql.Row) (Equipier, error) { return scanOneEquipier(row) }

// SelectAll returns all the items in the equipiers table.
func SelectAllEquipiers(db DB) (Equipiers, error) {
	rows, err := db.Query("SELECT id, idcamp, idpersonne, roles, presence, formstatus, acceptecharte FROM equipiers")
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

// SelectEquipier returns the entry matching 'id'.
func SelectEquipier(tx DB, id IdEquipier) (Equipier, error) {
	row := tx.QueryRow("SELECT id, idcamp, idpersonne, roles, presence, formstatus, acceptecharte FROM equipiers WHERE id = $1", id)
	return ScanEquipier(row)
}

// SelectEquipiers returns the entry matching the given 'ids'.
func SelectEquipiers(tx DB, ids ...IdEquipier) (Equipiers, error) {
	rows, err := tx.Query("SELECT id, idcamp, idpersonne, roles, presence, formstatus, acceptecharte FROM equipiers WHERE id = ANY($1)", IdEquipierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

type Equipiers map[IdEquipier]Equipier

func (m Equipiers) IDs() []IdEquipier {
	out := make([]IdEquipier, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanEquipiers(rs *sql.Rows) (Equipiers, error) {
	var (
		s   Equipier
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Equipiers, 16)
	for rs.Next() {
		s, err = scanOneEquipier(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Equipier in the database and returns the item with id filled.
func (item Equipier) Insert(tx DB) (out Equipier, err error) {
	row := tx.QueryRow(`INSERT INTO equipiers (
		idcamp, idpersonne, roles, presence, formstatus, acceptecharte
		) VALUES (
		$1, $2, $3, $4, $5, $6
		) RETURNING id, idcamp, idpersonne, roles, presence, formstatus, acceptecharte;
		`, item.IdCamp, item.IdPersonne, item.Roles, item.Presence, item.FormStatus, item.AccepteCharte)
	return ScanEquipier(row)
}

// Update Equipier in the database and returns the new version.
func (item Equipier) Update(tx DB) (out Equipier, err error) {
	row := tx.QueryRow(`UPDATE equipiers SET (
		idcamp, idpersonne, roles, presence, formstatus, acceptecharte
		) = (
		$1, $2, $3, $4, $5, $6
		) WHERE id = $7 RETURNING id, idcamp, idpersonne, roles, presence, formstatus, acceptecharte;
		`, item.IdCamp, item.IdPersonne, item.Roles, item.Presence, item.FormStatus, item.AccepteCharte, item.Id)
	return ScanEquipier(row)
}

// Deletes the Equipier and returns the item
func DeleteEquipierById(tx DB, id IdEquipier) (Equipier, error) {
	row := tx.QueryRow("DELETE FROM equipiers WHERE id = $1 RETURNING id, idcamp, idpersonne, roles, presence, formstatus, acceptecharte;", id)
	return ScanEquipier(row)
}

// Deletes the Equipier in the database and returns the ids.
func DeleteEquipiersByIDs(tx DB, ids ...IdEquipier) ([]IdEquipier, error) {
	rows, err := tx.Query("DELETE FROM equipiers WHERE id = ANY($1) RETURNING id", IdEquipierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdEquipierArray(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Equipiers) ByIdCamp() map[IdCamp]Equipiers {
	out := make(map[IdCamp]Equipiers)
	for _, target := range items {
		dict := out[target.IdCamp]
		if dict == nil {
			dict = make(Equipiers)
		}
		dict[target.Id] = target
		out[target.IdCamp] = dict
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this table.
// They are not garanteed to be distinct.
func (items Equipiers) IdCamps() []IdCamp {
	out := make([]IdCamp, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdCamp)
	}
	return out
}

func SelectEquipiersByIdCamps(tx DB, idCamps_ ...IdCamp) (Equipiers, error) {
	rows, err := tx.Query("SELECT id, idcamp, idpersonne, roles, presence, formstatus, acceptecharte FROM equipiers WHERE idcamp = ANY($1)", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

func DeleteEquipiersByIdCamps(tx DB, idCamps_ ...IdCamp) ([]IdEquipier, error) {
	rows, err := tx.Query("DELETE FROM equipiers WHERE idcamp = ANY($1) RETURNING id", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanIdEquipierArray(rows)
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items Equipiers) ByIdPersonne() map[personnes.IdPersonne]Equipiers {
	out := make(map[personnes.IdPersonne]Equipiers)
	for _, target := range items {
		dict := out[target.IdPersonne]
		if dict == nil {
			dict = make(Equipiers)
		}
		dict[target.Id] = target
		out[target.IdPersonne] = dict
	}
	return out
}

// IdPersonnes returns the list of ids of IdPersonne
// contained in this table.
// They are not garanteed to be distinct.
func (items Equipiers) IdPersonnes() []personnes.IdPersonne {
	out := make([]personnes.IdPersonne, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdPersonne)
	}
	return out
}

func SelectEquipiersByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) (Equipiers, error) {
	rows, err := tx.Query("SELECT id, idcamp, idpersonne, roles, presence, formstatus, acceptecharte FROM equipiers WHERE idpersonne = ANY($1)", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

func DeleteEquipiersByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) ([]IdEquipier, error) {
	rows, err := tx.Query("DELETE FROM equipiers WHERE idpersonne = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanIdEquipierArray(rows)
}

// SelectEquipierByIdCampAndIdPersonne return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEquipierByIdCampAndIdPersonne(tx DB, idCamp IdCamp, idPersonne personnes.IdPersonne) (item Equipier, found bool, err error) {
	row := tx.QueryRow("SELECT id, idcamp, idpersonne, roles, presence, formstatus, acceptecharte FROM equipiers WHERE IdCamp = $1 AND IdPersonne = $2", idCamp, idPersonne)
	item, err = ScanEquipier(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneGroupe(row scanner) (Groupe, error) {
	var item Groupe
	err := row.Scan(
		&item.Id,
		&item.IdCamp,
		&item.Nom,
		&item.Plage,
		&item.Couleur,
	)
	return item, err
}

func ScanGroupe(row *sql.Row) (Groupe, error) { return scanOneGroupe(row) }

// SelectAll returns all the items in the groupes table.
func SelectAllGroupes(db DB) (Groupes, error) {
	rows, err := db.Query("SELECT id, idcamp, nom, plage, couleur FROM groupes")
	if err != nil {
		return nil, err
	}
	return ScanGroupes(rows)
}

// SelectGroupe returns the entry matching 'id'.
func SelectGroupe(tx DB, id IdGroupe) (Groupe, error) {
	row := tx.QueryRow("SELECT id, idcamp, nom, plage, couleur FROM groupes WHERE id = $1", id)
	return ScanGroupe(row)
}

// SelectGroupes returns the entry matching the given 'ids'.
func SelectGroupes(tx DB, ids ...IdGroupe) (Groupes, error) {
	rows, err := tx.Query("SELECT id, idcamp, nom, plage, couleur FROM groupes WHERE id = ANY($1)", IdGroupeArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanGroupes(rows)
}

type Groupes map[IdGroupe]Groupe

func (m Groupes) IDs() []IdGroupe {
	out := make([]IdGroupe, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanGroupes(rs *sql.Rows) (Groupes, error) {
	var (
		s   Groupe
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Groupes, 16)
	for rs.Next() {
		s, err = scanOneGroupe(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Groupe in the database and returns the item with id filled.
func (item Groupe) Insert(tx DB) (out Groupe, err error) {
	row := tx.QueryRow(`INSERT INTO groupes (
		idcamp, nom, plage, couleur
		) VALUES (
		$1, $2, $3, $4
		) RETURNING id, idcamp, nom, plage, couleur;
		`, item.IdCamp, item.Nom, item.Plage, item.Couleur)
	return ScanGroupe(row)
}

// Update Groupe in the database and returns the new version.
func (item Groupe) Update(tx DB) (out Groupe, err error) {
	row := tx.QueryRow(`UPDATE groupes SET (
		idcamp, nom, plage, couleur
		) = (
		$1, $2, $3, $4
		) WHERE id = $5 RETURNING id, idcamp, nom, plage, couleur;
		`, item.IdCamp, item.Nom, item.Plage, item.Couleur, item.Id)
	return ScanGroupe(row)
}

// Deletes the Groupe and returns the item
func DeleteGroupeById(tx DB, id IdGroupe) (Groupe, error) {
	row := tx.QueryRow("DELETE FROM groupes WHERE id = $1 RETURNING id, idcamp, nom, plage, couleur;", id)
	return ScanGroupe(row)
}

// Deletes the Groupe in the database and returns the ids.
func DeleteGroupesByIDs(tx DB, ids ...IdGroupe) ([]IdGroupe, error) {
	rows, err := tx.Query("DELETE FROM groupes WHERE id = ANY($1) RETURNING id", IdGroupeArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdGroupeArray(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Groupes) ByIdCamp() map[IdCamp]Groupes {
	out := make(map[IdCamp]Groupes)
	for _, target := range items {
		dict := out[target.IdCamp]
		if dict == nil {
			dict = make(Groupes)
		}
		dict[target.Id] = target
		out[target.IdCamp] = dict
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this table.
// They are not garanteed to be distinct.
func (items Groupes) IdCamps() []IdCamp {
	out := make([]IdCamp, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdCamp)
	}
	return out
}

func SelectGroupesByIdCamps(tx DB, idCamps_ ...IdCamp) (Groupes, error) {
	rows, err := tx.Query("SELECT id, idcamp, nom, plage, couleur FROM groupes WHERE idcamp = ANY($1)", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanGroupes(rows)
}

func DeleteGroupesByIdCamps(tx DB, idCamps_ ...IdCamp) ([]IdGroupe, error) {
	rows, err := tx.Query("DELETE FROM groupes WHERE idcamp = ANY($1) RETURNING id", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanIdGroupeArray(rows)
}

func scanOneGroupeParticipant(row scanner) (GroupeParticipant, error) {
	var item GroupeParticipant
	err := row.Scan(
		&item.IdParticipant,
		&item.IdGroupe,
		&item.IdCamp,
		&item.Manuel,
	)
	return item, err
}

func ScanGroupeParticipant(row *sql.Row) (GroupeParticipant, error) {
	return scanOneGroupeParticipant(row)
}

// SelectAll returns all the items in the groupe_participants table.
func SelectAllGroupeParticipants(db DB) (GroupeParticipants, error) {
	rows, err := db.Query("SELECT idparticipant, idgroupe, idcamp, manuel FROM groupe_participants")
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

type GroupeParticipants []GroupeParticipant

func ScanGroupeParticipants(rs *sql.Rows) (GroupeParticipants, error) {
	var (
		item GroupeParticipant
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(GroupeParticipants, 0, 16)
	for rs.Next() {
		item, err = scanOneGroupeParticipant(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item GroupeParticipant) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO groupe_participants (
			idparticipant, idgroupe, idcamp, manuel
			) VALUES (
			$1, $2, $3, $4
			);
			`, item.IdParticipant, item.IdGroupe, item.IdCamp, item.Manuel)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links GroupeParticipant in the database.
// It is a no-op if 'items' is empty.
func InsertManyGroupeParticipants(tx *sql.Tx, items ...GroupeParticipant) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("groupe_participants",
		"idparticipant",
		"idgroupe",
		"idcamp",
		"manuel",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdParticipant, item.IdGroupe, item.IdCamp, item.Manuel)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link GroupeParticipant from the database.
// Only the foreign keys IdParticipant, IdGroupe, IdCamp fields are used in 'item'.
func (item GroupeParticipant) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM groupe_participants WHERE IdParticipant = $1 AND IdGroupe = $2 AND IdCamp = $3;`, item.IdParticipant, item.IdGroupe, item.IdCamp)
	return err
}

// ByIdParticipant returns a map with 'IdParticipant' as keys.
func (items GroupeParticipants) ByIdParticipant() map[IdParticipant]GroupeParticipant {
	out := make(map[IdParticipant]GroupeParticipant, len(items))
	for _, target := range items {
		out[target.IdParticipant] = target
	}
	return out
}

// IdParticipants returns the list of ids of IdParticipant
// contained in this link table.
// They are not garanteed to be distinct.
func (items GroupeParticipants) IdParticipants() []IdParticipant {
	out := make([]IdParticipant, len(items))
	for index, target := range items {
		out[index] = target.IdParticipant
	}
	return out
}

// SelectGroupeParticipantByIdParticipant return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectGroupeParticipantByIdParticipant(tx DB, idParticipant IdParticipant) (item GroupeParticipant, found bool, err error) {
	row := tx.QueryRow("SELECT idparticipant, idgroupe, idcamp, manuel FROM groupe_participants WHERE idparticipant = $1", idParticipant)
	item, err = ScanGroupeParticipant(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectGroupeParticipantsByIdParticipants(tx DB, idParticipants_ ...IdParticipant) (GroupeParticipants, error) {
	rows, err := tx.Query("SELECT idparticipant, idgroupe, idcamp, manuel FROM groupe_participants WHERE idparticipant = ANY($1)", IdParticipantArrayToPQ(idParticipants_))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

func DeleteGroupeParticipantsByIdParticipants(tx DB, idParticipants_ ...IdParticipant) (GroupeParticipants, error) {
	rows, err := tx.Query("DELETE FROM groupe_participants WHERE idparticipant = ANY($1) RETURNING idparticipant, idgroupe, idcamp, manuel", IdParticipantArrayToPQ(idParticipants_))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

// ByIdGroupe returns a map with 'IdGroupe' as keys.
func (items GroupeParticipants) ByIdGroupe() map[IdGroupe]GroupeParticipants {
	out := make(map[IdGroupe]GroupeParticipants)
	for _, target := range items {
		out[target.IdGroupe] = append(out[target.IdGroupe], target)
	}
	return out
}

// IdGroupes returns the list of ids of IdGroupe
// contained in this link table.
// They are not garanteed to be distinct.
func (items GroupeParticipants) IdGroupes() []IdGroupe {
	out := make([]IdGroupe, len(items))
	for index, target := range items {
		out[index] = target.IdGroupe
	}
	return out
}

func SelectGroupeParticipantsByIdGroupes(tx DB, idGroupes_ ...IdGroupe) (GroupeParticipants, error) {
	rows, err := tx.Query("SELECT idparticipant, idgroupe, idcamp, manuel FROM groupe_participants WHERE idgroupe = ANY($1)", IdGroupeArrayToPQ(idGroupes_))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

func DeleteGroupeParticipantsByIdGroupes(tx DB, idGroupes_ ...IdGroupe) (GroupeParticipants, error) {
	rows, err := tx.Query("DELETE FROM groupe_participants WHERE idgroupe = ANY($1) RETURNING idparticipant, idgroupe, idcamp, manuel", IdGroupeArrayToPQ(idGroupes_))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items GroupeParticipants) ByIdCamp() map[IdCamp]GroupeParticipants {
	out := make(map[IdCamp]GroupeParticipants)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this link table.
// They are not garanteed to be distinct.
func (items GroupeParticipants) IdCamps() []IdCamp {
	out := make([]IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

func SelectGroupeParticipantsByIdCamps(tx DB, idCamps_ ...IdCamp) (GroupeParticipants, error) {
	rows, err := tx.Query("SELECT idparticipant, idgroupe, idcamp, manuel FROM groupe_participants WHERE idcamp = ANY($1)", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

func DeleteGroupeParticipantsByIdCamps(tx DB, idCamps_ ...IdCamp) (GroupeParticipants, error) {
	rows, err := tx.Query("DELETE FROM groupe_participants WHERE idcamp = ANY($1) RETURNING idparticipant, idgroupe, idcamp, manuel", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

// SelectGroupeParticipantByIdParticipantAndIdCamp return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectGroupeParticipantByIdParticipantAndIdCamp(tx DB, idParticipant IdParticipant, idCamp IdCamp) (item GroupeParticipant, found bool, err error) {
	row := tx.QueryRow("SELECT idparticipant, idgroupe, idcamp, manuel FROM groupe_participants WHERE IdParticipant = $1 AND IdCamp = $2", idParticipant, idCamp)
	item, err = ScanGroupeParticipant(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

// SelectGroupeByIdCampAndNom return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectGroupeByIdCampAndNom(tx DB, idCamp IdCamp, nom string) (item Groupe, found bool, err error) {
	row := tx.QueryRow("SELECT id, idcamp, nom, plage, couleur FROM groupes WHERE IdCamp = $1 AND Nom = $2", idCamp, nom)
	item, err = ScanGroupe(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

// SelectGroupeByIdAndIdCamp return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectGroupeByIdAndIdCamp(tx DB, id IdGroupe, idCamp IdCamp) (item Groupe, found bool, err error) {
	row := tx.QueryRow("SELECT id, idcamp, nom, plage, couleur FROM groupes WHERE Id = $1 AND IdCamp = $2", id, idCamp)
	item, err = ScanGroupe(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneLettreImage(row scanner) (LettreImage, error) {
	var item LettreImage
	err := row.Scan(
		&item.Id,
		&item.IdCamp,
		&item.Filename,
		&item.Content,
	)
	return item, err
}

func ScanLettreImage(row *sql.Row) (LettreImage, error) { return scanOneLettreImage(row) }

// SelectAll returns all the items in the lettre_images table.
func SelectAllLettreImages(db DB) (LettreImages, error) {
	rows, err := db.Query("SELECT id, idcamp, filename, content FROM lettre_images")
	if err != nil {
		return nil, err
	}
	return ScanLettreImages(rows)
}

// SelectLettreImage returns the entry matching 'id'.
func SelectLettreImage(tx DB, id IdLettreImage) (LettreImage, error) {
	row := tx.QueryRow("SELECT id, idcamp, filename, content FROM lettre_images WHERE id = $1", id)
	return ScanLettreImage(row)
}

// SelectLettreImages returns the entry matching the given 'ids'.
func SelectLettreImages(tx DB, ids ...IdLettreImage) (LettreImages, error) {
	rows, err := tx.Query("SELECT id, idcamp, filename, content FROM lettre_images WHERE id = ANY($1)", IdLettreImageArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanLettreImages(rows)
}

type LettreImages map[IdLettreImage]LettreImage

func (m LettreImages) IDs() []IdLettreImage {
	out := make([]IdLettreImage, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanLettreImages(rs *sql.Rows) (LettreImages, error) {
	var (
		s   LettreImage
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(LettreImages, 16)
	for rs.Next() {
		s, err = scanOneLettreImage(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one LettreImage in the database and returns the item with id filled.
func (item LettreImage) Insert(tx DB) (out LettreImage, err error) {
	row := tx.QueryRow(`INSERT INTO lettre_images (
		idcamp, filename, content
		) VALUES (
		$1, $2, $3
		) RETURNING id, idcamp, filename, content;
		`, item.IdCamp, item.Filename, item.Content)
	return ScanLettreImage(row)
}

// Update LettreImage in the database and returns the new version.
func (item LettreImage) Update(tx DB) (out LettreImage, err error) {
	row := tx.QueryRow(`UPDATE lettre_images SET (
		idcamp, filename, content
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING id, idcamp, filename, content;
		`, item.IdCamp, item.Filename, item.Content, item.Id)
	return ScanLettreImage(row)
}

// Deletes the LettreImage and returns the item
func DeleteLettreImageById(tx DB, id IdLettreImage) (LettreImage, error) {
	row := tx.QueryRow("DELETE FROM lettre_images WHERE id = $1 RETURNING id, idcamp, filename, content;", id)
	return ScanLettreImage(row)
}

// Deletes the LettreImage in the database and returns the ids.
func DeleteLettreImagesByIDs(tx DB, ids ...IdLettreImage) ([]IdLettreImage, error) {
	rows, err := tx.Query("DELETE FROM lettre_images WHERE id = ANY($1) RETURNING id", IdLettreImageArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdLettreImageArray(rows)
}

func scanOneLettredirecteur(row scanner) (Lettredirecteur, error) {
	var item Lettredirecteur
	err := row.Scan(
		&item.IdCamp,
		&item.Html,
		&item.UseCoordCentre,
		&item.ShowAdressePostale,
		&item.ColorCoord,
	)
	return item, err
}

func ScanLettredirecteur(row *sql.Row) (Lettredirecteur, error) { return scanOneLettredirecteur(row) }

// SelectAll returns all the items in the lettredirecteurs table.
func SelectAllLettredirecteurs(db DB) (Lettredirecteurs, error) {
	rows, err := db.Query("SELECT idcamp, html, usecoordcentre, showadressepostale, colorcoord FROM lettredirecteurs")
	if err != nil {
		return nil, err
	}
	return ScanLettredirecteurs(rows)
}

type Lettredirecteurs []Lettredirecteur

func ScanLettredirecteurs(rs *sql.Rows) (Lettredirecteurs, error) {
	var (
		item Lettredirecteur
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Lettredirecteurs, 0, 16)
	for rs.Next() {
		item, err = scanOneLettredirecteur(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item Lettredirecteur) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO lettredirecteurs (
			idcamp, html, usecoordcentre, showadressepostale, colorcoord
			) VALUES (
			$1, $2, $3, $4, $5
			);
			`, item.IdCamp, item.Html, item.UseCoordCentre, item.ShowAdressePostale, item.ColorCoord)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links Lettredirecteur in the database.
// It is a no-op if 'items' is empty.
func InsertManyLettredirecteurs(tx *sql.Tx, items ...Lettredirecteur) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("lettredirecteurs",
		"idcamp",
		"html",
		"usecoordcentre",
		"showadressepostale",
		"colorcoord",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdCamp, item.Html, item.UseCoordCentre, item.ShowAdressePostale, item.ColorCoord)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Lettredirecteur from the database.
// Only the foreign keys IdCamp fields are used in 'item'.
func (item Lettredirecteur) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM lettredirecteurs WHERE IdCamp = $1;`, item.IdCamp)
	return err
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Lettredirecteurs) ByIdCamp() map[IdCamp]Lettredirecteur {
	out := make(map[IdCamp]Lettredirecteur, len(items))
	for _, target := range items {
		out[target.IdCamp] = target
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this link table.
// They are not garanteed to be distinct.
func (items Lettredirecteurs) IdCamps() []IdCamp {
	out := make([]IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

// SelectLettredirecteurByIdCamp return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectLettredirecteurByIdCamp(tx DB, idCamp IdCamp) (item Lettredirecteur, found bool, err error) {
	row := tx.QueryRow("SELECT idcamp, html, usecoordcentre, showadressepostale, colorcoord FROM lettredirecteurs WHERE idcamp = $1", idCamp)
	item, err = ScanLettredirecteur(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectLettredirecteursByIdCamps(tx DB, idCamps_ ...IdCamp) (Lettredirecteurs, error) {
	rows, err := tx.Query("SELECT idcamp, html, usecoordcentre, showadressepostale, colorcoord FROM lettredirecteurs WHERE idcamp = ANY($1)", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanLettredirecteurs(rows)
}

func DeleteLettredirecteursByIdCamps(tx DB, idCamps_ ...IdCamp) (Lettredirecteurs, error) {
	rows, err := tx.Query("DELETE FROM lettredirecteurs WHERE idcamp = ANY($1) RETURNING idcamp, html, usecoordcentre, showadressepostale, colorcoord", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanLettredirecteurs(rows)
}

func scanOneParticipant(row scanner) (Participant, error) {
	var item Participant
	err := row.Scan(
		&item.Id,
		&item.IdCamp,
		&item.IdPersonne,
		&item.IdDossier,
		&item.IdTaux,
		&item.Statut,
		&item.Remises,
		&item.QuotientFamilial,
		&item.OptionPrix,
		&item.Details,
		&item.Navette,
	)
	return item, err
}

func ScanParticipant(row *sql.Row) (Participant, error) { return scanOneParticipant(row) }

// SelectAll returns all the items in the participants table.
func SelectAllParticipants(db DB) (Participants, error) {
	rows, err := db.Query("SELECT id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette FROM participants")
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

// SelectParticipant returns the entry matching 'id'.
func SelectParticipant(tx DB, id IdParticipant) (Participant, error) {
	row := tx.QueryRow("SELECT id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette FROM participants WHERE id = $1", id)
	return ScanParticipant(row)
}

// SelectParticipants returns the entry matching the given 'ids'.
func SelectParticipants(tx DB, ids ...IdParticipant) (Participants, error) {
	rows, err := tx.Query("SELECT id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette FROM participants WHERE id = ANY($1)", IdParticipantArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

type Participants map[IdParticipant]Participant

func (m Participants) IDs() []IdParticipant {
	out := make([]IdParticipant, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanParticipants(rs *sql.Rows) (Participants, error) {
	var (
		s   Participant
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Participants, 16)
	for rs.Next() {
		s, err = scanOneParticipant(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Participant in the database and returns the item with id filled.
func (item Participant) Insert(tx DB) (out Participant, err error) {
	row := tx.QueryRow(`INSERT INTO participants (
		idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10
		) RETURNING id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette;
		`, item.IdCamp, item.IdPersonne, item.IdDossier, item.IdTaux, item.Statut, item.Remises, item.QuotientFamilial, item.OptionPrix, item.Details, item.Navette)
	return ScanParticipant(row)
}

// Update Participant in the database and returns the new version.
func (item Participant) Update(tx DB) (out Participant, err error) {
	row := tx.QueryRow(`UPDATE participants SET (
		idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10
		) WHERE id = $11 RETURNING id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette;
		`, item.IdCamp, item.IdPersonne, item.IdDossier, item.IdTaux, item.Statut, item.Remises, item.QuotientFamilial, item.OptionPrix, item.Details, item.Navette, item.Id)
	return ScanParticipant(row)
}

// Deletes the Participant and returns the item
func DeleteParticipantById(tx DB, id IdParticipant) (Participant, error) {
	row := tx.QueryRow("DELETE FROM participants WHERE id = $1 RETURNING id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette;", id)
	return ScanParticipant(row)
}

// Deletes the Participant in the database and returns the ids.
func DeleteParticipantsByIDs(tx DB, ids ...IdParticipant) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE id = ANY($1) RETURNING id", IdParticipantArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Participants) ByIdCamp() map[IdCamp]Participants {
	out := make(map[IdCamp]Participants)
	for _, target := range items {
		dict := out[target.IdCamp]
		if dict == nil {
			dict = make(Participants)
		}
		dict[target.Id] = target
		out[target.IdCamp] = dict
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this table.
// They are not garanteed to be distinct.
func (items Participants) IdCamps() []IdCamp {
	out := make([]IdCamp, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdCamp)
	}
	return out
}

func SelectParticipantsByIdCamps(tx DB, idCamps_ ...IdCamp) (Participants, error) {
	rows, err := tx.Query("SELECT id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette FROM participants WHERE idcamp = ANY($1)", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdCamps(tx DB, idCamps_ ...IdCamp) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE idcamp = ANY($1) RETURNING id", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items Participants) ByIdPersonne() map[personnes.IdPersonne]Participants {
	out := make(map[personnes.IdPersonne]Participants)
	for _, target := range items {
		dict := out[target.IdPersonne]
		if dict == nil {
			dict = make(Participants)
		}
		dict[target.Id] = target
		out[target.IdPersonne] = dict
	}
	return out
}

// IdPersonnes returns the list of ids of IdPersonne
// contained in this table.
// They are not garanteed to be distinct.
func (items Participants) IdPersonnes() []personnes.IdPersonne {
	out := make([]personnes.IdPersonne, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdPersonne)
	}
	return out
}

func SelectParticipantsByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) (Participants, error) {
	rows, err := tx.Query("SELECT id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette FROM participants WHERE idpersonne = ANY($1)", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE idpersonne = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// ByIdDossier returns a map with 'IdDossier' as keys.
func (items Participants) ByIdDossier() map[dossiers.IdDossier]Participants {
	out := make(map[dossiers.IdDossier]Participants)
	for _, target := range items {
		dict := out[target.IdDossier]
		if dict == nil {
			dict = make(Participants)
		}
		dict[target.Id] = target
		out[target.IdDossier] = dict
	}
	return out
}

// IdDossiers returns the list of ids of IdDossier
// contained in this table.
// They are not garanteed to be distinct.
func (items Participants) IdDossiers() []dossiers.IdDossier {
	out := make([]dossiers.IdDossier, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdDossier)
	}
	return out
}

func SelectParticipantsByIdDossiers(tx DB, idDossiers_ ...dossiers.IdDossier) (Participants, error) {
	rows, err := tx.Query("SELECT id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette FROM participants WHERE iddossier = ANY($1)", dossiers.IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdDossiers(tx DB, idDossiers_ ...dossiers.IdDossier) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE iddossier = ANY($1) RETURNING id", dossiers.IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// ByIdTaux returns a map with 'IdTaux' as keys.
func (items Participants) ByIdTaux() map[dossiers.IdTaux]Participants {
	out := make(map[dossiers.IdTaux]Participants)
	for _, target := range items {
		dict := out[target.IdTaux]
		if dict == nil {
			dict = make(Participants)
		}
		dict[target.Id] = target
		out[target.IdTaux] = dict
	}
	return out
}

// IdTauxs returns the list of ids of IdTaux
// contained in this table.
// They are not garanteed to be distinct.
func (items Participants) IdTauxs() []dossiers.IdTaux {
	out := make([]dossiers.IdTaux, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTaux)
	}
	return out
}

func SelectParticipantsByIdTauxs(tx DB, idTauxs_ ...dossiers.IdTaux) (Participants, error) {
	rows, err := tx.Query("SELECT id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette FROM participants WHERE idtaux = ANY($1)", dossiers.IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdTauxs(tx DB, idTauxs_ ...dossiers.IdTaux) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE idtaux = ANY($1) RETURNING id", dossiers.IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// SelectParticipantByIdCampAndIdPersonne return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectParticipantByIdCampAndIdPersonne(tx DB, idCamp IdCamp, idPersonne personnes.IdPersonne) (item Participant, found bool, err error) {
	row := tx.QueryRow("SELECT id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette FROM participants WHERE IdCamp = $1 AND IdPersonne = $2", idCamp, idPersonne)
	item, err = ScanParticipant(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

// SelectParticipantByIdAndIdCamp return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectParticipantByIdAndIdCamp(tx DB, id IdParticipant, idCamp IdCamp) (item Participant, found bool, err error) {
	row := tx.QueryRow("SELECT id, idcamp, idpersonne, iddossier, idtaux, statut, remises, quotientfamilial, optionprix, details, navette FROM participants WHERE Id = $1 AND IdCamp = $2", id, idCamp)
	item, err = ScanParticipant(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneSondage(row scanner) (Sondage, error) {
	var item Sondage
	err := row.Scan(
		&item.IdSondage,
		&item.IdCamp,
		&item.IdDossier,
		&item.Modified,
		&item.InfosAvantSejour,
		&item.InfosPendantSejour,
		&item.Hebergement,
		&item.Activites,
		&item.Theme,
		&item.Nourriture,
		&item.Hygiene,
		&item.Ambiance,
		&item.Ressenti,
		&item.MessageEnfant,
		&item.MessageResponsable,
	)
	return item, err
}

func ScanSondage(row *sql.Row) (Sondage, error) { return scanOneSondage(row) }

// SelectAll returns all the items in the sondages table.
func SelectAllSondages(db DB) (Sondages, error) {
	rows, err := db.Query("SELECT idsondage, idcamp, iddossier, modified, infosavantsejour, infospendantsejour, hebergement, activites, theme, nourriture, hygiene, ambiance, ressenti, messageenfant, messageresponsable FROM sondages")
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

type Sondages []Sondage

func ScanSondages(rs *sql.Rows) (Sondages, error) {
	var (
		item Sondage
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Sondages, 0, 16)
	for rs.Next() {
		item, err = scanOneSondage(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item Sondage) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO sondages (
			idsondage, idcamp, iddossier, modified, infosavantsejour, infospendantsejour, hebergement, activites, theme, nourriture, hygiene, ambiance, ressenti, messageenfant, messageresponsable
			) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
			);
			`, item.IdSondage, item.IdCamp, item.IdDossier, item.Modified, item.InfosAvantSejour, item.InfosPendantSejour, item.Hebergement, item.Activites, item.Theme, item.Nourriture, item.Hygiene, item.Ambiance, item.Ressenti, item.MessageEnfant, item.MessageResponsable)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links Sondage in the database.
// It is a no-op if 'items' is empty.
func InsertManySondages(tx *sql.Tx, items ...Sondage) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("sondages",
		"idsondage",
		"idcamp",
		"iddossier",
		"modified",
		"infosavantsejour",
		"infospendantsejour",
		"hebergement",
		"activites",
		"theme",
		"nourriture",
		"hygiene",
		"ambiance",
		"ressenti",
		"messageenfant",
		"messageresponsable",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdSondage, item.IdCamp, item.IdDossier, item.Modified, item.InfosAvantSejour, item.InfosPendantSejour, item.Hebergement, item.Activites, item.Theme, item.Nourriture, item.Hygiene, item.Ambiance, item.Ressenti, item.MessageEnfant, item.MessageResponsable)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Sondage from the database.
// Only the foreign keys IdCamp, IdDossier fields are used in 'item'.
func (item Sondage) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM sondages WHERE IdCamp = $1 AND IdDossier = $2;`, item.IdCamp, item.IdDossier)
	return err
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Sondages) ByIdCamp() map[IdCamp]Sondages {
	out := make(map[IdCamp]Sondages)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this link table.
// They are not garanteed to be distinct.
func (items Sondages) IdCamps() []IdCamp {
	out := make([]IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

func SelectSondagesByIdCamps(tx DB, idCamps_ ...IdCamp) (Sondages, error) {
	rows, err := tx.Query("SELECT idsondage, idcamp, iddossier, modified, infosavantsejour, infospendantsejour, hebergement, activites, theme, nourriture, hygiene, ambiance, ressenti, messageenfant, messageresponsable FROM sondages WHERE idcamp = ANY($1)", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

func DeleteSondagesByIdCamps(tx DB, idCamps_ ...IdCamp) (Sondages, error) {
	rows, err := tx.Query("DELETE FROM sondages WHERE idcamp = ANY($1) RETURNING idsondage, idcamp, iddossier, modified, infosavantsejour, infospendantsejour, hebergement, activites, theme, nourriture, hygiene, ambiance, ressenti, messageenfant, messageresponsable", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

// ByIdDossier returns a map with 'IdDossier' as keys.
func (items Sondages) ByIdDossier() map[dossiers.IdDossier]Sondages {
	out := make(map[dossiers.IdDossier]Sondages)
	for _, target := range items {
		out[target.IdDossier] = append(out[target.IdDossier], target)
	}
	return out
}

// IdDossiers returns the list of ids of IdDossier
// contained in this link table.
// They are not garanteed to be distinct.
func (items Sondages) IdDossiers() []dossiers.IdDossier {
	out := make([]dossiers.IdDossier, len(items))
	for index, target := range items {
		out[index] = target.IdDossier
	}
	return out
}

func SelectSondagesByIdDossiers(tx DB, idDossiers_ ...dossiers.IdDossier) (Sondages, error) {
	rows, err := tx.Query("SELECT idsondage, idcamp, iddossier, modified, infosavantsejour, infospendantsejour, hebergement, activites, theme, nourriture, hygiene, ambiance, ressenti, messageenfant, messageresponsable FROM sondages WHERE iddossier = ANY($1)", dossiers.IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

func DeleteSondagesByIdDossiers(tx DB, idDossiers_ ...dossiers.IdDossier) (Sondages, error) {
	rows, err := tx.Query("DELETE FROM sondages WHERE iddossier = ANY($1) RETURNING idsondage, idcamp, iddossier, modified, infosavantsejour, infospendantsejour, hebergement, activites, theme, nourriture, hygiene, ambiance, ressenti, messageenfant, messageresponsable", dossiers.IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

// SelectSondageByIdCampAndIdDossier return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectSondageByIdCampAndIdDossier(tx DB, idCamp IdCamp, idDossier dossiers.IdDossier) (item Sondage, found bool, err error) {
	row := tx.QueryRow("SELECT idsondage, idcamp, iddossier, modified, infosavantsejour, infospendantsejour, hebergement, activites, theme, nourriture, hygiene, ambiance, ressenti, messageenfant, messageresponsable FROM sondages WHERE IdCamp = $1 AND IdDossier = $2", idCamp, idDossier)
	item, err = ScanSondage(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneStructureaide(row scanner) (Structureaide, error) {
	var item Structureaide
	err := row.Scan(
		&item.Id,
		&item.Nom,
		&item.Immatriculation,
		&item.Info,
	)
	return item, err
}

func ScanStructureaide(row *sql.Row) (Structureaide, error) { return scanOneStructureaide(row) }

// SelectAll returns all the items in the structureaides table.
func SelectAllStructureaides(db DB) (Structureaides, error) {
	rows, err := db.Query("SELECT id, nom, immatriculation, info FROM structureaides")
	if err != nil {
		return nil, err
	}
	return ScanStructureaides(rows)
}

// SelectStructureaide returns the entry matching 'id'.
func SelectStructureaide(tx DB, id IdStructureaide) (Structureaide, error) {
	row := tx.QueryRow("SELECT id, nom, immatriculation, info FROM structureaides WHERE id = $1", id)
	return ScanStructureaide(row)
}

// SelectStructureaides returns the entry matching the given 'ids'.
func SelectStructureaides(tx DB, ids ...IdStructureaide) (Structureaides, error) {
	rows, err := tx.Query("SELECT id, nom, immatriculation, info FROM structureaides WHERE id = ANY($1)", IdStructureaideArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanStructureaides(rows)
}

type Structureaides map[IdStructureaide]Structureaide

func (m Structureaides) IDs() []IdStructureaide {
	out := make([]IdStructureaide, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanStructureaides(rs *sql.Rows) (Structureaides, error) {
	var (
		s   Structureaide
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Structureaides, 16)
	for rs.Next() {
		s, err = scanOneStructureaide(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Structureaide in the database and returns the item with id filled.
func (item Structureaide) Insert(tx DB) (out Structureaide, err error) {
	row := tx.QueryRow(`INSERT INTO structureaides (
		nom, immatriculation, info
		) VALUES (
		$1, $2, $3
		) RETURNING id, nom, immatriculation, info;
		`, item.Nom, item.Immatriculation, item.Info)
	return ScanStructureaide(row)
}

// Update Structureaide in the database and returns the new version.
func (item Structureaide) Update(tx DB) (out Structureaide, err error) {
	row := tx.QueryRow(`UPDATE structureaides SET (
		nom, immatriculation, info
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING id, nom, immatriculation, info;
		`, item.Nom, item.Immatriculation, item.Info, item.Id)
	return ScanStructureaide(row)
}

// Deletes the Structureaide and returns the item
func DeleteStructureaideById(tx DB, id IdStructureaide) (Structureaide, error) {
	row := tx.QueryRow("DELETE FROM structureaides WHERE id = $1 RETURNING id, nom, immatriculation, info;", id)
	return ScanStructureaide(row)
}

// Deletes the Structureaide in the database and returns the ids.
func DeleteStructureaidesByIDs(tx DB, ids ...IdStructureaide) ([]IdStructureaide, error) {
	rows, err := tx.Query("DELETE FROM structureaides WHERE id = ANY($1) RETURNING id", IdStructureaideArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdStructureaideArray(rows)
}

func loadJSON(out any, src any) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s any) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *PrixQuotientFamilial) Scan(src any) error {
	var tmp pq.Int32Array
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	if len(tmp) != 4 {
		return fmt.Errorf("unexpected length %d", len(tmp))
	}
	copy(s[:], tmp)
	return nil

}
func (s PrixQuotientFamilial) Value() (driver.Value, error) {
	return pq.Int32Array(s[:]).Value()
}

func (s *Roles) Scan(src any) error {
	var tmp pq.Int32Array
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = make([]Role, len(tmp))
	for i, v := range tmp {
		(*s)[i] = Role(v)
	}
	return nil
}
func (s Roles) Value() (driver.Value, error) {
	tmp := make(pq.Int32Array, len(s))
	for i, v := range s {
		tmp[i] = int32(v)
	}
	return tmp.Value()
}

func (s *PresenceOffsets) Scan(src any) error {
	bs, ok := src.([]byte)
	if !ok {
		return fmt.Errorf("unsupported type %T", src)
	}
	fields := strings.Split(string(bs[1:len(bs)-1]), ",")
	if len(fields) != 2 {
		return fmt.Errorf("unsupported number of fields %d", len(fields))
	}

	valDebut, err := strconv.Atoi(fields[0])
	if err != nil {
		return err
	}
	s.Debut = int(valDebut)

	valFin, err := strconv.Atoi(fields[1])
	if err != nil {
		return err
	}
	s.Fin = int(valFin)

	return nil
}
func (s PresenceOffsets) Value() (driver.Value, error) {
	bs := fmt.Appendf(nil, "(%d, %d)", s.Debut, s.Fin)
	return driver.Value(bs), nil
}

func IdAideArrayToPQ(ids []IdAide) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdAideArray scans the result of a query returning a
// list of ID's.
func ScanIdAideArray(rs *sql.Rows) ([]IdAide, error) {
	defer rs.Close()
	ints := make([]IdAide, 0, 16)
	var err error
	for rs.Next() {
		var s IdAide
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdCampArrayToPQ(ids []IdCamp) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdCampArray scans the result of a query returning a
// list of ID's.
func ScanIdCampArray(rs *sql.Rows) ([]IdCamp, error) {
	defer rs.Close()
	ints := make([]IdCamp, 0, 16)
	var err error
	for rs.Next() {
		var s IdCamp
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdEquipierArrayToPQ(ids []IdEquipier) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdEquipierArray scans the result of a query returning a
// list of ID's.
func ScanIdEquipierArray(rs *sql.Rows) ([]IdEquipier, error) {
	defer rs.Close()
	ints := make([]IdEquipier, 0, 16)
	var err error
	for rs.Next() {
		var s IdEquipier
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdGroupeArrayToPQ(ids []IdGroupe) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdGroupeArray scans the result of a query returning a
// list of ID's.
func ScanIdGroupeArray(rs *sql.Rows) ([]IdGroupe, error) {
	defer rs.Close()
	ints := make([]IdGroupe, 0, 16)
	var err error
	for rs.Next() {
		var s IdGroupe
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdLettreImageArrayToPQ(ids []IdLettreImage) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdLettreImageArray scans the result of a query returning a
// list of ID's.
func ScanIdLettreImageArray(rs *sql.Rows) ([]IdLettreImage, error) {
	defer rs.Close()
	ints := make([]IdLettreImage, 0, 16)
	var err error
	for rs.Next() {
		var s IdLettreImage
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdParticipantArrayToPQ(ids []IdParticipant) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdParticipantArray scans the result of a query returning a
// list of ID's.
func ScanIdParticipantArray(rs *sql.Rows) ([]IdParticipant, error) {
	defer rs.Close()
	ints := make([]IdParticipant, 0, 16)
	var err error
	for rs.Next() {
		var s IdParticipant
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdStructureaideArrayToPQ(ids []IdStructureaide) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdStructureaideArray scans the result of a query returning a
// list of ID's.
func ScanIdStructureaideArray(rs *sql.Rows) ([]IdStructureaide, error) {
	defer rs.Close()
	ints := make([]IdStructureaide, 0, 16)
	var err error
	for rs.Next() {
		var s IdStructureaide
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func (s *OptionNavette) Scan(src any) error          { return loadJSON(s, src) }
func (s OptionNavette) Value() (driver.Value, error) { return dumpJSON(s) }

func (s *OptionPrixCamp) Scan(src any) error          { return loadJSON(s, src) }
func (s OptionPrixCamp) Value() (driver.Value, error) { return dumpJSON(s) }

func (s *OptionPrixParticipant) Scan(src any) error          { return loadJSON(s, src) }
func (s OptionPrixParticipant) Value() (driver.Value, error) { return dumpJSON(s) }

func (s *Remises) Scan(src any) error          { return loadJSON(s, src) }
func (s Remises) Value() (driver.Value, error) { return dumpJSON(s) }

func SwitchEquipierPersonne(db DB, target personnes.IdPersonne, temporaire personnes.IdPersonne) error {
	_, err := db.Exec("UPDATE equipiers SET IdPersonne = $1 WHERE IdPersonne = $2;", target, temporaire)
	return err
}

func SwitchParticipantPersonne(db DB, target personnes.IdPersonne, temporaire personnes.IdPersonne) error {
	_, err := db.Exec("UPDATE participants SET IdPersonne = $1 WHERE IdPersonne = $2;", target, temporaire)
	return err
}

func SwitchParticipantDossier(db DB, to dossiers.IdDossier, from dossiers.IdDossier) error {
	_, err := db.Exec("UPDATE participants SET IdDossier = $1 WHERE IdDossier = $2;", to, from)
	return err
}

func SwitchSondageDossier(db DB, to dossiers.IdDossier, from dossiers.IdDossier) error {
	_, err := db.Exec("UPDATE sondages SET IdDossier = $1 WHERE IdDossier = $2;", to, from)
	return err
}
