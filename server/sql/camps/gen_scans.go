package camps

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"registro/sql/personnes"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneCamp(row scanner) (Camp, error) {
	var item Camp
	err := row.Scan(
		&item.Id,
		&item.Nom,
		&item.DateDebut,
		&item.Duree,
		&item.Agrement,
	)
	return item, err
}

func ScanCamp(row *sql.Row) (Camp, error) { return scanOneCamp(row) }

// SelectAll returns all the items in the camps table.
func SelectAllCamps(db DB) (Camps, error) {
	rows, err := db.Query("SELECT * FROM camps")
	if err != nil {
		return nil, err
	}
	return ScanCamps(rows)
}

// SelectCamp returns the entry matching 'id'.
func SelectCamp(tx DB, id IdCamp) (Camp, error) {
	row := tx.QueryRow("SELECT * FROM camps WHERE id = $1", id)
	return ScanCamp(row)
}

// SelectCamps returns the entry matching the given 'ids'.
func SelectCamps(tx DB, ids ...IdCamp) (Camps, error) {
	rows, err := tx.Query("SELECT * FROM camps WHERE id = ANY($1)", IdCampArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanCamps(rows)
}

type Camps map[IdCamp]Camp

func (m Camps) IDs() []IdCamp {
	out := make([]IdCamp, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanCamps(rs *sql.Rows) (Camps, error) {
	var (
		s   Camp
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Camps, 16)
	for rs.Next() {
		s, err = scanOneCamp(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Camp in the database and returns the item with id filled.
func (item Camp) Insert(tx DB) (out Camp, err error) {
	row := tx.QueryRow(`INSERT INTO camps (
		nom, datedebut, duree, agrement
		) VALUES (
		$1, $2, $3, $4
		) RETURNING *;
		`, item.Nom, item.DateDebut, item.Duree, item.Agrement)
	return ScanCamp(row)
}

// Update Camp in the database and returns the new version.
func (item Camp) Update(tx DB) (out Camp, err error) {
	row := tx.QueryRow(`UPDATE camps SET (
		nom, datedebut, duree, agrement
		) = (
		$1, $2, $3, $4
		) WHERE id = $5 RETURNING *;
		`, item.Nom, item.DateDebut, item.Duree, item.Agrement, item.Id)
	return ScanCamp(row)
}

// Deletes the Camp and returns the item
func DeleteCampById(tx DB, id IdCamp) (Camp, error) {
	row := tx.QueryRow("DELETE FROM camps WHERE id = $1 RETURNING *;", id)
	return ScanCamp(row)
}

// Deletes the Camp in the database and returns the ids.
func DeleteCampsByIDs(tx DB, ids ...IdCamp) ([]IdCamp, error) {
	rows, err := tx.Query("DELETE FROM camps WHERE id = ANY($1) RETURNING id", IdCampArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdCampArray(rows)
}

func scanOneParticipant(row scanner) (Participant, error) {
	var item Participant
	err := row.Scan(
		&item.Id,
		&item.IdCamp,
		&item.IdPersonne,
	)
	return item, err
}

func ScanParticipant(row *sql.Row) (Participant, error) { return scanOneParticipant(row) }

// SelectAll returns all the items in the participants table.
func SelectAllParticipants(db DB) (Participants, error) {
	rows, err := db.Query("SELECT * FROM participants")
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

// SelectParticipant returns the entry matching 'id'.
func SelectParticipant(tx DB, id IdParticipant) (Participant, error) {
	row := tx.QueryRow("SELECT * FROM participants WHERE id = $1", id)
	return ScanParticipant(row)
}

// SelectParticipants returns the entry matching the given 'ids'.
func SelectParticipants(tx DB, ids ...IdParticipant) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE id = ANY($1)", IdParticipantArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

type Participants map[IdParticipant]Participant

func (m Participants) IDs() []IdParticipant {
	out := make([]IdParticipant, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanParticipants(rs *sql.Rows) (Participants, error) {
	var (
		s   Participant
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Participants, 16)
	for rs.Next() {
		s, err = scanOneParticipant(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Participant in the database and returns the item with id filled.
func (item Participant) Insert(tx DB) (out Participant, err error) {
	row := tx.QueryRow(`INSERT INTO participants (
		idcamp, idpersonne
		) VALUES (
		$1, $2
		) RETURNING *;
		`, item.IdCamp, item.IdPersonne)
	return ScanParticipant(row)
}

// Update Participant in the database and returns the new version.
func (item Participant) Update(tx DB) (out Participant, err error) {
	row := tx.QueryRow(`UPDATE participants SET (
		idcamp, idpersonne
		) = (
		$1, $2
		) WHERE id = $3 RETURNING *;
		`, item.IdCamp, item.IdPersonne, item.Id)
	return ScanParticipant(row)
}

// Deletes the Participant and returns the item
func DeleteParticipantById(tx DB, id IdParticipant) (Participant, error) {
	row := tx.QueryRow("DELETE FROM participants WHERE id = $1 RETURNING *;", id)
	return ScanParticipant(row)
}

// Deletes the Participant in the database and returns the ids.
func DeleteParticipantsByIDs(tx DB, ids ...IdParticipant) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE id = ANY($1) RETURNING id", IdParticipantArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Participants) ByIdCamp() map[IdCamp]Participants {
	out := make(map[IdCamp]Participants)
	for _, target := range items {
		dict := out[target.IdCamp]
		if dict == nil {
			dict = make(Participants)
		}
		dict[target.Id] = target
		out[target.IdCamp] = dict
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this table.
// They are not garanteed to be distinct.
func (items Participants) IdCamps() []IdCamp {
	out := make([]IdCamp, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdCamp)
	}
	return out
}

func SelectParticipantsByIdCamps(tx DB, idCamps_ ...IdCamp) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE idcamp = ANY($1)", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdCamps(tx DB, idCamps_ ...IdCamp) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE idcamp = ANY($1) RETURNING id", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items Participants) ByIdPersonne() map[personnes.IdPersonne]Participants {
	out := make(map[personnes.IdPersonne]Participants)
	for _, target := range items {
		dict := out[target.IdPersonne]
		if dict == nil {
			dict = make(Participants)
		}
		dict[target.Id] = target
		out[target.IdPersonne] = dict
	}
	return out
}

// IdPersonnes returns the list of ids of IdPersonne
// contained in this table.
// They are not garanteed to be distinct.
func (items Participants) IdPersonnes() []personnes.IdPersonne {
	out := make([]personnes.IdPersonne, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdPersonne)
	}
	return out
}

func SelectParticipantsByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE idpersonne = ANY($1)", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE idpersonne = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

func IdCampArrayToPQ(ids []IdCamp) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdCampArray scans the result of a query returning a
// list of ID's.
func ScanIdCampArray(rs *sql.Rows) ([]IdCamp, error) {
	defer rs.Close()
	ints := make([]IdCamp, 0, 16)
	var err error
	for rs.Next() {
		var s IdCamp
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdCampSet map[IdCamp]bool

func NewIdCampSetFrom(ids []IdCamp) IdCampSet {
	out := make(IdCampSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdCampSet) Add(id IdCamp) { s[id] = true }

func (s IdCampSet) Has(id IdCamp) bool { return s[id] }

func (s IdCampSet) Keys() []IdCamp {
	out := make([]IdCamp, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdParticipantArrayToPQ(ids []IdParticipant) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdParticipantArray scans the result of a query returning a
// list of ID's.
func ScanIdParticipantArray(rs *sql.Rows) ([]IdParticipant, error) {
	defer rs.Close()
	ints := make([]IdParticipant, 0, 16)
	var err error
	for rs.Next() {
		var s IdParticipant
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdParticipantSet map[IdParticipant]bool

func NewIdParticipantSetFrom(ids []IdParticipant) IdParticipantSet {
	out := make(IdParticipantSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdParticipantSet) Add(id IdParticipant) { s[id] = true }

func (s IdParticipantSet) Has(id IdParticipant) bool { return s[id] }

func (s IdParticipantSet) Keys() []IdParticipant {
	out := make([]IdParticipant, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}
