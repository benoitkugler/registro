package camps

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"registro/sql/personnes"
	"strconv"
	"strings"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneCamp(row scanner) (Camp, error) {
	var item Camp
	err := row.Scan(
		&item.Id,
		&item.Nom,
		&item.DateDebut,
		&item.Duree,
		&item.Agrement,
		&item.Prix,
	)
	return item, err
}

func ScanCamp(row *sql.Row) (Camp, error) { return scanOneCamp(row) }

// SelectAll returns all the items in the camps table.
func SelectAllCamps(db DB) (Camps, error) {
	rows, err := db.Query("SELECT * FROM camps")
	if err != nil {
		return nil, err
	}
	return ScanCamps(rows)
}

// SelectCamp returns the entry matching 'id'.
func SelectCamp(tx DB, id IdCamp) (Camp, error) {
	row := tx.QueryRow("SELECT * FROM camps WHERE id = $1", id)
	return ScanCamp(row)
}

// SelectCamps returns the entry matching the given 'ids'.
func SelectCamps(tx DB, ids ...IdCamp) (Camps, error) {
	rows, err := tx.Query("SELECT * FROM camps WHERE id = ANY($1)", IdCampArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanCamps(rows)
}

type Camps map[IdCamp]Camp

func (m Camps) IDs() []IdCamp {
	out := make([]IdCamp, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanCamps(rs *sql.Rows) (Camps, error) {
	var (
		s   Camp
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Camps, 16)
	for rs.Next() {
		s, err = scanOneCamp(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Camp in the database and returns the item with id filled.
func (item Camp) Insert(tx DB) (out Camp, err error) {
	row := tx.QueryRow(`INSERT INTO camps (
		nom, datedebut, duree, agrement, prix
		) VALUES (
		$1, $2, $3, $4, $5
		) RETURNING *;
		`, item.Nom, item.DateDebut, item.Duree, item.Agrement, item.Prix)
	return ScanCamp(row)
}

// Update Camp in the database and returns the new version.
func (item Camp) Update(tx DB) (out Camp, err error) {
	row := tx.QueryRow(`UPDATE camps SET (
		nom, datedebut, duree, agrement, prix
		) = (
		$1, $2, $3, $4, $5
		) WHERE id = $6 RETURNING *;
		`, item.Nom, item.DateDebut, item.Duree, item.Agrement, item.Prix, item.Id)
	return ScanCamp(row)
}

// Deletes the Camp and returns the item
func DeleteCampById(tx DB, id IdCamp) (Camp, error) {
	row := tx.QueryRow("DELETE FROM camps WHERE id = $1 RETURNING *;", id)
	return ScanCamp(row)
}

// Deletes the Camp in the database and returns the ids.
func DeleteCampsByIDs(tx DB, ids ...IdCamp) ([]IdCamp, error) {
	rows, err := tx.Query("DELETE FROM camps WHERE id = ANY($1) RETURNING id", IdCampArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdCampArray(rows)
}

func scanOneEquipier(row scanner) (Equipier, error) {
	var item Equipier
	err := row.Scan(
		&item.Id,
		&item.IdCamp,
		&item.IdPersonne,
		&item.Roles,
		&item.Presence,
		&item.Invitation,
		&item.AccepteCharte,
	)
	return item, err
}

func ScanEquipier(row *sql.Row) (Equipier, error) { return scanOneEquipier(row) }

// SelectAll returns all the items in the equipiers table.
func SelectAllEquipiers(db DB) (Equipiers, error) {
	rows, err := db.Query("SELECT * FROM equipiers")
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

// SelectEquipier returns the entry matching 'id'.
func SelectEquipier(tx DB, id IdEquipier) (Equipier, error) {
	row := tx.QueryRow("SELECT * FROM equipiers WHERE id = $1", id)
	return ScanEquipier(row)
}

// SelectEquipiers returns the entry matching the given 'ids'.
func SelectEquipiers(tx DB, ids ...IdEquipier) (Equipiers, error) {
	rows, err := tx.Query("SELECT * FROM equipiers WHERE id = ANY($1)", IdEquipierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

type Equipiers map[IdEquipier]Equipier

func (m Equipiers) IDs() []IdEquipier {
	out := make([]IdEquipier, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanEquipiers(rs *sql.Rows) (Equipiers, error) {
	var (
		s   Equipier
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Equipiers, 16)
	for rs.Next() {
		s, err = scanOneEquipier(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Equipier in the database and returns the item with id filled.
func (item Equipier) Insert(tx DB) (out Equipier, err error) {
	row := tx.QueryRow(`INSERT INTO equipiers (
		idcamp, idpersonne, roles, presence, invitation, acceptecharte
		) VALUES (
		$1, $2, $3, $4, $5, $6
		) RETURNING *;
		`, item.IdCamp, item.IdPersonne, item.Roles, item.Presence, item.Invitation, item.AccepteCharte)
	return ScanEquipier(row)
}

// Update Equipier in the database and returns the new version.
func (item Equipier) Update(tx DB) (out Equipier, err error) {
	row := tx.QueryRow(`UPDATE equipiers SET (
		idcamp, idpersonne, roles, presence, invitation, acceptecharte
		) = (
		$1, $2, $3, $4, $5, $6
		) WHERE id = $7 RETURNING *;
		`, item.IdCamp, item.IdPersonne, item.Roles, item.Presence, item.Invitation, item.AccepteCharte, item.Id)
	return ScanEquipier(row)
}

// Deletes the Equipier and returns the item
func DeleteEquipierById(tx DB, id IdEquipier) (Equipier, error) {
	row := tx.QueryRow("DELETE FROM equipiers WHERE id = $1 RETURNING *;", id)
	return ScanEquipier(row)
}

// Deletes the Equipier in the database and returns the ids.
func DeleteEquipiersByIDs(tx DB, ids ...IdEquipier) ([]IdEquipier, error) {
	rows, err := tx.Query("DELETE FROM equipiers WHERE id = ANY($1) RETURNING id", IdEquipierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdEquipierArray(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Equipiers) ByIdCamp() map[IdCamp]Equipiers {
	out := make(map[IdCamp]Equipiers)
	for _, target := range items {
		dict := out[target.IdCamp]
		if dict == nil {
			dict = make(Equipiers)
		}
		dict[target.Id] = target
		out[target.IdCamp] = dict
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this table.
// They are not garanteed to be distinct.
func (items Equipiers) IdCamps() []IdCamp {
	out := make([]IdCamp, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdCamp)
	}
	return out
}

func SelectEquipiersByIdCamps(tx DB, idCamps_ ...IdCamp) (Equipiers, error) {
	rows, err := tx.Query("SELECT * FROM equipiers WHERE idcamp = ANY($1)", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

func DeleteEquipiersByIdCamps(tx DB, idCamps_ ...IdCamp) ([]IdEquipier, error) {
	rows, err := tx.Query("DELETE FROM equipiers WHERE idcamp = ANY($1) RETURNING id", IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanIdEquipierArray(rows)
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items Equipiers) ByIdPersonne() map[personnes.IdPersonne]Equipiers {
	out := make(map[personnes.IdPersonne]Equipiers)
	for _, target := range items {
		dict := out[target.IdPersonne]
		if dict == nil {
			dict = make(Equipiers)
		}
		dict[target.Id] = target
		out[target.IdPersonne] = dict
	}
	return out
}

// IdPersonnes returns the list of ids of IdPersonne
// contained in this table.
// They are not garanteed to be distinct.
func (items Equipiers) IdPersonnes() []personnes.IdPersonne {
	out := make([]personnes.IdPersonne, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdPersonne)
	}
	return out
}

func SelectEquipiersByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) (Equipiers, error) {
	rows, err := tx.Query("SELECT * FROM equipiers WHERE idpersonne = ANY($1)", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

func DeleteEquipiersByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) ([]IdEquipier, error) {
	rows, err := tx.Query("DELETE FROM equipiers WHERE idpersonne = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanIdEquipierArray(rows)
}

// SelectEquipierByIdCampAndIdPersonne return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectEquipierByIdCampAndIdPersonne(tx DB, idCamp IdCamp, idPersonne personnes.IdPersonne) (item Equipier, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM equipiers WHERE IdCamp = $1 AND IdPersonne = $2", idCamp, idPersonne)
	item, err = ScanEquipier(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneImagelettre(row scanner) (Imagelettre, error) {
	var item Imagelettre
	err := row.Scan(
		&item.Id,
		&item.IdCamp,
		&item.Filename,
		&item.Content,
	)
	return item, err
}

func ScanImagelettre(row *sql.Row) (Imagelettre, error) { return scanOneImagelettre(row) }

// SelectAll returns all the items in the imagelettres table.
func SelectAllImagelettres(db DB) (Imagelettres, error) {
	rows, err := db.Query("SELECT * FROM imagelettres")
	if err != nil {
		return nil, err
	}
	return ScanImagelettres(rows)
}

// SelectImagelettre returns the entry matching 'id'.
func SelectImagelettre(tx DB, id IdImagelettre) (Imagelettre, error) {
	row := tx.QueryRow("SELECT * FROM imagelettres WHERE id = $1", id)
	return ScanImagelettre(row)
}

// SelectImagelettres returns the entry matching the given 'ids'.
func SelectImagelettres(tx DB, ids ...IdImagelettre) (Imagelettres, error) {
	rows, err := tx.Query("SELECT * FROM imagelettres WHERE id = ANY($1)", IdImagelettreArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanImagelettres(rows)
}

type Imagelettres map[IdImagelettre]Imagelettre

func (m Imagelettres) IDs() []IdImagelettre {
	out := make([]IdImagelettre, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanImagelettres(rs *sql.Rows) (Imagelettres, error) {
	var (
		s   Imagelettre
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Imagelettres, 16)
	for rs.Next() {
		s, err = scanOneImagelettre(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Imagelettre in the database and returns the item with id filled.
func (item Imagelettre) Insert(tx DB) (out Imagelettre, err error) {
	row := tx.QueryRow(`INSERT INTO imagelettres (
		idcamp, filename, content
		) VALUES (
		$1, $2, $3
		) RETURNING *;
		`, item.IdCamp, item.Filename, item.Content)
	return ScanImagelettre(row)
}

// Update Imagelettre in the database and returns the new version.
func (item Imagelettre) Update(tx DB) (out Imagelettre, err error) {
	row := tx.QueryRow(`UPDATE imagelettres SET (
		idcamp, filename, content
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING *;
		`, item.IdCamp, item.Filename, item.Content, item.Id)
	return ScanImagelettre(row)
}

// Deletes the Imagelettre and returns the item
func DeleteImagelettreById(tx DB, id IdImagelettre) (Imagelettre, error) {
	row := tx.QueryRow("DELETE FROM imagelettres WHERE id = $1 RETURNING *;", id)
	return ScanImagelettre(row)
}

// Deletes the Imagelettre in the database and returns the ids.
func DeleteImagelettresByIDs(tx DB, ids ...IdImagelettre) ([]IdImagelettre, error) {
	rows, err := tx.Query("DELETE FROM imagelettres WHERE id = ANY($1) RETURNING id", IdImagelettreArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdImagelettreArray(rows)
}

func scanOneLettredirecteur(row scanner) (Lettredirecteur, error) {
	var item Lettredirecteur
	err := row.Scan(
		&item.IdCamp,
		&item.Html,
		&item.UseCoordCentre,
		&item.ShowAdressePostale,
		&item.ColorCoord,
	)
	return item, err
}

func ScanLettredirecteur(row *sql.Row) (Lettredirecteur, error) { return scanOneLettredirecteur(row) }

// SelectAll returns all the items in the lettredirecteurs table.
func SelectAllLettredirecteurs(db DB) (Lettredirecteurs, error) {
	rows, err := db.Query("SELECT * FROM lettredirecteurs")
	if err != nil {
		return nil, err
	}
	return ScanLettredirecteurs(rows)
}

type Lettredirecteurs []Lettredirecteur

func ScanLettredirecteurs(rs *sql.Rows) (Lettredirecteurs, error) {
	var (
		item Lettredirecteur
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Lettredirecteurs, 0, 16)
	for rs.Next() {
		item, err = scanOneLettredirecteur(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func InsertLettredirecteur(db DB, item Lettredirecteur) error {
	_, err := db.Exec(`INSERT INTO lettredirecteurs (
			idcamp, html, usecoordcentre, showadressepostale, colorcoord
			) VALUES (
			$1, $2, $3, $4, $5
			);
			`, item.IdCamp, item.Html, item.UseCoordCentre, item.ShowAdressePostale, item.ColorCoord)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links Lettredirecteur in the database.
// It is a no-op if 'items' is empty.
func InsertManyLettredirecteurs(tx *sql.Tx, items ...Lettredirecteur) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("lettredirecteurs",
		"idcamp",
		"html",
		"usecoordcentre",
		"showadressepostale",
		"colorcoord",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdCamp, item.Html, item.UseCoordCentre, item.ShowAdressePostale, item.ColorCoord)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Lettredirecteur from the database.
// Only the foreign keys  fields are used in 'item'.
func (item Lettredirecteur) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM lettredirecteurs WHERE ;`)
	return err
}

// SelectLettredirecteurByIdCamp return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectLettredirecteurByIdCamp(tx DB, idCamp int64) (item Lettredirecteur, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM lettredirecteurs WHERE IdCamp = $1", idCamp)
	item, err = ScanLettredirecteur(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *Roles) Scan(src interface{}) error {
	var tmp pq.Int32Array
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = make([]Role, len(tmp))
	for i, v := range tmp {
		(*s)[i] = Role(v)
	}
	return nil
}
func (s Roles) Value() (driver.Value, error) {
	tmp := make(pq.Int32Array, len(s))
	for i, v := range s {
		tmp[i] = int32(v)
	}
	return tmp.Value()
}

func (s *Montant) Scan(src interface{}) error {
	bs, ok := src.([]byte)
	if !ok {
		return fmt.Errorf("unsupported type %T", src)
	}
	fields := strings.Split(string(bs[1:len(bs)-1]), ",")
	if len(fields) != 2 {
		return fmt.Errorf("unsupported number of fields %d", len(fields))
	}

	valCent, err := strconv.Atoi(fields[0])
	if err != nil {
		return err
	}
	s.Cent = int(valCent)

	valCurrency, err := strconv.Atoi(fields[1])
	if err != nil {
		return err
	}
	s.Currency = Currency(valCurrency)

	return nil
}
func (s Montant) Value() (driver.Value, error) {
	bs := fmt.Appendf(nil, "(%d, %d)", s.Cent, s.Currency)
	return driver.Value(bs), nil
}

func IdCampArrayToPQ(ids []IdCamp) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdCampArray scans the result of a query returning a
// list of ID's.
func ScanIdCampArray(rs *sql.Rows) ([]IdCamp, error) {
	defer rs.Close()
	ints := make([]IdCamp, 0, 16)
	var err error
	for rs.Next() {
		var s IdCamp
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdCampSet map[IdCamp]bool

func NewIdCampSetFrom(ids []IdCamp) IdCampSet {
	out := make(IdCampSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdCampSet) Add(id IdCamp) { s[id] = true }

func (s IdCampSet) Has(id IdCamp) bool { return s[id] }

func (s IdCampSet) Keys() []IdCamp {
	out := make([]IdCamp, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdEquipierArrayToPQ(ids []IdEquipier) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdEquipierArray scans the result of a query returning a
// list of ID's.
func ScanIdEquipierArray(rs *sql.Rows) ([]IdEquipier, error) {
	defer rs.Close()
	ints := make([]IdEquipier, 0, 16)
	var err error
	for rs.Next() {
		var s IdEquipier
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdEquipierSet map[IdEquipier]bool

func NewIdEquipierSetFrom(ids []IdEquipier) IdEquipierSet {
	out := make(IdEquipierSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdEquipierSet) Add(id IdEquipier) { s[id] = true }

func (s IdEquipierSet) Has(id IdEquipier) bool { return s[id] }

func (s IdEquipierSet) Keys() []IdEquipier {
	out := make([]IdEquipier, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdImagelettreArrayToPQ(ids []IdImagelettre) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdImagelettreArray scans the result of a query returning a
// list of ID's.
func ScanIdImagelettreArray(rs *sql.Rows) ([]IdImagelettre, error) {
	defer rs.Close()
	ints := make([]IdImagelettre, 0, 16)
	var err error
	for rs.Next() {
		var s IdImagelettre
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdImagelettreSet map[IdImagelettre]bool

func NewIdImagelettreSetFrom(ids []IdImagelettre) IdImagelettreSet {
	out := make(IdImagelettreSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdImagelettreSet) Add(id IdImagelettre) { s[id] = true }

func (s IdImagelettreSet) Has(id IdImagelettre) bool { return s[id] }

func (s IdImagelettreSet) Keys() []IdImagelettre {
	out := make([]IdImagelettre, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *OptionnalPlage) Scan(src interface{}) error  { return loadJSON(s, src) }
func (s OptionnalPlage) Value() (driver.Value, error) { return dumpJSON(s) }
