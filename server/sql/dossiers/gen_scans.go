package dossiers

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"registro/sql/camps"
	"registro/sql/personnes"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneAide(row scanner) (Aide, error) {
	var item Aide
	err := row.Scan(
		&item.Id,
		&item.IdStructureaide,
		&item.IdParticipant,
		&item.Valide,
		&item.Valeur,
		&item.ParJour,
		&item.NbJoursMax,
	)
	return item, err
}

func ScanAide(row *sql.Row) (Aide, error) { return scanOneAide(row) }

// SelectAll returns all the items in the aides table.
func SelectAllAides(db DB) (Aides, error) {
	rows, err := db.Query("SELECT * FROM aides")
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

// SelectAide returns the entry matching 'id'.
func SelectAide(tx DB, id IdAide) (Aide, error) {
	row := tx.QueryRow("SELECT * FROM aides WHERE id = $1", id)
	return ScanAide(row)
}

// SelectAides returns the entry matching the given 'ids'.
func SelectAides(tx DB, ids ...IdAide) (Aides, error) {
	rows, err := tx.Query("SELECT * FROM aides WHERE id = ANY($1)", IdAideArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

type Aides map[IdAide]Aide

func (m Aides) IDs() []IdAide {
	out := make([]IdAide, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanAides(rs *sql.Rows) (Aides, error) {
	var (
		s   Aide
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Aides, 16)
	for rs.Next() {
		s, err = scanOneAide(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Aide in the database and returns the item with id filled.
func (item Aide) Insert(tx DB) (out Aide, err error) {
	row := tx.QueryRow(`INSERT INTO aides (
		idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax
		) VALUES (
		$1, $2, $3, $4, $5, $6
		) RETURNING *;
		`, item.IdStructureaide, item.IdParticipant, item.Valide, item.Valeur, item.ParJour, item.NbJoursMax)
	return ScanAide(row)
}

// Update Aide in the database and returns the new version.
func (item Aide) Update(tx DB) (out Aide, err error) {
	row := tx.QueryRow(`UPDATE aides SET (
		idstructureaide, idparticipant, valide, valeur, parjour, nbjoursmax
		) = (
		$1, $2, $3, $4, $5, $6
		) WHERE id = $7 RETURNING *;
		`, item.IdStructureaide, item.IdParticipant, item.Valide, item.Valeur, item.ParJour, item.NbJoursMax, item.Id)
	return ScanAide(row)
}

// Deletes the Aide and returns the item
func DeleteAideById(tx DB, id IdAide) (Aide, error) {
	row := tx.QueryRow("DELETE FROM aides WHERE id = $1 RETURNING *;", id)
	return ScanAide(row)
}

// Deletes the Aide in the database and returns the ids.
func DeleteAidesByIDs(tx DB, ids ...IdAide) ([]IdAide, error) {
	rows, err := tx.Query("DELETE FROM aides WHERE id = ANY($1) RETURNING id", IdAideArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdAideArray(rows)
}

// ByIdStructureaide returns a map with 'IdStructureaide' as keys.
func (items Aides) ByIdStructureaide() map[IdStructureaide]Aides {
	out := make(map[IdStructureaide]Aides)
	for _, target := range items {
		dict := out[target.IdStructureaide]
		if dict == nil {
			dict = make(Aides)
		}
		dict[target.Id] = target
		out[target.IdStructureaide] = dict
	}
	return out
}

// IdStructureaides returns the list of ids of IdStructureaide
// contained in this table.
// They are not garanteed to be distinct.
func (items Aides) IdStructureaides() []IdStructureaide {
	out := make([]IdStructureaide, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdStructureaide)
	}
	return out
}

func SelectAidesByIdStructureaides(tx DB, idStructureaides_ ...IdStructureaide) (Aides, error) {
	rows, err := tx.Query("SELECT * FROM aides WHERE idstructureaide = ANY($1)", IdStructureaideArrayToPQ(idStructureaides_))
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

func DeleteAidesByIdStructureaides(tx DB, idStructureaides_ ...IdStructureaide) ([]IdAide, error) {
	rows, err := tx.Query("DELETE FROM aides WHERE idstructureaide = ANY($1) RETURNING id", IdStructureaideArrayToPQ(idStructureaides_))
	if err != nil {
		return nil, err
	}
	return ScanIdAideArray(rows)
}

// ByIdParticipant returns a map with 'IdParticipant' as keys.
func (items Aides) ByIdParticipant() map[IdParticipant]Aides {
	out := make(map[IdParticipant]Aides)
	for _, target := range items {
		dict := out[target.IdParticipant]
		if dict == nil {
			dict = make(Aides)
		}
		dict[target.Id] = target
		out[target.IdParticipant] = dict
	}
	return out
}

// IdParticipants returns the list of ids of IdParticipant
// contained in this table.
// They are not garanteed to be distinct.
func (items Aides) IdParticipants() []IdParticipant {
	out := make([]IdParticipant, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdParticipant)
	}
	return out
}

func SelectAidesByIdParticipants(tx DB, idParticipants_ ...IdParticipant) (Aides, error) {
	rows, err := tx.Query("SELECT * FROM aides WHERE idparticipant = ANY($1)", IdParticipantArrayToPQ(idParticipants_))
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

func DeleteAidesByIdParticipants(tx DB, idParticipants_ ...IdParticipant) ([]IdAide, error) {
	rows, err := tx.Query("DELETE FROM aides WHERE idparticipant = ANY($1) RETURNING id", IdParticipantArrayToPQ(idParticipants_))
	if err != nil {
		return nil, err
	}
	return ScanIdAideArray(rows)
}

func scanOneDossier(row scanner) (Dossier, error) {
	var item Dossier
	err := row.Scan(
		&item.Id,
		&item.IdPersonne,
		&item.CopiesMails,
		&item.LastConnection,
		&item.IsValidated,
		&item.PartageAdressesOK,
	)
	return item, err
}

func ScanDossier(row *sql.Row) (Dossier, error) { return scanOneDossier(row) }

// SelectAll returns all the items in the dossiers table.
func SelectAllDossiers(db DB) (Dossiers, error) {
	rows, err := db.Query("SELECT * FROM dossiers")
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

// SelectDossier returns the entry matching 'id'.
func SelectDossier(tx DB, id IdDossier) (Dossier, error) {
	row := tx.QueryRow("SELECT * FROM dossiers WHERE id = $1", id)
	return ScanDossier(row)
}

// SelectDossiers returns the entry matching the given 'ids'.
func SelectDossiers(tx DB, ids ...IdDossier) (Dossiers, error) {
	rows, err := tx.Query("SELECT * FROM dossiers WHERE id = ANY($1)", IdDossierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

type Dossiers map[IdDossier]Dossier

func (m Dossiers) IDs() []IdDossier {
	out := make([]IdDossier, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanDossiers(rs *sql.Rows) (Dossiers, error) {
	var (
		s   Dossier
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Dossiers, 16)
	for rs.Next() {
		s, err = scanOneDossier(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Dossier in the database and returns the item with id filled.
func (item Dossier) Insert(tx DB) (out Dossier, err error) {
	row := tx.QueryRow(`INSERT INTO dossiers (
		idpersonne, copiesmails, lastconnection, isvalidated, partageadressesok
		) VALUES (
		$1, $2, $3, $4, $5
		) RETURNING *;
		`, item.IdPersonne, item.CopiesMails, item.LastConnection, item.IsValidated, item.PartageAdressesOK)
	return ScanDossier(row)
}

// Update Dossier in the database and returns the new version.
func (item Dossier) Update(tx DB) (out Dossier, err error) {
	row := tx.QueryRow(`UPDATE dossiers SET (
		idpersonne, copiesmails, lastconnection, isvalidated, partageadressesok
		) = (
		$1, $2, $3, $4, $5
		) WHERE id = $6 RETURNING *;
		`, item.IdPersonne, item.CopiesMails, item.LastConnection, item.IsValidated, item.PartageAdressesOK, item.Id)
	return ScanDossier(row)
}

// Deletes the Dossier and returns the item
func DeleteDossierById(tx DB, id IdDossier) (Dossier, error) {
	row := tx.QueryRow("DELETE FROM dossiers WHERE id = $1 RETURNING *;", id)
	return ScanDossier(row)
}

// Deletes the Dossier in the database and returns the ids.
func DeleteDossiersByIDs(tx DB, ids ...IdDossier) ([]IdDossier, error) {
	rows, err := tx.Query("DELETE FROM dossiers WHERE id = ANY($1) RETURNING id", IdDossierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdDossierArray(rows)
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items Dossiers) ByIdPersonne() map[personnes.IdPersonne]Dossiers {
	out := make(map[personnes.IdPersonne]Dossiers)
	for _, target := range items {
		dict := out[target.IdPersonne]
		if dict == nil {
			dict = make(Dossiers)
		}
		dict[target.Id] = target
		out[target.IdPersonne] = dict
	}
	return out
}

// IdPersonnes returns the list of ids of IdPersonne
// contained in this table.
// They are not garanteed to be distinct.
func (items Dossiers) IdPersonnes() []personnes.IdPersonne {
	out := make([]personnes.IdPersonne, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdPersonne)
	}
	return out
}

func SelectDossiersByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) (Dossiers, error) {
	rows, err := tx.Query("SELECT * FROM dossiers WHERE idpersonne = ANY($1)", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

func DeleteDossiersByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) ([]IdDossier, error) {
	rows, err := tx.Query("DELETE FROM dossiers WHERE idpersonne = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanIdDossierArray(rows)
}

func scanOnePaiement(row scanner) (Paiement, error) {
	var item Paiement
	err := row.Scan(
		&item.Id,
		&item.IdDossier,
		&item.IsAcompte,
		&item.IsRemboursement,
		&item.Montant,
		&item.Payeur,
		&item.Mode,
		&item.Date,
		&item.Label,
		&item.Details,
	)
	return item, err
}

func ScanPaiement(row *sql.Row) (Paiement, error) { return scanOnePaiement(row) }

// SelectAll returns all the items in the paiements table.
func SelectAllPaiements(db DB) (Paiements, error) {
	rows, err := db.Query("SELECT * FROM paiements")
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

// SelectPaiement returns the entry matching 'id'.
func SelectPaiement(tx DB, id IdPaiement) (Paiement, error) {
	row := tx.QueryRow("SELECT * FROM paiements WHERE id = $1", id)
	return ScanPaiement(row)
}

// SelectPaiements returns the entry matching the given 'ids'.
func SelectPaiements(tx DB, ids ...IdPaiement) (Paiements, error) {
	rows, err := tx.Query("SELECT * FROM paiements WHERE id = ANY($1)", IdPaiementArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

type Paiements map[IdPaiement]Paiement

func (m Paiements) IDs() []IdPaiement {
	out := make([]IdPaiement, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanPaiements(rs *sql.Rows) (Paiements, error) {
	var (
		s   Paiement
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Paiements, 16)
	for rs.Next() {
		s, err = scanOnePaiement(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Paiement in the database and returns the item with id filled.
func (item Paiement) Insert(tx DB) (out Paiement, err error) {
	row := tx.QueryRow(`INSERT INTO paiements (
		iddossier, isacompte, isremboursement, montant, payeur, mode, date, label, details
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
		) RETURNING *;
		`, item.IdDossier, item.IsAcompte, item.IsRemboursement, item.Montant, item.Payeur, item.Mode, item.Date, item.Label, item.Details)
	return ScanPaiement(row)
}

// Update Paiement in the database and returns the new version.
func (item Paiement) Update(tx DB) (out Paiement, err error) {
	row := tx.QueryRow(`UPDATE paiements SET (
		iddossier, isacompte, isremboursement, montant, payeur, mode, date, label, details
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
		) WHERE id = $10 RETURNING *;
		`, item.IdDossier, item.IsAcompte, item.IsRemboursement, item.Montant, item.Payeur, item.Mode, item.Date, item.Label, item.Details, item.Id)
	return ScanPaiement(row)
}

// Deletes the Paiement and returns the item
func DeletePaiementById(tx DB, id IdPaiement) (Paiement, error) {
	row := tx.QueryRow("DELETE FROM paiements WHERE id = $1 RETURNING *;", id)
	return ScanPaiement(row)
}

// Deletes the Paiement in the database and returns the ids.
func DeletePaiementsByIDs(tx DB, ids ...IdPaiement) ([]IdPaiement, error) {
	rows, err := tx.Query("DELETE FROM paiements WHERE id = ANY($1) RETURNING id", IdPaiementArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdPaiementArray(rows)
}

// ByIdDossier returns a map with 'IdDossier' as keys.
func (items Paiements) ByIdDossier() map[IdDossier]Paiements {
	out := make(map[IdDossier]Paiements)
	for _, target := range items {
		dict := out[target.IdDossier]
		if dict == nil {
			dict = make(Paiements)
		}
		dict[target.Id] = target
		out[target.IdDossier] = dict
	}
	return out
}

// IdDossiers returns the list of ids of IdDossier
// contained in this table.
// They are not garanteed to be distinct.
func (items Paiements) IdDossiers() []IdDossier {
	out := make([]IdDossier, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdDossier)
	}
	return out
}

func SelectPaiementsByIdDossiers(tx DB, idDossiers_ ...IdDossier) (Paiements, error) {
	rows, err := tx.Query("SELECT * FROM paiements WHERE iddossier = ANY($1)", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

func DeletePaiementsByIdDossiers(tx DB, idDossiers_ ...IdDossier) ([]IdPaiement, error) {
	rows, err := tx.Query("DELETE FROM paiements WHERE iddossier = ANY($1) RETURNING id", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanIdPaiementArray(rows)
}

func scanOneParticipant(row scanner) (Participant, error) {
	var item Participant
	err := row.Scan(
		&item.Id,
		&item.IdCamp,
		&item.IdPersonne,
		&item.IdDossier,
		&item.ListeAttente,
		&item.Remises,
		&item.QuotientFamilial,
		&item.Details,
		&item.Bus,
	)
	return item, err
}

func ScanParticipant(row *sql.Row) (Participant, error) { return scanOneParticipant(row) }

// SelectAll returns all the items in the participants table.
func SelectAllParticipants(db DB) (Participants, error) {
	rows, err := db.Query("SELECT * FROM participants")
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

// SelectParticipant returns the entry matching 'id'.
func SelectParticipant(tx DB, id IdParticipant) (Participant, error) {
	row := tx.QueryRow("SELECT * FROM participants WHERE id = $1", id)
	return ScanParticipant(row)
}

// SelectParticipants returns the entry matching the given 'ids'.
func SelectParticipants(tx DB, ids ...IdParticipant) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE id = ANY($1)", IdParticipantArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

type Participants map[IdParticipant]Participant

func (m Participants) IDs() []IdParticipant {
	out := make([]IdParticipant, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanParticipants(rs *sql.Rows) (Participants, error) {
	var (
		s   Participant
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Participants, 16)
	for rs.Next() {
		s, err = scanOneParticipant(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Participant in the database and returns the item with id filled.
func (item Participant) Insert(tx DB) (out Participant, err error) {
	row := tx.QueryRow(`INSERT INTO participants (
		idcamp, idpersonne, iddossier, listeattente, remises, quotientfamilial, details, bus
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8
		) RETURNING *;
		`, item.IdCamp, item.IdPersonne, item.IdDossier, item.ListeAttente, item.Remises, item.QuotientFamilial, item.Details, item.Bus)
	return ScanParticipant(row)
}

// Update Participant in the database and returns the new version.
func (item Participant) Update(tx DB) (out Participant, err error) {
	row := tx.QueryRow(`UPDATE participants SET (
		idcamp, idpersonne, iddossier, listeattente, remises, quotientfamilial, details, bus
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8
		) WHERE id = $9 RETURNING *;
		`, item.IdCamp, item.IdPersonne, item.IdDossier, item.ListeAttente, item.Remises, item.QuotientFamilial, item.Details, item.Bus, item.Id)
	return ScanParticipant(row)
}

// Deletes the Participant and returns the item
func DeleteParticipantById(tx DB, id IdParticipant) (Participant, error) {
	row := tx.QueryRow("DELETE FROM participants WHERE id = $1 RETURNING *;", id)
	return ScanParticipant(row)
}

// Deletes the Participant in the database and returns the ids.
func DeleteParticipantsByIDs(tx DB, ids ...IdParticipant) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE id = ANY($1) RETURNING id", IdParticipantArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Participants) ByIdCamp() map[camps.IdCamp]Participants {
	out := make(map[camps.IdCamp]Participants)
	for _, target := range items {
		dict := out[target.IdCamp]
		if dict == nil {
			dict = make(Participants)
		}
		dict[target.Id] = target
		out[target.IdCamp] = dict
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this table.
// They are not garanteed to be distinct.
func (items Participants) IdCamps() []camps.IdCamp {
	out := make([]camps.IdCamp, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdCamp)
	}
	return out
}

func SelectParticipantsByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE idcamp = ANY($1)", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdCamps(tx DB, idCamps_ ...camps.IdCamp) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE idcamp = ANY($1) RETURNING id", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items Participants) ByIdPersonne() map[personnes.IdPersonne]Participants {
	out := make(map[personnes.IdPersonne]Participants)
	for _, target := range items {
		dict := out[target.IdPersonne]
		if dict == nil {
			dict = make(Participants)
		}
		dict[target.Id] = target
		out[target.IdPersonne] = dict
	}
	return out
}

// IdPersonnes returns the list of ids of IdPersonne
// contained in this table.
// They are not garanteed to be distinct.
func (items Participants) IdPersonnes() []personnes.IdPersonne {
	out := make([]personnes.IdPersonne, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdPersonne)
	}
	return out
}

func SelectParticipantsByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE idpersonne = ANY($1)", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdPersonnes(tx DB, idPersonnes_ ...personnes.IdPersonne) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE idpersonne = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(idPersonnes_))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

// ByIdDossier returns a map with 'IdDossier' as keys.
func (items Participants) ByIdDossier() map[IdDossier]Participants {
	out := make(map[IdDossier]Participants)
	for _, target := range items {
		dict := out[target.IdDossier]
		if dict == nil {
			dict = make(Participants)
		}
		dict[target.Id] = target
		out[target.IdDossier] = dict
	}
	return out
}

// IdDossiers returns the list of ids of IdDossier
// contained in this table.
// They are not garanteed to be distinct.
func (items Participants) IdDossiers() []IdDossier {
	out := make([]IdDossier, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdDossier)
	}
	return out
}

func SelectParticipantsByIdDossiers(tx DB, idDossiers_ ...IdDossier) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE iddossier = ANY($1)", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdDossiers(tx DB, idDossiers_ ...IdDossier) ([]IdParticipant, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE iddossier = ANY($1) RETURNING id", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanIdParticipantArray(rows)
}

func scanOneSondage(row scanner) (Sondage, error) {
	var item Sondage
	err := row.Scan(
		&item.IdSondage,
		&item.IdCamp,
		&item.IdDossier,
		&item.Modified,
		&item.InfosAvantSejour,
		&item.InfosPendantSejour,
		&item.Hebergement,
		&item.Activites,
		&item.Theme,
		&item.Nourriture,
		&item.Hygiene,
		&item.Ambiance,
		&item.Ressenti,
		&item.MessageEnfant,
		&item.MessageResponsable,
	)
	return item, err
}

func ScanSondage(row *sql.Row) (Sondage, error) { return scanOneSondage(row) }

// SelectAll returns all the items in the sondages table.
func SelectAllSondages(db DB) (Sondages, error) {
	rows, err := db.Query("SELECT * FROM sondages")
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

type Sondages []Sondage

func ScanSondages(rs *sql.Rows) (Sondages, error) {
	var (
		item Sondage
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Sondages, 0, 16)
	for rs.Next() {
		item, err = scanOneSondage(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func InsertSondage(db DB, item Sondage) error {
	_, err := db.Exec(`INSERT INTO sondages (
			idsondage, idcamp, iddossier, modified, infosavantsejour, infospendantsejour, hebergement, activites, theme, nourriture, hygiene, ambiance, ressenti, messageenfant, messageresponsable
			) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
			);
			`, item.IdSondage, item.IdCamp, item.IdDossier, item.Modified, item.InfosAvantSejour, item.InfosPendantSejour, item.Hebergement, item.Activites, item.Theme, item.Nourriture, item.Hygiene, item.Ambiance, item.Ressenti, item.MessageEnfant, item.MessageResponsable)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links Sondage in the database.
// It is a no-op if 'items' is empty.
func InsertManySondages(tx *sql.Tx, items ...Sondage) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("sondages",
		"idsondage",
		"idcamp",
		"iddossier",
		"modified",
		"infosavantsejour",
		"infospendantsejour",
		"hebergement",
		"activites",
		"theme",
		"nourriture",
		"hygiene",
		"ambiance",
		"ressenti",
		"messageenfant",
		"messageresponsable",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdSondage, item.IdCamp, item.IdDossier, item.Modified, item.InfosAvantSejour, item.InfosPendantSejour, item.Hebergement, item.Activites, item.Theme, item.Nourriture, item.Hygiene, item.Ambiance, item.Ressenti, item.MessageEnfant, item.MessageResponsable)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Sondage from the database.
// Only the foreign keys IdCamp, IdDossier fields are used in 'item'.
func (item Sondage) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM sondages WHERE IdCamp = $1 AND IdDossier = $2;`, item.IdCamp, item.IdDossier)
	return err
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Sondages) ByIdCamp() map[camps.IdCamp]Sondages {
	out := make(map[camps.IdCamp]Sondages)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this link table.
// They are not garanteed to be distinct.
func (items Sondages) IdCamps() []camps.IdCamp {
	out := make([]camps.IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

func SelectSondagesByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (Sondages, error) {
	rows, err := tx.Query("SELECT * FROM sondages WHERE idcamp = ANY($1)", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

func DeleteSondagesByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (Sondages, error) {
	rows, err := tx.Query("DELETE FROM sondages WHERE idcamp = ANY($1) RETURNING *", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

// ByIdDossier returns a map with 'IdDossier' as keys.
func (items Sondages) ByIdDossier() map[IdDossier]Sondages {
	out := make(map[IdDossier]Sondages)
	for _, target := range items {
		out[target.IdDossier] = append(out[target.IdDossier], target)
	}
	return out
}

// IdDossiers returns the list of ids of IdDossier
// contained in this link table.
// They are not garanteed to be distinct.
func (items Sondages) IdDossiers() []IdDossier {
	out := make([]IdDossier, len(items))
	for index, target := range items {
		out[index] = target.IdDossier
	}
	return out
}

func SelectSondagesByIdDossiers(tx DB, idDossiers_ ...IdDossier) (Sondages, error) {
	rows, err := tx.Query("SELECT * FROM sondages WHERE iddossier = ANY($1)", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

func DeleteSondagesByIdDossiers(tx DB, idDossiers_ ...IdDossier) (Sondages, error) {
	rows, err := tx.Query("DELETE FROM sondages WHERE iddossier = ANY($1) RETURNING *", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

// SelectSondageByIdCampAndIdDossier return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectSondageByIdCampAndIdDossier(tx DB, idCamp camps.IdCamp, idDossier IdDossier) (item Sondage, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM sondages WHERE IdCamp = $1 AND IdDossier = $2", idCamp, idDossier)
	item, err = ScanSondage(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneStructureaide(row scanner) (Structureaide, error) {
	var item Structureaide
	err := row.Scan(
		&item.Id,
		&item.Nom,
		&item.Immatriculation,
		&item.Adresse,
		&item.CodePostal,
		&item.Ville,
		&item.Telephone,
		&item.Info,
	)
	return item, err
}

func ScanStructureaide(row *sql.Row) (Structureaide, error) { return scanOneStructureaide(row) }

// SelectAll returns all the items in the structureaides table.
func SelectAllStructureaides(db DB) (Structureaides, error) {
	rows, err := db.Query("SELECT * FROM structureaides")
	if err != nil {
		return nil, err
	}
	return ScanStructureaides(rows)
}

// SelectStructureaide returns the entry matching 'id'.
func SelectStructureaide(tx DB, id int64) (Structureaide, error) {
	row := tx.QueryRow("SELECT * FROM structureaides WHERE id = $1", id)
	return ScanStructureaide(row)
}

// SelectStructureaides returns the entry matching the given 'ids'.
func SelectStructureaides(tx DB, ids ...int64) (Structureaides, error) {
	rows, err := tx.Query("SELECT * FROM structureaides WHERE id = ANY($1)", int64ArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanStructureaides(rows)
}

type Structureaides map[int64]Structureaide

func (m Structureaides) IDs() []int64 {
	out := make([]int64, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanStructureaides(rs *sql.Rows) (Structureaides, error) {
	var (
		s   Structureaide
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Structureaides, 16)
	for rs.Next() {
		s, err = scanOneStructureaide(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Structureaide in the database and returns the item with id filled.
func (item Structureaide) Insert(tx DB) (out Structureaide, err error) {
	row := tx.QueryRow(`INSERT INTO structureaides (
		nom, immatriculation, adresse, codepostal, ville, telephone, info
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7
		) RETURNING *;
		`, item.Nom, item.Immatriculation, item.Adresse, item.CodePostal, item.Ville, item.Telephone, item.Info)
	return ScanStructureaide(row)
}

// Update Structureaide in the database and returns the new version.
func (item Structureaide) Update(tx DB) (out Structureaide, err error) {
	row := tx.QueryRow(`UPDATE structureaides SET (
		nom, immatriculation, adresse, codepostal, ville, telephone, info
		) = (
		$1, $2, $3, $4, $5, $6, $7
		) WHERE id = $8 RETURNING *;
		`, item.Nom, item.Immatriculation, item.Adresse, item.CodePostal, item.Ville, item.Telephone, item.Info, item.Id)
	return ScanStructureaide(row)
}

// Deletes the Structureaide and returns the item
func DeleteStructureaideById(tx DB, id int64) (Structureaide, error) {
	row := tx.QueryRow("DELETE FROM structureaides WHERE id = $1 RETURNING *;", id)
	return ScanStructureaide(row)
}

// Deletes the Structureaide in the database and returns the ids.
func DeleteStructureaidesByIDs(tx DB, ids ...int64) ([]int64, error) {
	rows, err := tx.Query("DELETE FROM structureaides WHERE id = ANY($1) RETURNING id", int64ArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return Scanint64Array(rows)
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func IdAideArrayToPQ(ids []IdAide) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdAideArray scans the result of a query returning a
// list of ID's.
func ScanIdAideArray(rs *sql.Rows) ([]IdAide, error) {
	defer rs.Close()
	ints := make([]IdAide, 0, 16)
	var err error
	for rs.Next() {
		var s IdAide
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdAideSet map[IdAide]bool

func NewIdAideSetFrom(ids []IdAide) IdAideSet {
	out := make(IdAideSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdAideSet) Add(id IdAide) { s[id] = true }

func (s IdAideSet) Has(id IdAide) bool { return s[id] }

func (s IdAideSet) Keys() []IdAide {
	out := make([]IdAide, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdDossierArrayToPQ(ids []IdDossier) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdDossierArray scans the result of a query returning a
// list of ID's.
func ScanIdDossierArray(rs *sql.Rows) ([]IdDossier, error) {
	defer rs.Close()
	ints := make([]IdDossier, 0, 16)
	var err error
	for rs.Next() {
		var s IdDossier
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdDossierSet map[IdDossier]bool

func NewIdDossierSetFrom(ids []IdDossier) IdDossierSet {
	out := make(IdDossierSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdDossierSet) Add(id IdDossier) { s[id] = true }

func (s IdDossierSet) Has(id IdDossier) bool { return s[id] }

func (s IdDossierSet) Keys() []IdDossier {
	out := make([]IdDossier, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdPaiementArrayToPQ(ids []IdPaiement) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdPaiementArray scans the result of a query returning a
// list of ID's.
func ScanIdPaiementArray(rs *sql.Rows) ([]IdPaiement, error) {
	defer rs.Close()
	ints := make([]IdPaiement, 0, 16)
	var err error
	for rs.Next() {
		var s IdPaiement
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdPaiementSet map[IdPaiement]bool

func NewIdPaiementSetFrom(ids []IdPaiement) IdPaiementSet {
	out := make(IdPaiementSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdPaiementSet) Add(id IdPaiement) { s[id] = true }

func (s IdPaiementSet) Has(id IdPaiement) bool { return s[id] }

func (s IdPaiementSet) Keys() []IdPaiement {
	out := make([]IdPaiement, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdParticipantArrayToPQ(ids []IdParticipant) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdParticipantArray scans the result of a query returning a
// list of ID's.
func ScanIdParticipantArray(rs *sql.Rows) ([]IdParticipant, error) {
	defer rs.Close()
	ints := make([]IdParticipant, 0, 16)
	var err error
	for rs.Next() {
		var s IdParticipant
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdParticipantSet map[IdParticipant]bool

func NewIdParticipantSetFrom(ids []IdParticipant) IdParticipantSet {
	out := make(IdParticipantSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdParticipantSet) Add(id IdParticipant) { s[id] = true }

func (s IdParticipantSet) Has(id IdParticipant) bool { return s[id] }

func (s IdParticipantSet) Keys() []IdParticipant {
	out := make([]IdParticipant, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdStructureaideArrayToPQ(ids []IdStructureaide) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdStructureaideArray scans the result of a query returning a
// list of ID's.
func ScanIdStructureaideArray(rs *sql.Rows) ([]IdStructureaide, error) {
	defer rs.Close()
	ints := make([]IdStructureaide, 0, 16)
	var err error
	for rs.Next() {
		var s IdStructureaide
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdStructureaideSet map[IdStructureaide]bool

func NewIdStructureaideSetFrom(ids []IdStructureaide) IdStructureaideSet {
	out := make(IdStructureaideSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdStructureaideSet) Add(id IdStructureaide) { s[id] = true }

func (s IdStructureaideSet) Has(id IdStructureaide) bool { return s[id] }

func (s IdStructureaideSet) Keys() []IdStructureaide {
	out := make([]IdStructureaide, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func int64ArrayToPQ(ids []int64) pq.Int64Array { return ids }

// Scanint64Array scans the result of a query returning a
// list of ID's.
func Scanint64Array(rs *sql.Rows) ([]int64, error) {
	defer rs.Close()
	ints := make([]int64, 0, 16)
	var err error
	for rs.Next() {
		var s int64
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type int64Set map[int64]bool

func Newint64SetFrom(ids []int64) int64Set {
	out := make(int64Set, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s int64Set) Add(id int64) { s[id] = true }

func (s int64Set) Has(id int64) bool { return s[id] }

func (s int64Set) Keys() []int64 {
	out := make([]int64, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *Remises) Scan(src interface{}) error  { return loadJSON(s, src) }
func (s Remises) Value() (driver.Value, error) { return dumpJSON(s) }
