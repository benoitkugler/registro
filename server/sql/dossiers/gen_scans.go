package dossiers

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"registro/sql/personnes"
	"strconv"
	"strings"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneDossier(row scanner) (Dossier, error) {
	var item Dossier
	err := row.Scan(
		&item.Id,
		&item.IdResponsable,
		&item.CopiesMails,
		&item.LastConnection,
		&item.IsValidated,
		&item.PartageAdressesOK,
	)
	return item, err
}

func ScanDossier(row *sql.Row) (Dossier, error) { return scanOneDossier(row) }

// SelectAll returns all the items in the dossiers table.
func SelectAllDossiers(db DB) (Dossiers, error) {
	rows, err := db.Query("SELECT * FROM dossiers")
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

// SelectDossier returns the entry matching 'id'.
func SelectDossier(tx DB, id IdDossier) (Dossier, error) {
	row := tx.QueryRow("SELECT * FROM dossiers WHERE id = $1", id)
	return ScanDossier(row)
}

// SelectDossiers returns the entry matching the given 'ids'.
func SelectDossiers(tx DB, ids ...IdDossier) (Dossiers, error) {
	rows, err := tx.Query("SELECT * FROM dossiers WHERE id = ANY($1)", IdDossierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

type Dossiers map[IdDossier]Dossier

func (m Dossiers) IDs() []IdDossier {
	out := make([]IdDossier, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanDossiers(rs *sql.Rows) (Dossiers, error) {
	var (
		s   Dossier
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Dossiers, 16)
	for rs.Next() {
		s, err = scanOneDossier(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Dossier in the database and returns the item with id filled.
func (item Dossier) Insert(tx DB) (out Dossier, err error) {
	row := tx.QueryRow(`INSERT INTO dossiers (
		idresponsable, copiesmails, lastconnection, isvalidated, partageadressesok
		) VALUES (
		$1, $2, $3, $4, $5
		) RETURNING *;
		`, item.IdResponsable, item.CopiesMails, item.LastConnection, item.IsValidated, item.PartageAdressesOK)
	return ScanDossier(row)
}

// Update Dossier in the database and returns the new version.
func (item Dossier) Update(tx DB) (out Dossier, err error) {
	row := tx.QueryRow(`UPDATE dossiers SET (
		idresponsable, copiesmails, lastconnection, isvalidated, partageadressesok
		) = (
		$1, $2, $3, $4, $5
		) WHERE id = $6 RETURNING *;
		`, item.IdResponsable, item.CopiesMails, item.LastConnection, item.IsValidated, item.PartageAdressesOK, item.Id)
	return ScanDossier(row)
}

// Deletes the Dossier and returns the item
func DeleteDossierById(tx DB, id IdDossier) (Dossier, error) {
	row := tx.QueryRow("DELETE FROM dossiers WHERE id = $1 RETURNING *;", id)
	return ScanDossier(row)
}

// Deletes the Dossier in the database and returns the ids.
func DeleteDossiersByIDs(tx DB, ids ...IdDossier) ([]IdDossier, error) {
	rows, err := tx.Query("DELETE FROM dossiers WHERE id = ANY($1) RETURNING id", IdDossierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdDossierArray(rows)
}

// ByIdResponsable returns a map with 'IdResponsable' as keys.
func (items Dossiers) ByIdResponsable() map[personnes.IdPersonne]Dossiers {
	out := make(map[personnes.IdPersonne]Dossiers)
	for _, target := range items {
		dict := out[target.IdResponsable]
		if dict == nil {
			dict = make(Dossiers)
		}
		dict[target.Id] = target
		out[target.IdResponsable] = dict
	}
	return out
}

// IdResponsables returns the list of ids of IdResponsable
// contained in this table.
// They are not garanteed to be distinct.
func (items Dossiers) IdResponsables() []personnes.IdPersonne {
	out := make([]personnes.IdPersonne, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdResponsable)
	}
	return out
}

func SelectDossiersByIdResponsables(tx DB, idResponsables_ ...personnes.IdPersonne) (Dossiers, error) {
	rows, err := tx.Query("SELECT * FROM dossiers WHERE idresponsable = ANY($1)", personnes.IdPersonneArrayToPQ(idResponsables_))
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

func DeleteDossiersByIdResponsables(tx DB, idResponsables_ ...personnes.IdPersonne) ([]IdDossier, error) {
	rows, err := tx.Query("DELETE FROM dossiers WHERE idresponsable = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(idResponsables_))
	if err != nil {
		return nil, err
	}
	return ScanIdDossierArray(rows)
}

func scanOnePaiement(row scanner) (Paiement, error) {
	var item Paiement
	err := row.Scan(
		&item.Id,
		&item.IdDossier,
		&item.IsAcompte,
		&item.IsRemboursement,
		&item.Montant,
		&item.Payeur,
		&item.Mode,
		&item.Date,
		&item.Label,
		&item.Details,
	)
	return item, err
}

func ScanPaiement(row *sql.Row) (Paiement, error) { return scanOnePaiement(row) }

// SelectAll returns all the items in the paiements table.
func SelectAllPaiements(db DB) (Paiements, error) {
	rows, err := db.Query("SELECT * FROM paiements")
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

// SelectPaiement returns the entry matching 'id'.
func SelectPaiement(tx DB, id IdPaiement) (Paiement, error) {
	row := tx.QueryRow("SELECT * FROM paiements WHERE id = $1", id)
	return ScanPaiement(row)
}

// SelectPaiements returns the entry matching the given 'ids'.
func SelectPaiements(tx DB, ids ...IdPaiement) (Paiements, error) {
	rows, err := tx.Query("SELECT * FROM paiements WHERE id = ANY($1)", IdPaiementArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

type Paiements map[IdPaiement]Paiement

func (m Paiements) IDs() []IdPaiement {
	out := make([]IdPaiement, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanPaiements(rs *sql.Rows) (Paiements, error) {
	var (
		s   Paiement
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Paiements, 16)
	for rs.Next() {
		s, err = scanOnePaiement(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Paiement in the database and returns the item with id filled.
func (item Paiement) Insert(tx DB) (out Paiement, err error) {
	row := tx.QueryRow(`INSERT INTO paiements (
		iddossier, isacompte, isremboursement, montant, payeur, mode, date, label, details
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
		) RETURNING *;
		`, item.IdDossier, item.IsAcompte, item.IsRemboursement, item.Montant, item.Payeur, item.Mode, item.Date, item.Label, item.Details)
	return ScanPaiement(row)
}

// Update Paiement in the database and returns the new version.
func (item Paiement) Update(tx DB) (out Paiement, err error) {
	row := tx.QueryRow(`UPDATE paiements SET (
		iddossier, isacompte, isremboursement, montant, payeur, mode, date, label, details
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
		) WHERE id = $10 RETURNING *;
		`, item.IdDossier, item.IsAcompte, item.IsRemboursement, item.Montant, item.Payeur, item.Mode, item.Date, item.Label, item.Details, item.Id)
	return ScanPaiement(row)
}

// Deletes the Paiement and returns the item
func DeletePaiementById(tx DB, id IdPaiement) (Paiement, error) {
	row := tx.QueryRow("DELETE FROM paiements WHERE id = $1 RETURNING *;", id)
	return ScanPaiement(row)
}

// Deletes the Paiement in the database and returns the ids.
func DeletePaiementsByIDs(tx DB, ids ...IdPaiement) ([]IdPaiement, error) {
	rows, err := tx.Query("DELETE FROM paiements WHERE id = ANY($1) RETURNING id", IdPaiementArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdPaiementArray(rows)
}

// ByIdDossier returns a map with 'IdDossier' as keys.
func (items Paiements) ByIdDossier() map[IdDossier]Paiements {
	out := make(map[IdDossier]Paiements)
	for _, target := range items {
		dict := out[target.IdDossier]
		if dict == nil {
			dict = make(Paiements)
		}
		dict[target.Id] = target
		out[target.IdDossier] = dict
	}
	return out
}

// IdDossiers returns the list of ids of IdDossier
// contained in this table.
// They are not garanteed to be distinct.
func (items Paiements) IdDossiers() []IdDossier {
	out := make([]IdDossier, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdDossier)
	}
	return out
}

func SelectPaiementsByIdDossiers(tx DB, idDossiers_ ...IdDossier) (Paiements, error) {
	rows, err := tx.Query("SELECT * FROM paiements WHERE iddossier = ANY($1)", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

func DeletePaiementsByIdDossiers(tx DB, idDossiers_ ...IdDossier) ([]IdPaiement, error) {
	rows, err := tx.Query("DELETE FROM paiements WHERE iddossier = ANY($1) RETURNING id", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanIdPaiementArray(rows)
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *Montant) Scan(src interface{}) error {
	bs, ok := src.([]byte)
	if !ok {
		return fmt.Errorf("unsupported type %T", src)
	}
	fields := strings.Split(string(bs[1:len(bs)-1]), ",")
	if len(fields) != 2 {
		return fmt.Errorf("unsupported number of fields %d", len(fields))
	}

	valCent, err := strconv.Atoi(fields[0])
	if err != nil {
		return err
	}
	s.Cent = int(valCent)

	valCurrency, err := strconv.Atoi(fields[1])
	if err != nil {
		return err
	}
	s.Currency = Currency(valCurrency)

	return nil
}
func (s Montant) Value() (driver.Value, error) {
	bs := fmt.Appendf(nil, "(%d, %d)", s.Cent, s.Currency)
	return driver.Value(bs), nil
}

func IdDossierArrayToPQ(ids []IdDossier) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdDossierArray scans the result of a query returning a
// list of ID's.
func ScanIdDossierArray(rs *sql.Rows) ([]IdDossier, error) {
	defer rs.Close()
	ints := make([]IdDossier, 0, 16)
	var err error
	for rs.Next() {
		var s IdDossier
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdDossierSet map[IdDossier]bool

func NewIdDossierSetFrom(ids []IdDossier) IdDossierSet {
	out := make(IdDossierSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdDossierSet) Add(id IdDossier) { s[id] = true }

func (s IdDossierSet) Has(id IdDossier) bool { return s[id] }

func (s IdDossierSet) Keys() []IdDossier {
	out := make([]IdDossier, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdPaiementArrayToPQ(ids []IdPaiement) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdPaiementArray scans the result of a query returning a
// list of ID's.
func ScanIdPaiementArray(rs *sql.Rows) ([]IdPaiement, error) {
	defer rs.Close()
	ints := make([]IdPaiement, 0, 16)
	var err error
	for rs.Next() {
		var s IdPaiement
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdPaiementSet map[IdPaiement]bool

func NewIdPaiementSetFrom(ids []IdPaiement) IdPaiementSet {
	out := make(IdPaiementSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdPaiementSet) Add(id IdPaiement) { s[id] = true }

func (s IdPaiementSet) Has(id IdPaiement) bool { return s[id] }

func (s IdPaiementSet) Keys() []IdPaiement {
	out := make([]IdPaiement, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}
