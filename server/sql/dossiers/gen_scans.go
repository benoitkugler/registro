package dossiers

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"registro/sql/personnes"
	"strconv"
	"strings"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...any) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...any) (sql.Result, error)
	Query(query string, args ...any) (*sql.Rows, error)
	QueryRow(query string, args ...any) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneDossier(row scanner) (Dossier, error) {
	var item Dossier
	err := row.Scan(
		&item.Id,
		&item.IdTaux,
		&item.IdResponsable,
		&item.CopiesMails,
		&item.PartageAdressesOK,
		&item.DemandeFondSoutien,
		&item.IsValidated,
		&item.MomentInscription,
		&item.LastLoadDocuments,
		&item.KeyV1,
	)
	return item, err
}

func ScanDossier(row *sql.Row) (Dossier, error) { return scanOneDossier(row) }

// SelectAll returns all the items in the dossiers table.
func SelectAllDossiers(db DB) (Dossiers, error) {
	rows, err := db.Query("SELECT id, idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1 FROM dossiers")
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

// SelectDossier returns the entry matching 'id'.
func SelectDossier(tx DB, id IdDossier) (Dossier, error) {
	row := tx.QueryRow("SELECT id, idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1 FROM dossiers WHERE id = $1", id)
	return ScanDossier(row)
}

// SelectDossiers returns the entry matching the given 'ids'.
func SelectDossiers(tx DB, ids ...IdDossier) (Dossiers, error) {
	rows, err := tx.Query("SELECT id, idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1 FROM dossiers WHERE id = ANY($1)", IdDossierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

type Dossiers map[IdDossier]Dossier

func (m Dossiers) IDs() []IdDossier {
	out := make([]IdDossier, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanDossiers(rs *sql.Rows) (Dossiers, error) {
	var (
		s   Dossier
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Dossiers, 16)
	for rs.Next() {
		s, err = scanOneDossier(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Dossier in the database and returns the item with id filled.
func (item Dossier) Insert(tx DB) (out Dossier, err error) {
	row := tx.QueryRow(`INSERT INTO dossiers (
		idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
		) RETURNING id, idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1;
		`, item.IdTaux, item.IdResponsable, item.CopiesMails, item.PartageAdressesOK, item.DemandeFondSoutien, item.IsValidated, item.MomentInscription, item.LastLoadDocuments, item.KeyV1)
	return ScanDossier(row)
}

// Update Dossier in the database and returns the new version.
func (item Dossier) Update(tx DB) (out Dossier, err error) {
	row := tx.QueryRow(`UPDATE dossiers SET (
		idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
		) WHERE id = $10 RETURNING id, idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1;
		`, item.IdTaux, item.IdResponsable, item.CopiesMails, item.PartageAdressesOK, item.DemandeFondSoutien, item.IsValidated, item.MomentInscription, item.LastLoadDocuments, item.KeyV1, item.Id)
	return ScanDossier(row)
}

// Deletes the Dossier and returns the item
func DeleteDossierById(tx DB, id IdDossier) (Dossier, error) {
	row := tx.QueryRow("DELETE FROM dossiers WHERE id = $1 RETURNING id, idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1;", id)
	return ScanDossier(row)
}

// Deletes the Dossier in the database and returns the ids.
func DeleteDossiersByIDs(tx DB, ids ...IdDossier) ([]IdDossier, error) {
	rows, err := tx.Query("DELETE FROM dossiers WHERE id = ANY($1) RETURNING id", IdDossierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdDossierArray(rows)
}

// ByIdTaux returns a map with 'IdTaux' as keys.
func (items Dossiers) ByIdTaux() map[IdTaux]Dossiers {
	out := make(map[IdTaux]Dossiers)
	for _, target := range items {
		dict := out[target.IdTaux]
		if dict == nil {
			dict = make(Dossiers)
		}
		dict[target.Id] = target
		out[target.IdTaux] = dict
	}
	return out
}

// IdTauxs returns the list of ids of IdTaux
// contained in this table.
// They are not garanteed to be distinct.
func (items Dossiers) IdTauxs() []IdTaux {
	out := make([]IdTaux, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTaux)
	}
	return out
}

func SelectDossiersByIdTauxs(tx DB, idTauxs_ ...IdTaux) (Dossiers, error) {
	rows, err := tx.Query("SELECT id, idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1 FROM dossiers WHERE idtaux = ANY($1)", IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

func DeleteDossiersByIdTauxs(tx DB, idTauxs_ ...IdTaux) ([]IdDossier, error) {
	rows, err := tx.Query("DELETE FROM dossiers WHERE idtaux = ANY($1) RETURNING id", IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanIdDossierArray(rows)
}

// ByIdResponsable returns a map with 'IdResponsable' as keys.
func (items Dossiers) ByIdResponsable() map[personnes.IdPersonne]Dossiers {
	out := make(map[personnes.IdPersonne]Dossiers)
	for _, target := range items {
		dict := out[target.IdResponsable]
		if dict == nil {
			dict = make(Dossiers)
		}
		dict[target.Id] = target
		out[target.IdResponsable] = dict
	}
	return out
}

// IdResponsables returns the list of ids of IdResponsable
// contained in this table.
// They are not garanteed to be distinct.
func (items Dossiers) IdResponsables() []personnes.IdPersonne {
	out := make([]personnes.IdPersonne, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdResponsable)
	}
	return out
}

func SelectDossiersByIdResponsables(tx DB, idResponsables_ ...personnes.IdPersonne) (Dossiers, error) {
	rows, err := tx.Query("SELECT id, idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1 FROM dossiers WHERE idresponsable = ANY($1)", personnes.IdPersonneArrayToPQ(idResponsables_))
	if err != nil {
		return nil, err
	}
	return ScanDossiers(rows)
}

func DeleteDossiersByIdResponsables(tx DB, idResponsables_ ...personnes.IdPersonne) ([]IdDossier, error) {
	rows, err := tx.Query("DELETE FROM dossiers WHERE idresponsable = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(idResponsables_))
	if err != nil {
		return nil, err
	}
	return ScanIdDossierArray(rows)
}

// SelectDossierByIdAndIdTaux return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectDossierByIdAndIdTaux(tx DB, id IdDossier, idTaux IdTaux) (item Dossier, found bool, err error) {
	row := tx.QueryRow("SELECT id, idtaux, idresponsable, copiesmails, partageadressesok, demandefondsoutien, isvalidated, momentinscription, lastloaddocuments, keyv1 FROM dossiers WHERE Id = $1 AND IdTaux = $2", id, idTaux)
	item, err = ScanDossier(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOnePaiement(row scanner) (Paiement, error) {
	var item Paiement
	err := row.Scan(
		&item.Id,
		&item.IdDossier,
		&item.IsRemboursement,
		&item.Montant,
		&item.Payeur,
		&item.Mode,
		&item.Time,
		&item.Label,
		&item.Details,
	)
	return item, err
}

func ScanPaiement(row *sql.Row) (Paiement, error) { return scanOnePaiement(row) }

// SelectAll returns all the items in the paiements table.
func SelectAllPaiements(db DB) (Paiements, error) {
	rows, err := db.Query("SELECT id, iddossier, isremboursement, montant, payeur, mode, time, label, details FROM paiements")
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

// SelectPaiement returns the entry matching 'id'.
func SelectPaiement(tx DB, id IdPaiement) (Paiement, error) {
	row := tx.QueryRow("SELECT id, iddossier, isremboursement, montant, payeur, mode, time, label, details FROM paiements WHERE id = $1", id)
	return ScanPaiement(row)
}

// SelectPaiements returns the entry matching the given 'ids'.
func SelectPaiements(tx DB, ids ...IdPaiement) (Paiements, error) {
	rows, err := tx.Query("SELECT id, iddossier, isremboursement, montant, payeur, mode, time, label, details FROM paiements WHERE id = ANY($1)", IdPaiementArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

type Paiements map[IdPaiement]Paiement

func (m Paiements) IDs() []IdPaiement {
	out := make([]IdPaiement, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanPaiements(rs *sql.Rows) (Paiements, error) {
	var (
		s   Paiement
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Paiements, 16)
	for rs.Next() {
		s, err = scanOnePaiement(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Paiement in the database and returns the item with id filled.
func (item Paiement) Insert(tx DB) (out Paiement, err error) {
	row := tx.QueryRow(`INSERT INTO paiements (
		iddossier, isremboursement, montant, payeur, mode, time, label, details
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8
		) RETURNING id, iddossier, isremboursement, montant, payeur, mode, time, label, details;
		`, item.IdDossier, item.IsRemboursement, item.Montant, item.Payeur, item.Mode, item.Time, item.Label, item.Details)
	return ScanPaiement(row)
}

// Update Paiement in the database and returns the new version.
func (item Paiement) Update(tx DB) (out Paiement, err error) {
	row := tx.QueryRow(`UPDATE paiements SET (
		iddossier, isremboursement, montant, payeur, mode, time, label, details
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8
		) WHERE id = $9 RETURNING id, iddossier, isremboursement, montant, payeur, mode, time, label, details;
		`, item.IdDossier, item.IsRemboursement, item.Montant, item.Payeur, item.Mode, item.Time, item.Label, item.Details, item.Id)
	return ScanPaiement(row)
}

// Deletes the Paiement and returns the item
func DeletePaiementById(tx DB, id IdPaiement) (Paiement, error) {
	row := tx.QueryRow("DELETE FROM paiements WHERE id = $1 RETURNING id, iddossier, isremboursement, montant, payeur, mode, time, label, details;", id)
	return ScanPaiement(row)
}

// Deletes the Paiement in the database and returns the ids.
func DeletePaiementsByIDs(tx DB, ids ...IdPaiement) ([]IdPaiement, error) {
	rows, err := tx.Query("DELETE FROM paiements WHERE id = ANY($1) RETURNING id", IdPaiementArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdPaiementArray(rows)
}

// ByIdDossier returns a map with 'IdDossier' as keys.
func (items Paiements) ByIdDossier() map[IdDossier]Paiements {
	out := make(map[IdDossier]Paiements)
	for _, target := range items {
		dict := out[target.IdDossier]
		if dict == nil {
			dict = make(Paiements)
		}
		dict[target.Id] = target
		out[target.IdDossier] = dict
	}
	return out
}

// IdDossiers returns the list of ids of IdDossier
// contained in this table.
// They are not garanteed to be distinct.
func (items Paiements) IdDossiers() []IdDossier {
	out := make([]IdDossier, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdDossier)
	}
	return out
}

func SelectPaiementsByIdDossiers(tx DB, idDossiers_ ...IdDossier) (Paiements, error) {
	rows, err := tx.Query("SELECT id, iddossier, isremboursement, montant, payeur, mode, time, label, details FROM paiements WHERE iddossier = ANY($1)", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

func DeletePaiementsByIdDossiers(tx DB, idDossiers_ ...IdDossier) ([]IdPaiement, error) {
	rows, err := tx.Query("DELETE FROM paiements WHERE iddossier = ANY($1) RETURNING id", IdDossierArrayToPQ(idDossiers_))
	if err != nil {
		return nil, err
	}
	return ScanIdPaiementArray(rows)
}

func scanOneTaux(row scanner) (Taux, error) {
	var item Taux
	err := row.Scan(
		&item.Id,
		&item.Label,
		&item.Euros,
		&item.FrancsSuisse,
	)
	return item, err
}

func ScanTaux(row *sql.Row) (Taux, error) { return scanOneTaux(row) }

// SelectAll returns all the items in the tauxs table.
func SelectAllTauxs(db DB) (Tauxs, error) {
	rows, err := db.Query("SELECT id, label, euros, francssuisse FROM tauxs")
	if err != nil {
		return nil, err
	}
	return ScanTauxs(rows)
}

// SelectTaux returns the entry matching 'id'.
func SelectTaux(tx DB, id IdTaux) (Taux, error) {
	row := tx.QueryRow("SELECT id, label, euros, francssuisse FROM tauxs WHERE id = $1", id)
	return ScanTaux(row)
}

// SelectTauxs returns the entry matching the given 'ids'.
func SelectTauxs(tx DB, ids ...IdTaux) (Tauxs, error) {
	rows, err := tx.Query("SELECT id, label, euros, francssuisse FROM tauxs WHERE id = ANY($1)", IdTauxArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanTauxs(rows)
}

type Tauxs map[IdTaux]Taux

func (m Tauxs) IDs() []IdTaux {
	out := make([]IdTaux, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanTauxs(rs *sql.Rows) (Tauxs, error) {
	var (
		s   Taux
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Tauxs, 16)
	for rs.Next() {
		s, err = scanOneTaux(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Taux in the database and returns the item with id filled.
func (item Taux) Insert(tx DB) (out Taux, err error) {
	row := tx.QueryRow(`INSERT INTO tauxs (
		label, euros, francssuisse
		) VALUES (
		$1, $2, $3
		) RETURNING id, label, euros, francssuisse;
		`, item.Label, item.Euros, item.FrancsSuisse)
	return ScanTaux(row)
}

// Update Taux in the database and returns the new version.
func (item Taux) Update(tx DB) (out Taux, err error) {
	row := tx.QueryRow(`UPDATE tauxs SET (
		label, euros, francssuisse
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING id, label, euros, francssuisse;
		`, item.Label, item.Euros, item.FrancsSuisse, item.Id)
	return ScanTaux(row)
}

// Deletes the Taux and returns the item
func DeleteTauxById(tx DB, id IdTaux) (Taux, error) {
	row := tx.QueryRow("DELETE FROM tauxs WHERE id = $1 RETURNING id, label, euros, francssuisse;", id)
	return ScanTaux(row)
}

// Deletes the Taux in the database and returns the ids.
func DeleteTauxsByIDs(tx DB, ids ...IdTaux) ([]IdTaux, error) {
	rows, err := tx.Query("DELETE FROM tauxs WHERE id = ANY($1) RETURNING id", IdTauxArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdTauxArray(rows)
}

// SelectTauxByLabel return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectTauxByLabel(tx DB, label string) (item Taux, found bool, err error) {
	row := tx.QueryRow("SELECT id, label, euros, francssuisse FROM tauxs WHERE Label = $1", label)
	item, err = ScanTaux(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out any, src any) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s any) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *Montant) Scan(src any) error {
	bs, ok := src.([]byte)
	if !ok {
		return fmt.Errorf("unsupported type %T", src)
	}
	fields := strings.Split(string(bs[1:len(bs)-1]), ",")
	if len(fields) != 2 {
		return fmt.Errorf("unsupported number of fields %d", len(fields))
	}

	valCent, err := strconv.Atoi(fields[0])
	if err != nil {
		return err
	}
	s.Cent = int(valCent)

	valCurrency, err := strconv.Atoi(fields[1])
	if err != nil {
		return err
	}
	s.Currency = Currency(valCurrency)

	return nil
}
func (s Montant) Value() (driver.Value, error) {
	bs := fmt.Sprintf("(%d, %d)", s.Cent, s.Currency)
	return driver.Value(bs), nil
}

func IdDossierArrayToPQ(ids []IdDossier) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdDossierArray scans the result of a query returning a
// list of ID's.
func ScanIdDossierArray(rs *sql.Rows) ([]IdDossier, error) {
	defer rs.Close()
	ints := make([]IdDossier, 0, 16)
	var err error
	for rs.Next() {
		var s IdDossier
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdPaiementArrayToPQ(ids []IdPaiement) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdPaiementArray scans the result of a query returning a
// list of ID's.
func ScanIdPaiementArray(rs *sql.Rows) ([]IdPaiement, error) {
	defer rs.Close()
	ints := make([]IdPaiement, 0, 16)
	var err error
	for rs.Next() {
		var s IdPaiement
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdTauxArrayToPQ(ids []IdTaux) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdTauxArray scans the result of a query returning a
// list of ID's.
func ScanIdTauxArray(rs *sql.Rows) ([]IdTaux, error) {
	defer rs.Close()
	ints := make([]IdTaux, 0, 16)
	var err error
	for rs.Next() {
		var s IdTaux
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func SwitchDossierPersonne(db DB, target personnes.IdPersonne, temporaire personnes.IdPersonne) error {
	_, err := db.Exec("UPDATE dossiers SET IdResponsable = $1 WHERE IdResponsable = $2;", target, temporaire)
	return err
}

func SwitchPaiementDossier(db DB, to IdDossier, from IdDossier) error {
	_, err := db.Exec("UPDATE paiements SET IdDossier = $1 WHERE IdDossier = $2;", to, from)
	return err
}
