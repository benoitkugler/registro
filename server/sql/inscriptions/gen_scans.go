package inscriptions

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"registro/sql/camps"
	"registro/sql/dossiers"
	"registro/sql/personnes"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneInscription(row scanner) (Inscription, error) {
	var item Inscription
	err := row.Scan(
		&item.Id,
		&item.IdTaux,
		&item.Responsable,
		&item.ResponsablePreIdent,
		&item.Message,
		&item.CopiesMails,
		&item.PartageAdressesOK,
		&item.DemandeFondSoutien,
		&item.DateHeure,
		&item.IsConfirmed,
	)
	return item, err
}

func ScanInscription(row *sql.Row) (Inscription, error) { return scanOneInscription(row) }

// SelectAll returns all the items in the inscriptions table.
func SelectAllInscriptions(db DB) (Inscriptions, error) {
	rows, err := db.Query("SELECT id, idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed FROM inscriptions")
	if err != nil {
		return nil, err
	}
	return ScanInscriptions(rows)
}

// SelectInscription returns the entry matching 'id'.
func SelectInscription(tx DB, id IdInscription) (Inscription, error) {
	row := tx.QueryRow("SELECT id, idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed FROM inscriptions WHERE id = $1", id)
	return ScanInscription(row)
}

// SelectInscriptions returns the entry matching the given 'ids'.
func SelectInscriptions(tx DB, ids ...IdInscription) (Inscriptions, error) {
	rows, err := tx.Query("SELECT id, idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed FROM inscriptions WHERE id = ANY($1)", IdInscriptionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanInscriptions(rows)
}

type Inscriptions map[IdInscription]Inscription

func (m Inscriptions) IDs() []IdInscription {
	out := make([]IdInscription, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanInscriptions(rs *sql.Rows) (Inscriptions, error) {
	var (
		s   Inscription
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Inscriptions, 16)
	for rs.Next() {
		s, err = scanOneInscription(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Inscription in the database and returns the item with id filled.
func (item Inscription) Insert(tx DB) (out Inscription, err error) {
	row := tx.QueryRow(`INSERT INTO inscriptions (
		idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed
		) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
		) RETURNING id, idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed;
		`, item.IdTaux, item.Responsable, item.ResponsablePreIdent, item.Message, item.CopiesMails, item.PartageAdressesOK, item.DemandeFondSoutien, item.DateHeure, item.IsConfirmed)
	return ScanInscription(row)
}

// Update Inscription in the database and returns the new version.
func (item Inscription) Update(tx DB) (out Inscription, err error) {
	row := tx.QueryRow(`UPDATE inscriptions SET (
		idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed
		) = (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
		) WHERE id = $10 RETURNING id, idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed;
		`, item.IdTaux, item.Responsable, item.ResponsablePreIdent, item.Message, item.CopiesMails, item.PartageAdressesOK, item.DemandeFondSoutien, item.DateHeure, item.IsConfirmed, item.Id)
	return ScanInscription(row)
}

// Deletes the Inscription and returns the item
func DeleteInscriptionById(tx DB, id IdInscription) (Inscription, error) {
	row := tx.QueryRow("DELETE FROM inscriptions WHERE id = $1 RETURNING id, idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed;", id)
	return ScanInscription(row)
}

// Deletes the Inscription in the database and returns the ids.
func DeleteInscriptionsByIDs(tx DB, ids ...IdInscription) ([]IdInscription, error) {
	rows, err := tx.Query("DELETE FROM inscriptions WHERE id = ANY($1) RETURNING id", IdInscriptionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdInscriptionArray(rows)
}

// ByIdTaux returns a map with 'IdTaux' as keys.
func (items Inscriptions) ByIdTaux() map[dossiers.IdTaux]Inscriptions {
	out := make(map[dossiers.IdTaux]Inscriptions)
	for _, target := range items {
		dict := out[target.IdTaux]
		if dict == nil {
			dict = make(Inscriptions)
		}
		dict[target.Id] = target
		out[target.IdTaux] = dict
	}
	return out
}

// IdTauxs returns the list of ids of IdTaux
// contained in this table.
// They are not garanteed to be distinct.
func (items Inscriptions) IdTauxs() []dossiers.IdTaux {
	out := make([]dossiers.IdTaux, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTaux)
	}
	return out
}

func SelectInscriptionsByIdTauxs(tx DB, idTauxs_ ...dossiers.IdTaux) (Inscriptions, error) {
	rows, err := tx.Query("SELECT id, idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed FROM inscriptions WHERE idtaux = ANY($1)", dossiers.IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptions(rows)
}

func DeleteInscriptionsByIdTauxs(tx DB, idTauxs_ ...dossiers.IdTaux) ([]IdInscription, error) {
	rows, err := tx.Query("DELETE FROM inscriptions WHERE idtaux = ANY($1) RETURNING id", dossiers.IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanIdInscriptionArray(rows)
}

func SelectInscriptionsByResponsablePreIdents(tx DB, responsablePreIdents_ ...personnes.IdPersonne) (Inscriptions, error) {
	rows, err := tx.Query("SELECT id, idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed FROM inscriptions WHERE responsablepreident = ANY($1)", personnes.IdPersonneArrayToPQ(responsablePreIdents_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptions(rows)
}

func DeleteInscriptionsByResponsablePreIdents(tx DB, responsablePreIdents_ ...personnes.IdPersonne) ([]IdInscription, error) {
	rows, err := tx.Query("DELETE FROM inscriptions WHERE responsablepreident = ANY($1) RETURNING id", personnes.IdPersonneArrayToPQ(responsablePreIdents_))
	if err != nil {
		return nil, err
	}
	return ScanIdInscriptionArray(rows)
}

func scanOneInscriptionParticipant(row scanner) (InscriptionParticipant, error) {
	var item InscriptionParticipant
	err := row.Scan(
		&item.IdInscription,
		&item.IdCamp,
		&item.IdTaux,
		&item.PreIdent,
		&item.Nom,
		&item.Prenom,
		&item.DateNaissance,
		&item.Sexe,
		&item.Nationnalite,
	)
	return item, err
}

func ScanInscriptionParticipant(row *sql.Row) (InscriptionParticipant, error) {
	return scanOneInscriptionParticipant(row)
}

// SelectAll returns all the items in the inscription_participants table.
func SelectAllInscriptionParticipants(db DB) (InscriptionParticipants, error) {
	rows, err := db.Query("SELECT idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite FROM inscription_participants")
	if err != nil {
		return nil, err
	}
	return ScanInscriptionParticipants(rows)
}

type InscriptionParticipants []InscriptionParticipant

func ScanInscriptionParticipants(rs *sql.Rows) (InscriptionParticipants, error) {
	var (
		item InscriptionParticipant
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(InscriptionParticipants, 0, 16)
	for rs.Next() {
		item, err = scanOneInscriptionParticipant(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item InscriptionParticipant) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO inscription_participants (
			idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite
			) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9
			);
			`, item.IdInscription, item.IdCamp, item.IdTaux, item.PreIdent, item.Nom, item.Prenom, item.DateNaissance, item.Sexe, item.Nationnalite)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links InscriptionParticipant in the database.
// It is a no-op if 'items' is empty.
func InsertManyInscriptionParticipants(tx *sql.Tx, items ...InscriptionParticipant) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("inscription_participants",
		"idinscription",
		"idcamp",
		"idtaux",
		"preident",
		"nom",
		"prenom",
		"datenaissance",
		"sexe",
		"nationnalite",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdInscription, item.IdCamp, item.IdTaux, item.PreIdent, item.Nom, item.Prenom, item.DateNaissance, item.Sexe, item.Nationnalite)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link InscriptionParticipant from the database.
// Only the foreign keys IdInscription, IdCamp, IdTaux, PreIdent fields are used in 'item'.
func (item InscriptionParticipant) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM inscription_participants WHERE IdInscription = $1 AND IdCamp = $2 AND IdTaux = $3 AND ((PreIdent IS NULL AND $4 IS NULL) OR PreIdent = $4);`, item.IdInscription, item.IdCamp, item.IdTaux, item.PreIdent)
	return err
}

// ByIdInscription returns a map with 'IdInscription' as keys.
func (items InscriptionParticipants) ByIdInscription() map[IdInscription]InscriptionParticipants {
	out := make(map[IdInscription]InscriptionParticipants)
	for _, target := range items {
		out[target.IdInscription] = append(out[target.IdInscription], target)
	}
	return out
}

// IdInscriptions returns the list of ids of IdInscription
// contained in this link table.
// They are not garanteed to be distinct.
func (items InscriptionParticipants) IdInscriptions() []IdInscription {
	out := make([]IdInscription, len(items))
	for index, target := range items {
		out[index] = target.IdInscription
	}
	return out
}

func SelectInscriptionParticipantsByIdInscriptions(tx DB, idInscriptions_ ...IdInscription) (InscriptionParticipants, error) {
	rows, err := tx.Query("SELECT idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite FROM inscription_participants WHERE idinscription = ANY($1)", IdInscriptionArrayToPQ(idInscriptions_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptionParticipants(rows)
}

func DeleteInscriptionParticipantsByIdInscriptions(tx DB, idInscriptions_ ...IdInscription) (InscriptionParticipants, error) {
	rows, err := tx.Query("DELETE FROM inscription_participants WHERE idinscription = ANY($1) RETURNING idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite", IdInscriptionArrayToPQ(idInscriptions_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptionParticipants(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items InscriptionParticipants) ByIdCamp() map[camps.IdCamp]InscriptionParticipants {
	out := make(map[camps.IdCamp]InscriptionParticipants)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// IdCamps returns the list of ids of IdCamp
// contained in this link table.
// They are not garanteed to be distinct.
func (items InscriptionParticipants) IdCamps() []camps.IdCamp {
	out := make([]camps.IdCamp, len(items))
	for index, target := range items {
		out[index] = target.IdCamp
	}
	return out
}

func SelectInscriptionParticipantsByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (InscriptionParticipants, error) {
	rows, err := tx.Query("SELECT idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite FROM inscription_participants WHERE idcamp = ANY($1)", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptionParticipants(rows)
}

func DeleteInscriptionParticipantsByIdCamps(tx DB, idCamps_ ...camps.IdCamp) (InscriptionParticipants, error) {
	rows, err := tx.Query("DELETE FROM inscription_participants WHERE idcamp = ANY($1) RETURNING idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite", camps.IdCampArrayToPQ(idCamps_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptionParticipants(rows)
}

// ByIdTaux returns a map with 'IdTaux' as keys.
func (items InscriptionParticipants) ByIdTaux() map[dossiers.IdTaux]InscriptionParticipants {
	out := make(map[dossiers.IdTaux]InscriptionParticipants)
	for _, target := range items {
		out[target.IdTaux] = append(out[target.IdTaux], target)
	}
	return out
}

// IdTauxs returns the list of ids of IdTaux
// contained in this link table.
// They are not garanteed to be distinct.
func (items InscriptionParticipants) IdTauxs() []dossiers.IdTaux {
	out := make([]dossiers.IdTaux, len(items))
	for index, target := range items {
		out[index] = target.IdTaux
	}
	return out
}

func SelectInscriptionParticipantsByIdTauxs(tx DB, idTauxs_ ...dossiers.IdTaux) (InscriptionParticipants, error) {
	rows, err := tx.Query("SELECT idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite FROM inscription_participants WHERE idtaux = ANY($1)", dossiers.IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptionParticipants(rows)
}

func DeleteInscriptionParticipantsByIdTauxs(tx DB, idTauxs_ ...dossiers.IdTaux) (InscriptionParticipants, error) {
	rows, err := tx.Query("DELETE FROM inscription_participants WHERE idtaux = ANY($1) RETURNING idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite", dossiers.IdTauxArrayToPQ(idTauxs_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptionParticipants(rows)
}

func SelectInscriptionParticipantsByPreIdents(tx DB, preIdents_ ...personnes.IdPersonne) (InscriptionParticipants, error) {
	rows, err := tx.Query("SELECT idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite FROM inscription_participants WHERE preident = ANY($1)", personnes.IdPersonneArrayToPQ(preIdents_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptionParticipants(rows)
}

func DeleteInscriptionParticipantsByPreIdents(tx DB, preIdents_ ...personnes.IdPersonne) (InscriptionParticipants, error) {
	rows, err := tx.Query("DELETE FROM inscription_participants WHERE preident = ANY($1) RETURNING idinscription, idcamp, idtaux, preident, nom, prenom, datenaissance, sexe, nationnalite", personnes.IdPersonneArrayToPQ(preIdents_))
	if err != nil {
		return nil, err
	}
	return ScanInscriptionParticipants(rows)
}

// SelectInscriptionByIdAndIdTaux return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectInscriptionByIdAndIdTaux(tx DB, id IdInscription, idTaux dossiers.IdTaux) (item Inscription, found bool, err error) {
	row := tx.QueryRow("SELECT id, idtaux, responsable, responsablepreident, message, copiesmails, partageadressesok, demandefondsoutien, dateheure, isconfirmed FROM inscriptions WHERE Id = $1 AND IdTaux = $2", id, idTaux)
	item, err = ScanInscription(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func IdInscriptionArrayToPQ(ids []IdInscription) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdInscriptionArray scans the result of a query returning a
// list of ID's.
func ScanIdInscriptionArray(rs *sql.Rows) ([]IdInscription, error) {
	defer rs.Close()
	ints := make([]IdInscription, 0, 16)
	var err error
	for rs.Next() {
		var s IdInscription
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdInscriptionSet map[IdInscription]bool

func NewIdInscriptionSetFrom(ids []IdInscription) IdInscriptionSet {
	out := make(IdInscriptionSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdInscriptionSet) Add(id IdInscription) { s[id] = true }

func (s IdInscriptionSet) Has(id IdInscription) bool { return s[id] }

func (s IdInscriptionSet) Keys() []IdInscription {
	out := make([]IdInscription, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *ResponsableLegal) Scan(src interface{}) error  { return loadJSON(s, src) }
func (s ResponsableLegal) Value() (driver.Value, error) { return dumpJSON(s) }
