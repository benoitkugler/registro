package logic

import (
	"encoding/json"
	"registro/sql/events"
	"time"
)

// Code generated by gomacro/generator/gounions. DO NOT EDIT

// EventContentWrapper may be used as replacements for EventContent
// when working with JSON
type EventContentWrapper struct {
	Data EventContent
}

func (out *EventContentWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "AccuseReception":
		var data AccuseReception
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Attestation":
		var data Attestation
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "CampDocs":
		var data CampDocs
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Facture":
		var data Facture
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Message":
		var data Message
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PlaceLiberee":
		var data PlaceLiberee
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Sondage":
		var data Sondage
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Supprime":
		var data Supprime
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item EventContentWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case AccuseReception:
		wr = wrapper{Kind: "AccuseReception", Data: data}
	case Attestation:
		wr = wrapper{Kind: "Attestation", Data: data}
	case CampDocs:
		wr = wrapper{Kind: "CampDocs", Data: data}
	case Facture:
		wr = wrapper{Kind: "Facture", Data: data}
	case Message:
		wr = wrapper{Kind: "Message", Data: data}
	case PlaceLiberee:
		wr = wrapper{Kind: "PlaceLiberee", Data: data}
	case Sondage:
		wr = wrapper{Kind: "Sondage", Data: data}
	case Supprime:
		wr = wrapper{Kind: "Supprime", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	AccuseReceptionEvKind = "AccuseReception"
	AttestationEvKind     = "Attestation"
	CampDocsEvKind        = "CampDocs"
	FactureEvKind         = "Facture"
	MessageEvKind         = "Message"
	PlaceLibereeEvKind    = "PlaceLiberee"
	SondageEvKind         = "Sondage"
	SupprimeEvKind        = "Supprime"
)

func (item Event) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Id      events.IdEvent
		Created time.Time
		Content EventContentWrapper
	}
	wr := wrapper{
		Id:      item.Id,
		Created: item.Created,
		Content: EventContentWrapper{item.Content},
	}
	return json.Marshal(wr)
}

func (item *Event) UnmarshalJSON(src []byte) error {
	type wrapper struct {
		Id      events.IdEvent
		Created time.Time
		Content EventContentWrapper
	}
	var wr wrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	item.Id = wr.Id
	item.Created = wr.Created
	item.Content = wr.Content.Data
	return nil
}
