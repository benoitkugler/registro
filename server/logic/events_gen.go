package logic

import (
	"encoding/json"
	"time"

	"registro/sql/dossiers"
	"registro/sql/events"
)

// Code generated by gomacro/generator/gounions. DO NOT EDIT

// EventContentWrapper may be used as replacements for EventContent
// when working with JSON
type EventContentWrapper struct {
	Data EventContent
}

func (out *EventContentWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "Attestation":
		var data AttestationEvt
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "CampDocs":
		var data CampDocsEvt
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Facture":
		var data FactureEvt
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Message":
		var data MessageEvt
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PlaceLiberee":
		var data PlaceLibereeEvt
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Sondage":
		var data SondageEvt
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Supprime":
		var data SupprimeEvt
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Validation":
		var data ValidationEvt
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item EventContentWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data any
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case AttestationEvt:
		wr = wrapper{Kind: "Attestation", Data: data}
	case CampDocsEvt:
		wr = wrapper{Kind: "CampDocs", Data: data}
	case FactureEvt:
		wr = wrapper{Kind: "Facture", Data: data}
	case MessageEvt:
		wr = wrapper{Kind: "Message", Data: data}
	case PlaceLibereeEvt:
		wr = wrapper{Kind: "PlaceLiberee", Data: data}
	case SondageEvt:
		wr = wrapper{Kind: "Sondage", Data: data}
	case SupprimeEvt:
		wr = wrapper{Kind: "Supprime", Data: data}
	case ValidationEvt:
		wr = wrapper{Kind: "Validation", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	AttestationEvKind  = "Attestation"
	CampDocsEvKind     = "CampDocs"
	FactureEvKind      = "Facture"
	MessageEvKind      = "Message"
	PlaceLibereeEvKind = "PlaceLiberee"
	SondageEvKind      = "Sondage"
	SupprimeEvKind     = "Supprime"
	ValidationEvKind   = "Validation"
)

func (item Event) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Id        events.IdEvent
		idDossier dossiers.IdDossier
		Created   time.Time
		Content   EventContentWrapper
	}
	wr := wrapper{
		Id:        item.Id,
		idDossier: item.idDossier,
		Created:   item.Created,
		Content:   EventContentWrapper{item.Content},
	}
	return json.Marshal(wr)
}

func (item *Event) UnmarshalJSON(src []byte) error {
	type wrapper struct {
		Id        events.IdEvent
		idDossier dossiers.IdDossier
		Created   time.Time
		Content   EventContentWrapper
	}
	var wr wrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	item.Id = wr.Id
	item.idDossier = wr.idDossier
	item.Created = wr.Created
	item.Content = wr.Content.Data
	return nil
}
