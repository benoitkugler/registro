// DON'T EDIT - automatically generated by structgen //

package rawdata

import (
	"database/sql"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneAide(row scanner) (Aide, error) {
	var s Aide
	err := row.Scan(
		&s.Id,
		&s.IdStructureaide,
		&s.IdParticipant,
		&s.Valeur,
		&s.Valide,
		&s.ParJour,
		&s.NbJoursMax,
	)
	return s, err
}

func ScanAide(row *sql.Row) (Aide, error) {
	return scanOneAide(row)
}

func SelectAllAides(tx DB) (Aides, error) {
	rows, err := tx.Query("SELECT * FROM aides")
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

// SelectAide returns the entry matching id.
func SelectAide(tx DB, id int64) (Aide, error) {
	row := tx.QueryRow("SELECT * FROM aides WHERE id = $1", id)
	return ScanAide(row)
}

// SelectAides returns the entry matching the given ids.
func SelectAides(tx DB, ids ...int64) (Aides, error) {
	rows, err := tx.Query("SELECT * FROM aides WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

type Aides map[int64]Aide

func (m Aides) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanAides(rs *sql.Rows) (Aides, error) {
	var (
		s   Aide
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Aides, 16)
	for rs.Next() {
		s, err = scanOneAide(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Aide in the database and returns the item with id filled.
func (item Aide) Insert(tx DB) (out Aide, err error) {
	row := tx.QueryRow(`INSERT INTO aides (
		id_structureaide,id_participant,valeur,valide,par_jour,nb_jours_max
		) VALUES (
		$1,$2,$3,$4,$5,$6
		) RETURNING 
		id,id_structureaide,id_participant,valeur,valide,par_jour,nb_jours_max;
		`, item.IdStructureaide, item.IdParticipant, item.Valeur, item.Valide, item.ParJour, item.NbJoursMax)
	return ScanAide(row)
}

// Update Aide in the database and returns the new version.
func (item Aide) Update(tx DB) (out Aide, err error) {
	row := tx.QueryRow(`UPDATE aides SET (
		id_structureaide,id_participant,valeur,valide,par_jour,nb_jours_max
		) = (
		$2,$3,$4,$5,$6,$7
		) WHERE id = $1 RETURNING 
		id,id_structureaide,id_participant,valeur,valide,par_jour,nb_jours_max;
		`, item.Id, item.IdStructureaide, item.IdParticipant, item.Valeur, item.Valide, item.ParJour, item.NbJoursMax)
	return ScanAide(row)
}

// Deletes the Aide and returns the item
func DeleteAideById(tx DB, id int64) (Aide, error) {
	row := tx.QueryRow("DELETE FROM aides WHERE id = $1 RETURNING *;", id)
	return ScanAide(row)
}

// Deletes the Aide in the database and returns the ids.
func DeleteAidesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM aides WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneCamp(row scanner) (Camp, error) {
	var s Camp
	err := row.Scan(
		&s.Id,
		&s.Lieu,
		&s.Nom,
		&s.Prix,
		&s.NbPlaces,
		&s.Password,
		&s.Ouvert,
		&s.NbPlacesReservees,
		&s.NumeroJS,
		&s.NeedEquilibreGf,
		&s.AgeMin,
		&s.AgeMax,
		&s.Options,
		&s.DateDebut,
		&s.DateFin,
		&s.ListeVetements,
		&s.SchemaPaiement,
		&s.JoomeoAlbumId,
		&s.Envois,
		&s.LienCompta,
		&s.OptionPrix,
		&s.InscriptionSimple,
		&s.Infos,
		&s.QuotientFamilial,
	)
	return s, err
}

func ScanCamp(row *sql.Row) (Camp, error) {
	return scanOneCamp(row)
}

func SelectAllCamps(tx DB) (Camps, error) {
	rows, err := tx.Query("SELECT * FROM camps")
	if err != nil {
		return nil, err
	}
	return ScanCamps(rows)
}

// SelectCamp returns the entry matching id.
func SelectCamp(tx DB, id int64) (Camp, error) {
	row := tx.QueryRow("SELECT * FROM camps WHERE id = $1", id)
	return ScanCamp(row)
}

// SelectCamps returns the entry matching the given ids.
func SelectCamps(tx DB, ids ...int64) (Camps, error) {
	rows, err := tx.Query("SELECT * FROM camps WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanCamps(rows)
}

type Camps map[int64]Camp

func (m Camps) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanCamps(rs *sql.Rows) (Camps, error) {
	var (
		s   Camp
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Camps, 16)
	for rs.Next() {
		s, err = scanOneCamp(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Camp in the database and returns the item with id filled.
func (item Camp) Insert(tx DB) (out Camp, err error) {
	row := tx.QueryRow(`INSERT INTO camps (
		lieu,nom,prix,nb_places,password,ouvert,nb_places_reservees,numero_js,need_equilibre_gf,age_min,age_max,options,date_debut,date_fin,liste_vetements,schema_paiement,joomeo_album_id,envois,lien_compta,option_prix,inscription_simple,infos,quotient_familial
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23
		) RETURNING 
		id,lieu,nom,prix,nb_places,password,ouvert,nb_places_reservees,numero_js,need_equilibre_gf,age_min,age_max,options,date_debut,date_fin,liste_vetements,schema_paiement,joomeo_album_id,envois,lien_compta,option_prix,inscription_simple,infos,quotient_familial;
		`, item.Lieu, item.Nom, item.Prix, item.NbPlaces, item.Password, item.Ouvert, item.NbPlacesReservees, item.NumeroJS, item.NeedEquilibreGf, item.AgeMin, item.AgeMax, item.Options, item.DateDebut, item.DateFin, item.ListeVetements, item.SchemaPaiement, item.JoomeoAlbumId, item.Envois, item.LienCompta, item.OptionPrix, item.InscriptionSimple, item.Infos, item.QuotientFamilial)
	return ScanCamp(row)
}

// Update Camp in the database and returns the new version.
func (item Camp) Update(tx DB) (out Camp, err error) {
	row := tx.QueryRow(`UPDATE camps SET (
		lieu,nom,prix,nb_places,password,ouvert,nb_places_reservees,numero_js,need_equilibre_gf,age_min,age_max,options,date_debut,date_fin,liste_vetements,schema_paiement,joomeo_album_id,envois,lien_compta,option_prix,inscription_simple,infos,quotient_familial
		) = (
		$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24
		) WHERE id = $1 RETURNING 
		id,lieu,nom,prix,nb_places,password,ouvert,nb_places_reservees,numero_js,need_equilibre_gf,age_min,age_max,options,date_debut,date_fin,liste_vetements,schema_paiement,joomeo_album_id,envois,lien_compta,option_prix,inscription_simple,infos,quotient_familial;
		`, item.Id, item.Lieu, item.Nom, item.Prix, item.NbPlaces, item.Password, item.Ouvert, item.NbPlacesReservees, item.NumeroJS, item.NeedEquilibreGf, item.AgeMin, item.AgeMax, item.Options, item.DateDebut, item.DateFin, item.ListeVetements, item.SchemaPaiement, item.JoomeoAlbumId, item.Envois, item.LienCompta, item.OptionPrix, item.InscriptionSimple, item.Infos, item.QuotientFamilial)
	return ScanCamp(row)
}

// Deletes the Camp and returns the item
func DeleteCampById(tx DB, id int64) (Camp, error) {
	row := tx.QueryRow("DELETE FROM camps WHERE id = $1 RETURNING *;", id)
	return ScanCamp(row)
}

// Deletes the Camp in the database and returns the ids.
func DeleteCampsByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM camps WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneCampContrainte(row scanner) (CampContrainte, error) {
	var s CampContrainte
	err := row.Scan(
		&s.IdCamp,
		&s.IdContrainte,
	)
	return s, err
}

func ScanCampContrainte(row *sql.Row) (CampContrainte, error) {
	return scanOneCampContrainte(row)
}

func SelectAllCampContraintes(tx DB) (CampContraintes, error) {
	rows, err := tx.Query("SELECT * FROM camp_contraintes")
	if err != nil {
		return nil, err
	}
	return ScanCampContraintes(rows)
}

type CampContraintes []CampContrainte

func ScanCampContraintes(rs *sql.Rows) (CampContraintes, error) {
	var (
		s   CampContrainte
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(CampContraintes, 0, 16)
	for rs.Next() {
		s, err = scanOneCampContrainte(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links CampContrainte in the database.
func InsertManyCampContraintes(tx *sql.Tx, items ...CampContrainte) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("camp_contraintes",
		"id_camp", "id_contrainte",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdCamp, item.IdContrainte)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link CampContrainte in the database.
// Only the 'IdCamp' 'IdContrainte' fields are used.
func (item CampContrainte) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM camp_contraintes WHERE 
	id_camp = $1 AND id_contrainte = $2;`, item.IdCamp, item.IdContrainte)
	return err
}

func scanOneContenuDocument(row scanner) (ContenuDocument, error) {
	var s ContenuDocument
	err := row.Scan(
		&s.IdDocument,
		&s.Contenu,
		&s.Miniature,
	)
	return s, err
}

func ScanContenuDocument(row *sql.Row) (ContenuDocument, error) {
	return scanOneContenuDocument(row)
}

func SelectAllContenuDocuments(tx DB) (ContenuDocuments, error) {
	rows, err := tx.Query("SELECT * FROM contenu_documents")
	if err != nil {
		return nil, err
	}
	return ScanContenuDocuments(rows)
}

type ContenuDocuments []ContenuDocument

func ScanContenuDocuments(rs *sql.Rows) (ContenuDocuments, error) {
	var (
		s   ContenuDocument
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ContenuDocuments, 0, 16)
	for rs.Next() {
		s, err = scanOneContenuDocument(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links ContenuDocument in the database.
func InsertManyContenuDocuments(tx *sql.Tx, items ...ContenuDocument) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("contenu_documents",
		"id_document", "contenu", "miniature",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdDocument, item.Contenu, item.Miniature)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ContenuDocument in the database.
// Only the 'IdDocument' fields are used.
func (item ContenuDocument) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM contenu_documents WHERE 
	id_document = $1;`, item.IdDocument)
	return err
}

func scanOneContrainte(row scanner) (Contrainte, error) {
	var s Contrainte
	err := row.Scan(
		&s.Id,
		&s.IdPersonne,
		&s.IdDocument,
		&s.Builtin,
		&s.Nom,
		&s.Description,
		&s.MaxDocs,
		&s.JoursValide,
	)
	return s, err
}

func ScanContrainte(row *sql.Row) (Contrainte, error) {
	return scanOneContrainte(row)
}

func SelectAllContraintes(tx DB) (Contraintes, error) {
	rows, err := tx.Query("SELECT * FROM contraintes")
	if err != nil {
		return nil, err
	}
	return ScanContraintes(rows)
}

// SelectContrainte returns the entry matching id.
func SelectContrainte(tx DB, id int64) (Contrainte, error) {
	row := tx.QueryRow("SELECT * FROM contraintes WHERE id = $1", id)
	return ScanContrainte(row)
}

// SelectContraintes returns the entry matching the given ids.
func SelectContraintes(tx DB, ids ...int64) (Contraintes, error) {
	rows, err := tx.Query("SELECT * FROM contraintes WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanContraintes(rows)
}

type Contraintes map[int64]Contrainte

func (m Contraintes) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanContraintes(rs *sql.Rows) (Contraintes, error) {
	var (
		s   Contrainte
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Contraintes, 16)
	for rs.Next() {
		s, err = scanOneContrainte(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Contrainte in the database and returns the item with id filled.
func (item Contrainte) Insert(tx DB) (out Contrainte, err error) {
	row := tx.QueryRow(`INSERT INTO contraintes (
		id_personne,id_document,builtin,nom,description,max_docs,jours_valide
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7
		) RETURNING 
		id,id_personne,id_document,builtin,nom,description,max_docs,jours_valide;
		`, item.IdPersonne, item.IdDocument, item.Builtin, item.Nom, item.Description, item.MaxDocs, item.JoursValide)
	return ScanContrainte(row)
}

// Update Contrainte in the database and returns the new version.
func (item Contrainte) Update(tx DB) (out Contrainte, err error) {
	row := tx.QueryRow(`UPDATE contraintes SET (
		id_personne,id_document,builtin,nom,description,max_docs,jours_valide
		) = (
		$2,$3,$4,$5,$6,$7,$8
		) WHERE id = $1 RETURNING 
		id,id_personne,id_document,builtin,nom,description,max_docs,jours_valide;
		`, item.Id, item.IdPersonne, item.IdDocument, item.Builtin, item.Nom, item.Description, item.MaxDocs, item.JoursValide)
	return ScanContrainte(row)
}

// Deletes the Contrainte and returns the item
func DeleteContrainteById(tx DB, id int64) (Contrainte, error) {
	row := tx.QueryRow("DELETE FROM contraintes WHERE id = $1 RETURNING *;", id)
	return ScanContrainte(row)
}

// Deletes the Contrainte in the database and returns the ids.
func DeleteContraintesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM contraintes WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneDocument(row scanner) (Document, error) {
	var s Document
	err := row.Scan(
		&s.Id,
		&s.Taille,
		&s.NomClient,
		&s.Description,
		&s.DateHeureModif,
	)
	return s, err
}

func ScanDocument(row *sql.Row) (Document, error) {
	return scanOneDocument(row)
}

func SelectAllDocuments(tx DB) (Documents, error) {
	rows, err := tx.Query("SELECT * FROM documents")
	if err != nil {
		return nil, err
	}
	return ScanDocuments(rows)
}

// SelectDocument returns the entry matching id.
func SelectDocument(tx DB, id int64) (Document, error) {
	row := tx.QueryRow("SELECT * FROM documents WHERE id = $1", id)
	return ScanDocument(row)
}

// SelectDocuments returns the entry matching the given ids.
func SelectDocuments(tx DB, ids ...int64) (Documents, error) {
	rows, err := tx.Query("SELECT * FROM documents WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanDocuments(rows)
}

type Documents map[int64]Document

func (m Documents) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanDocuments(rs *sql.Rows) (Documents, error) {
	var (
		s   Document
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Documents, 16)
	for rs.Next() {
		s, err = scanOneDocument(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Document in the database and returns the item with id filled.
func (item Document) Insert(tx DB) (out Document, err error) {
	row := tx.QueryRow(`INSERT INTO documents (
		taille,nom_client,description,date_heure_modif
		) VALUES (
		$1,$2,$3,$4
		) RETURNING 
		id,taille,nom_client,description,date_heure_modif;
		`, item.Taille, item.NomClient, item.Description, item.DateHeureModif)
	return ScanDocument(row)
}

// Update Document in the database and returns the new version.
func (item Document) Update(tx DB) (out Document, err error) {
	row := tx.QueryRow(`UPDATE documents SET (
		taille,nom_client,description,date_heure_modif
		) = (
		$2,$3,$4,$5
		) WHERE id = $1 RETURNING 
		id,taille,nom_client,description,date_heure_modif;
		`, item.Id, item.Taille, item.NomClient, item.Description, item.DateHeureModif)
	return ScanDocument(row)
}

// Deletes the Document and returns the item
func DeleteDocumentById(tx DB, id int64) (Document, error) {
	row := tx.QueryRow("DELETE FROM documents WHERE id = $1 RETURNING *;", id)
	return ScanDocument(row)
}

// Deletes the Document in the database and returns the ids.
func DeleteDocumentsByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM documents WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneDocumentAide(row scanner) (DocumentAide, error) {
	var s DocumentAide
	err := row.Scan(
		&s.IdDocument,
		&s.IdAide,
	)
	return s, err
}

func ScanDocumentAide(row *sql.Row) (DocumentAide, error) {
	return scanOneDocumentAide(row)
}

func SelectAllDocumentAides(tx DB) (DocumentAides, error) {
	rows, err := tx.Query("SELECT * FROM document_aides")
	if err != nil {
		return nil, err
	}
	return ScanDocumentAides(rows)
}

type DocumentAides []DocumentAide

func ScanDocumentAides(rs *sql.Rows) (DocumentAides, error) {
	var (
		s   DocumentAide
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(DocumentAides, 0, 16)
	for rs.Next() {
		s, err = scanOneDocumentAide(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links DocumentAide in the database.
func InsertManyDocumentAides(tx *sql.Tx, items ...DocumentAide) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("document_aides",
		"id_document", "id_aide",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdDocument, item.IdAide)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link DocumentAide in the database.
// Only the 'IdDocument' 'IdAide' fields are used.
func (item DocumentAide) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM document_aides WHERE 
	id_document = $1 AND id_aide = $2;`, item.IdDocument, item.IdAide)
	return err
}

func scanOneDocumentCamp(row scanner) (DocumentCamp, error) {
	var s DocumentCamp
	err := row.Scan(
		&s.IdDocument,
		&s.IdCamp,
		&s.IsLettre,
	)
	return s, err
}

func ScanDocumentCamp(row *sql.Row) (DocumentCamp, error) {
	return scanOneDocumentCamp(row)
}

func SelectAllDocumentCamps(tx DB) (DocumentCamps, error) {
	rows, err := tx.Query("SELECT * FROM document_camps")
	if err != nil {
		return nil, err
	}
	return ScanDocumentCamps(rows)
}

type DocumentCamps []DocumentCamp

func ScanDocumentCamps(rs *sql.Rows) (DocumentCamps, error) {
	var (
		s   DocumentCamp
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(DocumentCamps, 0, 16)
	for rs.Next() {
		s, err = scanOneDocumentCamp(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links DocumentCamp in the database.
func InsertManyDocumentCamps(tx *sql.Tx, items ...DocumentCamp) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("document_camps",
		"id_document", "id_camp", "is_lettre",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdDocument, item.IdCamp, item.IsLettre)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link DocumentCamp in the database.
// Only the 'IdDocument' 'IdCamp' fields are used.
func (item DocumentCamp) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM document_camps WHERE 
	id_document = $1 AND id_camp = $2;`, item.IdDocument, item.IdCamp)
	return err
}

func scanOneDocumentPersonne(row scanner) (DocumentPersonne, error) {
	var s DocumentPersonne
	err := row.Scan(
		&s.IdDocument,
		&s.IdPersonne,
		&s.IdContrainte,
	)
	return s, err
}

func ScanDocumentPersonne(row *sql.Row) (DocumentPersonne, error) {
	return scanOneDocumentPersonne(row)
}

func SelectAllDocumentPersonnes(tx DB) (DocumentPersonnes, error) {
	rows, err := tx.Query("SELECT * FROM document_personnes")
	if err != nil {
		return nil, err
	}
	return ScanDocumentPersonnes(rows)
}

type DocumentPersonnes []DocumentPersonne

func ScanDocumentPersonnes(rs *sql.Rows) (DocumentPersonnes, error) {
	var (
		s   DocumentPersonne
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(DocumentPersonnes, 0, 16)
	for rs.Next() {
		s, err = scanOneDocumentPersonne(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links DocumentPersonne in the database.
func InsertManyDocumentPersonnes(tx *sql.Tx, items ...DocumentPersonne) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("document_personnes",
		"id_document", "id_personne", "id_contrainte",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdDocument, item.IdPersonne, item.IdContrainte)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link DocumentPersonne in the database.
// Only the 'IdDocument' 'IdPersonne' 'IdContrainte' fields are used.
func (item DocumentPersonne) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM document_personnes WHERE 
	id_document = $1 AND id_personne = $2 AND id_contrainte = $3;`, item.IdDocument, item.IdPersonne, item.IdContrainte)
	return err
}

func scanOneDon(row scanner) (Don, error) {
	var s Don
	err := row.Scan(
		&s.Id,
		&s.Valeur,
		&s.ModePaiement,
		&s.DateReception,
		&s.RecuEmis,
		&s.Infos,
		&s.Remercie,
		&s.Details,
		&s.Affectation,
	)
	return s, err
}

func ScanDon(row *sql.Row) (Don, error) {
	return scanOneDon(row)
}

func SelectAllDons(tx DB) (Dons, error) {
	rows, err := tx.Query("SELECT * FROM dons")
	if err != nil {
		return nil, err
	}
	return ScanDons(rows)
}

// SelectDon returns the entry matching id.
func SelectDon(tx DB, id int64) (Don, error) {
	row := tx.QueryRow("SELECT * FROM dons WHERE id = $1", id)
	return ScanDon(row)
}

// SelectDons returns the entry matching the given ids.
func SelectDons(tx DB, ids ...int64) (Dons, error) {
	rows, err := tx.Query("SELECT * FROM dons WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanDons(rows)
}

type Dons map[int64]Don

func (m Dons) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanDons(rs *sql.Rows) (Dons, error) {
	var (
		s   Don
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Dons, 16)
	for rs.Next() {
		s, err = scanOneDon(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Don in the database and returns the item with id filled.
func (item Don) Insert(tx DB) (out Don, err error) {
	row := tx.QueryRow(`INSERT INTO dons (
		valeur,mode_paiement,date_reception,recu_emis,infos,remercie,details,affectation
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7,$8
		) RETURNING 
		id,valeur,mode_paiement,date_reception,recu_emis,infos,remercie,details,affectation;
		`, item.Valeur, item.ModePaiement, item.DateReception, item.RecuEmis, item.Infos, item.Remercie, item.Details, item.Affectation)
	return ScanDon(row)
}

// Update Don in the database and returns the new version.
func (item Don) Update(tx DB) (out Don, err error) {
	row := tx.QueryRow(`UPDATE dons SET (
		valeur,mode_paiement,date_reception,recu_emis,infos,remercie,details,affectation
		) = (
		$2,$3,$4,$5,$6,$7,$8,$9
		) WHERE id = $1 RETURNING 
		id,valeur,mode_paiement,date_reception,recu_emis,infos,remercie,details,affectation;
		`, item.Id, item.Valeur, item.ModePaiement, item.DateReception, item.RecuEmis, item.Infos, item.Remercie, item.Details, item.Affectation)
	return ScanDon(row)
}

// Deletes the Don and returns the item
func DeleteDonById(tx DB, id int64) (Don, error) {
	row := tx.QueryRow("DELETE FROM dons WHERE id = $1 RETURNING *;", id)
	return ScanDon(row)
}

// Deletes the Don in the database and returns the ids.
func DeleteDonsByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM dons WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneDonDonateur(row scanner) (DonDonateur, error) {
	var s DonDonateur
	err := row.Scan(
		&s.IdDon,
		&s.IdPersonne,
		&s.IdOrganisme,
	)
	return s, err
}

func ScanDonDonateur(row *sql.Row) (DonDonateur, error) {
	return scanOneDonDonateur(row)
}

func SelectAllDonDonateurs(tx DB) (DonDonateurs, error) {
	rows, err := tx.Query("SELECT * FROM don_donateurs")
	if err != nil {
		return nil, err
	}
	return ScanDonDonateurs(rows)
}

type DonDonateurs []DonDonateur

func ScanDonDonateurs(rs *sql.Rows) (DonDonateurs, error) {
	var (
		s   DonDonateur
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(DonDonateurs, 0, 16)
	for rs.Next() {
		s, err = scanOneDonDonateur(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links DonDonateur in the database.
func InsertManyDonDonateurs(tx *sql.Tx, items ...DonDonateur) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("don_donateurs",
		"id_don", "id_personne", "id_organisme",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdDon, item.IdPersonne, item.IdOrganisme)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link DonDonateur in the database.
// Only the 'IdDon' 'IdPersonne' 'IdOrganisme' fields are used.
func (item DonDonateur) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM don_donateurs WHERE 
	id_don = $1 AND ( id_personne IS NULL OR id_personne = $2) AND ( id_organisme IS NULL OR id_organisme = $3);`, item.IdDon, item.IdPersonne, item.IdOrganisme)
	return err
}

func scanOneEquipier(row scanner) (Equipier, error) {
	var s Equipier
	err := row.Scan(
		&s.Id,
		&s.IdCamp,
		&s.IdPersonne,
		&s.Roles,
		&s.Diplome,
		&s.Appro,
		&s.Presence,
		&s.InvitationEquipier,
		&s.Charte,
	)
	return s, err
}

func ScanEquipier(row *sql.Row) (Equipier, error) {
	return scanOneEquipier(row)
}

func SelectAllEquipiers(tx DB) (Equipiers, error) {
	rows, err := tx.Query("SELECT * FROM equipiers")
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

// SelectEquipier returns the entry matching id.
func SelectEquipier(tx DB, id int64) (Equipier, error) {
	row := tx.QueryRow("SELECT * FROM equipiers WHERE id = $1", id)
	return ScanEquipier(row)
}

// SelectEquipiers returns the entry matching the given ids.
func SelectEquipiers(tx DB, ids ...int64) (Equipiers, error) {
	rows, err := tx.Query("SELECT * FROM equipiers WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

type Equipiers map[int64]Equipier

func (m Equipiers) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanEquipiers(rs *sql.Rows) (Equipiers, error) {
	var (
		s   Equipier
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Equipiers, 16)
	for rs.Next() {
		s, err = scanOneEquipier(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Equipier in the database and returns the item with id filled.
func (item Equipier) Insert(tx DB) (out Equipier, err error) {
	row := tx.QueryRow(`INSERT INTO equipiers (
		id_camp,id_personne,roles,diplome,appro,presence,invitation_equipier,charte
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7,$8
		) RETURNING 
		id,id_camp,id_personne,roles,diplome,appro,presence,invitation_equipier,charte;
		`, item.IdCamp, item.IdPersonne, item.Roles, item.Diplome, item.Appro, item.Presence, item.InvitationEquipier, item.Charte)
	return ScanEquipier(row)
}

// Update Equipier in the database and returns the new version.
func (item Equipier) Update(tx DB) (out Equipier, err error) {
	row := tx.QueryRow(`UPDATE equipiers SET (
		id_camp,id_personne,roles,diplome,appro,presence,invitation_equipier,charte
		) = (
		$2,$3,$4,$5,$6,$7,$8,$9
		) WHERE id = $1 RETURNING 
		id,id_camp,id_personne,roles,diplome,appro,presence,invitation_equipier,charte;
		`, item.Id, item.IdCamp, item.IdPersonne, item.Roles, item.Diplome, item.Appro, item.Presence, item.InvitationEquipier, item.Charte)
	return ScanEquipier(row)
}

// Deletes the Equipier and returns the item
func DeleteEquipierById(tx DB, id int64) (Equipier, error) {
	row := tx.QueryRow("DELETE FROM equipiers WHERE id = $1 RETURNING *;", id)
	return ScanEquipier(row)
}

// Deletes the Equipier in the database and returns the ids.
func DeleteEquipiersByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM equipiers WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneEquipierContrainte(row scanner) (EquipierContrainte, error) {
	var s EquipierContrainte
	err := row.Scan(
		&s.IdEquipier,
		&s.IdContrainte,
		&s.Optionnel,
	)
	return s, err
}

func ScanEquipierContrainte(row *sql.Row) (EquipierContrainte, error) {
	return scanOneEquipierContrainte(row)
}

func SelectAllEquipierContraintes(tx DB) (EquipierContraintes, error) {
	rows, err := tx.Query("SELECT * FROM equipier_contraintes")
	if err != nil {
		return nil, err
	}
	return ScanEquipierContraintes(rows)
}

type EquipierContraintes []EquipierContrainte

func ScanEquipierContraintes(rs *sql.Rows) (EquipierContraintes, error) {
	var (
		s   EquipierContrainte
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(EquipierContraintes, 0, 16)
	for rs.Next() {
		s, err = scanOneEquipierContrainte(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links EquipierContrainte in the database.
func InsertManyEquipierContraintes(tx *sql.Tx, items ...EquipierContrainte) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("equipier_contraintes",
		"id_equipier", "id_contrainte", "optionnel",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdEquipier, item.IdContrainte, item.Optionnel)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link EquipierContrainte in the database.
// Only the 'IdEquipier' 'IdContrainte' fields are used.
func (item EquipierContrainte) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM equipier_contraintes WHERE 
	id_equipier = $1 AND id_contrainte = $2;`, item.IdEquipier, item.IdContrainte)
	return err
}

func scanOneFacture(row scanner) (Facture, error) {
	var s Facture
	err := row.Scan(
		&s.Id,
		&s.IdPersonne,
		&s.DestinatairesOptionnels,
		&s.Key,
		&s.CopiesMails,
		&s.LastConnection,
		&s.IsConfirmed,
		&s.IsValidated,
		&s.PartageAdressesOK,
	)
	return s, err
}

func ScanFacture(row *sql.Row) (Facture, error) {
	return scanOneFacture(row)
}

func SelectAllFactures(tx DB) (Factures, error) {
	rows, err := tx.Query("SELECT * FROM factures")
	if err != nil {
		return nil, err
	}
	return ScanFactures(rows)
}

// SelectFacture returns the entry matching id.
func SelectFacture(tx DB, id int64) (Facture, error) {
	row := tx.QueryRow("SELECT * FROM factures WHERE id = $1", id)
	return ScanFacture(row)
}

// SelectFactures returns the entry matching the given ids.
func SelectFactures(tx DB, ids ...int64) (Factures, error) {
	rows, err := tx.Query("SELECT * FROM factures WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanFactures(rows)
}

type Factures map[int64]Facture

func (m Factures) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanFactures(rs *sql.Rows) (Factures, error) {
	var (
		s   Facture
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Factures, 16)
	for rs.Next() {
		s, err = scanOneFacture(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Facture in the database and returns the item with id filled.
func (item Facture) Insert(tx DB) (out Facture, err error) {
	row := tx.QueryRow(`INSERT INTO factures (
		id_personne,destinataires_optionnels,key,copies_mails,last_connection,is_confirmed,is_validated,partage_adresses_ok
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7,$8
		) RETURNING 
		id,id_personne,destinataires_optionnels,key,copies_mails,last_connection,is_confirmed,is_validated,partage_adresses_ok;
		`, item.IdPersonne, item.DestinatairesOptionnels, item.Key, item.CopiesMails, item.LastConnection, item.IsConfirmed, item.IsValidated, item.PartageAdressesOK)
	return ScanFacture(row)
}

// Update Facture in the database and returns the new version.
func (item Facture) Update(tx DB) (out Facture, err error) {
	row := tx.QueryRow(`UPDATE factures SET (
		id_personne,destinataires_optionnels,key,copies_mails,last_connection,is_confirmed,is_validated,partage_adresses_ok
		) = (
		$2,$3,$4,$5,$6,$7,$8,$9
		) WHERE id = $1 RETURNING 
		id,id_personne,destinataires_optionnels,key,copies_mails,last_connection,is_confirmed,is_validated,partage_adresses_ok;
		`, item.Id, item.IdPersonne, item.DestinatairesOptionnels, item.Key, item.CopiesMails, item.LastConnection, item.IsConfirmed, item.IsValidated, item.PartageAdressesOK)
	return ScanFacture(row)
}

// Deletes the Facture and returns the item
func DeleteFactureById(tx DB, id int64) (Facture, error) {
	row := tx.QueryRow("DELETE FROM factures WHERE id = $1 RETURNING *;", id)
	return ScanFacture(row)
}

// Deletes the Facture in the database and returns the ids.
func DeleteFacturesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM factures WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneGroupe(row scanner) (Groupe, error) {
	var s Groupe
	err := row.Scan(
		&s.Id,
		&s.IdCamp,
		&s.Nom,
		&s.Plage,
		&s.Couleur,
		&s.isSimple,
	)
	return s, err
}

func ScanGroupe(row *sql.Row) (Groupe, error) {
	return scanOneGroupe(row)
}

func SelectAllGroupes(tx DB) (Groupes, error) {
	rows, err := tx.Query("SELECT * FROM groupes")
	if err != nil {
		return nil, err
	}
	return ScanGroupes(rows)
}

// SelectGroupe returns the entry matching id.
func SelectGroupe(tx DB, id int64) (Groupe, error) {
	row := tx.QueryRow("SELECT * FROM groupes WHERE id = $1", id)
	return ScanGroupe(row)
}

// SelectGroupes returns the entry matching the given ids.
func SelectGroupes(tx DB, ids ...int64) (Groupes, error) {
	rows, err := tx.Query("SELECT * FROM groupes WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanGroupes(rows)
}

type Groupes map[int64]Groupe

func (m Groupes) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanGroupes(rs *sql.Rows) (Groupes, error) {
	var (
		s   Groupe
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Groupes, 16)
	for rs.Next() {
		s, err = scanOneGroupe(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Groupe in the database and returns the item with id filled.
func (item Groupe) Insert(tx DB) (out Groupe, err error) {
	row := tx.QueryRow(`INSERT INTO groupes (
		id_camp,nom,plage,couleur
		) VALUES (
		$1,$2,$3,$4
		) RETURNING 
		id,id_camp,nom,plage,couleur,isSimple;
		`, item.IdCamp, item.Nom, item.Plage, item.Couleur)
	return ScanGroupe(row)
}

// Update Groupe in the database and returns the new version.
func (item Groupe) Update(tx DB) (out Groupe, err error) {
	row := tx.QueryRow(`UPDATE groupes SET (
		id_camp,nom,plage,couleur
		) = (
		$2,$3,$4,$5
		) WHERE id = $1 RETURNING 
		id,id_camp,nom,plage,couleur,isSimple;
		`, item.Id, item.IdCamp, item.Nom, item.Plage, item.Couleur)
	return ScanGroupe(row)
}

// Deletes the Groupe and returns the item
func DeleteGroupeById(tx DB, id int64) (Groupe, error) {
	row := tx.QueryRow("DELETE FROM groupes WHERE id = $1 RETURNING *;", id)
	return ScanGroupe(row)
}

// Deletes the Groupe in the database and returns the ids.
func DeleteGroupesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM groupes WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneGroupeContrainte(row scanner) (GroupeContrainte, error) {
	var s GroupeContrainte
	err := row.Scan(
		&s.IdGroupe,
		&s.IdContrainte,
	)
	return s, err
}

func ScanGroupeContrainte(row *sql.Row) (GroupeContrainte, error) {
	return scanOneGroupeContrainte(row)
}

func SelectAllGroupeContraintes(tx DB) (GroupeContraintes, error) {
	rows, err := tx.Query("SELECT * FROM groupe_contraintes")
	if err != nil {
		return nil, err
	}
	return ScanGroupeContraintes(rows)
}

type GroupeContraintes []GroupeContrainte

func ScanGroupeContraintes(rs *sql.Rows) (GroupeContraintes, error) {
	var (
		s   GroupeContrainte
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(GroupeContraintes, 0, 16)
	for rs.Next() {
		s, err = scanOneGroupeContrainte(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links GroupeContrainte in the database.
func InsertManyGroupeContraintes(tx *sql.Tx, items ...GroupeContrainte) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("groupe_contraintes",
		"id_groupe", "id_contrainte",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdGroupe, item.IdContrainte)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link GroupeContrainte in the database.
// Only the 'IdGroupe' 'IdContrainte' fields are used.
func (item GroupeContrainte) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM groupe_contraintes WHERE 
	id_groupe = $1 AND id_contrainte = $2;`, item.IdGroupe, item.IdContrainte)
	return err
}

func scanOneGroupeEquipier(row scanner) (GroupeEquipier, error) {
	var s GroupeEquipier
	err := row.Scan(
		&s.IdGroupe,
		&s.IdEquipier,
		&s.IdCamp,
	)
	return s, err
}

func ScanGroupeEquipier(row *sql.Row) (GroupeEquipier, error) {
	return scanOneGroupeEquipier(row)
}

func SelectAllGroupeEquipiers(tx DB) (GroupeEquipiers, error) {
	rows, err := tx.Query("SELECT * FROM groupe_equipiers")
	if err != nil {
		return nil, err
	}
	return ScanGroupeEquipiers(rows)
}

type GroupeEquipiers []GroupeEquipier

func ScanGroupeEquipiers(rs *sql.Rows) (GroupeEquipiers, error) {
	var (
		s   GroupeEquipier
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(GroupeEquipiers, 0, 16)
	for rs.Next() {
		s, err = scanOneGroupeEquipier(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links GroupeEquipier in the database.
func InsertManyGroupeEquipiers(tx *sql.Tx, items ...GroupeEquipier) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("groupe_equipiers",
		"id_groupe", "id_equipier", "id_camp",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdGroupe, item.IdEquipier, item.IdCamp)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link GroupeEquipier in the database.
// Only the 'IdGroupe' 'IdEquipier' 'IdCamp' fields are used.
func (item GroupeEquipier) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM groupe_equipiers WHERE 
	id_groupe = $1 AND id_equipier = $2 AND id_camp = $3;`, item.IdGroupe, item.IdEquipier, item.IdCamp)
	return err
}

func scanOneGroupeParticipant(row scanner) (GroupeParticipant, error) {
	var s GroupeParticipant
	err := row.Scan(
		&s.IdParticipant,
		&s.IdGroupe,
		&s.IdCamp,
		&s.Manuel,
	)
	return s, err
}

func ScanGroupeParticipant(row *sql.Row) (GroupeParticipant, error) {
	return scanOneGroupeParticipant(row)
}

func SelectAllGroupeParticipants(tx DB) (GroupeParticipants, error) {
	rows, err := tx.Query("SELECT * FROM groupe_participants")
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

type GroupeParticipants []GroupeParticipant

func ScanGroupeParticipants(rs *sql.Rows) (GroupeParticipants, error) {
	var (
		s   GroupeParticipant
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(GroupeParticipants, 0, 16)
	for rs.Next() {
		s, err = scanOneGroupeParticipant(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links GroupeParticipant in the database.
func InsertManyGroupeParticipants(tx *sql.Tx, items ...GroupeParticipant) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("groupe_participants",
		"id_participant", "id_groupe", "id_camp", "manuel",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdParticipant, item.IdGroupe, item.IdCamp, item.Manuel)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link GroupeParticipant in the database.
// Only the 'IdParticipant' 'IdGroupe' 'IdCamp' fields are used.
func (item GroupeParticipant) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM groupe_participants WHERE 
	id_participant = $1 AND id_groupe = $2 AND id_camp = $3;`, item.IdParticipant, item.IdGroupe, item.IdCamp)
	return err
}

func scanOneImageuploaded(row scanner) (Imageuploaded, error) {
	var s Imageuploaded
	err := row.Scan(
		&s.IdCamp,
		&s.Filename,
		&s.Lien,
		&s.Content,
	)
	return s, err
}

func ScanImageuploaded(row *sql.Row) (Imageuploaded, error) {
	return scanOneImageuploaded(row)
}

func SelectAllImageuploadeds(tx DB) (Imageuploadeds, error) {
	rows, err := tx.Query("SELECT * FROM imageuploadeds")
	if err != nil {
		return nil, err
	}
	return ScanImageuploadeds(rows)
}

type Imageuploadeds []Imageuploaded

func ScanImageuploadeds(rs *sql.Rows) (Imageuploadeds, error) {
	var (
		s   Imageuploaded
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Imageuploadeds, 0, 16)
	for rs.Next() {
		s, err = scanOneImageuploaded(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links Imageuploaded in the database.
func InsertManyImageuploadeds(tx *sql.Tx, items ...Imageuploaded) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("imageuploadeds",
		"id_camp", "filename", "lien", "content",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdCamp, item.Filename, item.Lien, item.Content)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Imageuploaded in the database.
// Only the 'IdCamp' fields are used.
func (item Imageuploaded) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM imageuploadeds WHERE 
	id_camp = $1;`, item.IdCamp)
	return err
}

func scanOneInscription(row scanner) (Inscription, error) {
	var s Inscription
	err := row.Scan(
		&s.Id,
		&s.Info,
		&s.DateHeure,
		&s.CopiesMails,
		&s.Responsable,
		&s.Participants,
		&s.PartageAdressesOK,
	)
	return s, err
}

func ScanInscription(row *sql.Row) (Inscription, error) {
	return scanOneInscription(row)
}

func SelectAllInscriptions(tx DB) (Inscriptions, error) {
	rows, err := tx.Query("SELECT * FROM inscriptions")
	if err != nil {
		return nil, err
	}
	return ScanInscriptions(rows)
}

// SelectInscription returns the entry matching id.
func SelectInscription(tx DB, id int64) (Inscription, error) {
	row := tx.QueryRow("SELECT * FROM inscriptions WHERE id = $1", id)
	return ScanInscription(row)
}

// SelectInscriptions returns the entry matching the given ids.
func SelectInscriptions(tx DB, ids ...int64) (Inscriptions, error) {
	rows, err := tx.Query("SELECT * FROM inscriptions WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanInscriptions(rows)
}

type Inscriptions map[int64]Inscription

func (m Inscriptions) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanInscriptions(rs *sql.Rows) (Inscriptions, error) {
	var (
		s   Inscription
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Inscriptions, 16)
	for rs.Next() {
		s, err = scanOneInscription(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Inscription in the database and returns the item with id filled.
func (item Inscription) Insert(tx DB) (out Inscription, err error) {
	row := tx.QueryRow(`INSERT INTO inscriptions (
		info,date_heure,copies_mails,responsable,participants,partage_adresses_ok
		) VALUES (
		$1,$2,$3,$4,$5,$6
		) RETURNING 
		id,info,date_heure,copies_mails,responsable,participants,partage_adresses_ok;
		`, item.Info, item.DateHeure, item.CopiesMails, item.Responsable, item.Participants, item.PartageAdressesOK)
	return ScanInscription(row)
}

// Update Inscription in the database and returns the new version.
func (item Inscription) Update(tx DB) (out Inscription, err error) {
	row := tx.QueryRow(`UPDATE inscriptions SET (
		info,date_heure,copies_mails,responsable,participants,partage_adresses_ok
		) = (
		$2,$3,$4,$5,$6,$7
		) WHERE id = $1 RETURNING 
		id,info,date_heure,copies_mails,responsable,participants,partage_adresses_ok;
		`, item.Id, item.Info, item.DateHeure, item.CopiesMails, item.Responsable, item.Participants, item.PartageAdressesOK)
	return ScanInscription(row)
}

// Deletes the Inscription and returns the item
func DeleteInscriptionById(tx DB, id int64) (Inscription, error) {
	row := tx.QueryRow("DELETE FROM inscriptions WHERE id = $1 RETURNING *;", id)
	return ScanInscription(row)
}

// Deletes the Inscription in the database and returns the ids.
func DeleteInscriptionsByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM inscriptions WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneLettredirecteur(row scanner) (Lettredirecteur, error) {
	var s Lettredirecteur
	err := row.Scan(
		&s.IdCamp,
		&s.Html,
		&s.UseCoordCentre,
		&s.ShowAdressePostale,
		&s.ColorCoord,
	)
	return s, err
}

func ScanLettredirecteur(row *sql.Row) (Lettredirecteur, error) {
	return scanOneLettredirecteur(row)
}

func SelectAllLettredirecteurs(tx DB) (Lettredirecteurs, error) {
	rows, err := tx.Query("SELECT * FROM lettredirecteurs")
	if err != nil {
		return nil, err
	}
	return ScanLettredirecteurs(rows)
}

type Lettredirecteurs []Lettredirecteur

func ScanLettredirecteurs(rs *sql.Rows) (Lettredirecteurs, error) {
	var (
		s   Lettredirecteur
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Lettredirecteurs, 0, 16)
	for rs.Next() {
		s, err = scanOneLettredirecteur(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links Lettredirecteur in the database.
func InsertManyLettredirecteurs(tx *sql.Tx, items ...Lettredirecteur) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("lettredirecteurs",
		"id_camp", "html", "use_coord_centre", "show_adresse_postale", "color_coord",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdCamp, item.Html, item.UseCoordCentre, item.ShowAdressePostale, item.ColorCoord)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Lettredirecteur in the database.
// Only the 'IdCamp' fields are used.
func (item Lettredirecteur) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM lettredirecteurs WHERE 
	id_camp = $1;`, item.IdCamp)
	return err
}

func scanOneMessage(row scanner) (Message, error) {
	var s Message
	err := row.Scan(
		&s.Id,
		&s.IdFacture,
		&s.Kind,
		&s.Created,
		&s.Modified,
		&s.Vu,
	)
	return s, err
}

func ScanMessage(row *sql.Row) (Message, error) {
	return scanOneMessage(row)
}

func SelectAllMessages(tx DB) (Messages, error) {
	rows, err := tx.Query("SELECT * FROM messages")
	if err != nil {
		return nil, err
	}
	return ScanMessages(rows)
}

// SelectMessage returns the entry matching id.
func SelectMessage(tx DB, id int64) (Message, error) {
	row := tx.QueryRow("SELECT * FROM messages WHERE id = $1", id)
	return ScanMessage(row)
}

// SelectMessages returns the entry matching the given ids.
func SelectMessages(tx DB, ids ...int64) (Messages, error) {
	rows, err := tx.Query("SELECT * FROM messages WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanMessages(rows)
}

type Messages map[int64]Message

func (m Messages) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanMessages(rs *sql.Rows) (Messages, error) {
	var (
		s   Message
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Messages, 16)
	for rs.Next() {
		s, err = scanOneMessage(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Message in the database and returns the item with id filled.
func (item Message) Insert(tx DB) (out Message, err error) {
	row := tx.QueryRow(`INSERT INTO messages (
		id_facture,kind,created,modified,vu
		) VALUES (
		$1,$2,$3,$4,$5
		) RETURNING 
		id,id_facture,kind,created,modified,vu;
		`, item.IdFacture, item.Kind, item.Created, item.Modified, item.Vu)
	return ScanMessage(row)
}

// Update Message in the database and returns the new version.
func (item Message) Update(tx DB) (out Message, err error) {
	row := tx.QueryRow(`UPDATE messages SET (
		id_facture,kind,created,modified,vu
		) = (
		$2,$3,$4,$5,$6
		) WHERE id = $1 RETURNING 
		id,id_facture,kind,created,modified,vu;
		`, item.Id, item.IdFacture, item.Kind, item.Created, item.Modified, item.Vu)
	return ScanMessage(row)
}

// Deletes the Message and returns the item
func DeleteMessageById(tx DB, id int64) (Message, error) {
	row := tx.QueryRow("DELETE FROM messages WHERE id = $1 RETURNING *;", id)
	return ScanMessage(row)
}

// Deletes the Message in the database and returns the ids.
func DeleteMessagesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM messages WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneMessageAttestation(row scanner) (MessageAttestation, error) {
	var s MessageAttestation
	err := row.Scan(
		&s.IdMessage,
		&s.Distribution,
		&s.GuardKind,
	)
	return s, err
}

func ScanMessageAttestation(row *sql.Row) (MessageAttestation, error) {
	return scanOneMessageAttestation(row)
}

func SelectAllMessageAttestations(tx DB) (MessageAttestations, error) {
	rows, err := tx.Query("SELECT * FROM message_attestations")
	if err != nil {
		return nil, err
	}
	return ScanMessageAttestations(rows)
}

type MessageAttestations []MessageAttestation

func ScanMessageAttestations(rs *sql.Rows) (MessageAttestations, error) {
	var (
		s   MessageAttestation
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MessageAttestations, 0, 16)
	for rs.Next() {
		s, err = scanOneMessageAttestation(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MessageAttestation in the database.
func InsertManyMessageAttestations(tx *sql.Tx, items ...MessageAttestation) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("message_attestations",
		"id_message", "distribution", "guard_kind",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMessage, item.Distribution, item.GuardKind)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MessageAttestation in the database.
// Only the 'IdMessage' fields are used.
func (item MessageAttestation) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM message_attestations WHERE 
	id_message = $1;`, item.IdMessage)
	return err
}

func scanOneMessageDocument(row scanner) (MessageDocument, error) {
	var s MessageDocument
	err := row.Scan(
		&s.IdMessage,
		&s.IdCamp,
		&s.guardKind,
	)
	return s, err
}

func ScanMessageDocument(row *sql.Row) (MessageDocument, error) {
	return scanOneMessageDocument(row)
}

func SelectAllMessageDocuments(tx DB) (MessageDocuments, error) {
	rows, err := tx.Query("SELECT * FROM message_documents")
	if err != nil {
		return nil, err
	}
	return ScanMessageDocuments(rows)
}

type MessageDocuments []MessageDocument

func ScanMessageDocuments(rs *sql.Rows) (MessageDocuments, error) {
	var (
		s   MessageDocument
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MessageDocuments, 0, 16)
	for rs.Next() {
		s, err = scanOneMessageDocument(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MessageDocument in the database.
func InsertManyMessageDocuments(tx *sql.Tx, items ...MessageDocument) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("message_documents",
		"id_message", "id_camp",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMessage, item.IdCamp)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MessageDocument in the database.
// Only the 'IdMessage' 'IdCamp' fields are used.
func (item MessageDocument) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM message_documents WHERE 
	id_message = $1 AND id_camp = $2;`, item.IdMessage, item.IdCamp)
	return err
}

func scanOneMessageMessage(row scanner) (MessageMessage, error) {
	var s MessageMessage
	err := row.Scan(
		&s.IdMessage,
		&s.Contenu,
		&s.GuardKind,
	)
	return s, err
}

func ScanMessageMessage(row *sql.Row) (MessageMessage, error) {
	return scanOneMessageMessage(row)
}

func SelectAllMessageMessages(tx DB) (MessageMessages, error) {
	rows, err := tx.Query("SELECT * FROM message_messages")
	if err != nil {
		return nil, err
	}
	return ScanMessageMessages(rows)
}

type MessageMessages []MessageMessage

func ScanMessageMessages(rs *sql.Rows) (MessageMessages, error) {
	var (
		s   MessageMessage
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MessageMessages, 0, 16)
	for rs.Next() {
		s, err = scanOneMessageMessage(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MessageMessage in the database.
func InsertManyMessageMessages(tx *sql.Tx, items ...MessageMessage) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("message_messages",
		"id_message", "contenu", "guard_kind",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMessage, item.Contenu, item.GuardKind)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MessageMessage in the database.
// Only the 'IdMessage' fields are used.
func (item MessageMessage) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM message_messages WHERE 
	id_message = $1;`, item.IdMessage)
	return err
}

func scanOneMessagePlacelibere(row scanner) (MessagePlacelibere, error) {
	var s MessagePlacelibere
	err := row.Scan(
		&s.IdMessage,
		&s.IdParticipant,
		&s.guardKind,
	)
	return s, err
}

func ScanMessagePlacelibere(row *sql.Row) (MessagePlacelibere, error) {
	return scanOneMessagePlacelibere(row)
}

func SelectAllMessagePlaceliberes(tx DB) (MessagePlaceliberes, error) {
	rows, err := tx.Query("SELECT * FROM message_placeliberes")
	if err != nil {
		return nil, err
	}
	return ScanMessagePlaceliberes(rows)
}

type MessagePlaceliberes []MessagePlacelibere

func ScanMessagePlaceliberes(rs *sql.Rows) (MessagePlaceliberes, error) {
	var (
		s   MessagePlacelibere
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MessagePlaceliberes, 0, 16)
	for rs.Next() {
		s, err = scanOneMessagePlacelibere(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MessagePlacelibere in the database.
func InsertManyMessagePlaceliberes(tx *sql.Tx, items ...MessagePlacelibere) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("message_placeliberes",
		"id_message", "id_participant",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMessage, item.IdParticipant)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MessagePlacelibere in the database.
// Only the 'IdMessage' 'IdParticipant' fields are used.
func (item MessagePlacelibere) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM message_placeliberes WHERE 
	id_message = $1 AND id_participant = $2;`, item.IdMessage, item.IdParticipant)
	return err
}

func scanOneMessageSondage(row scanner) (MessageSondage, error) {
	var s MessageSondage
	err := row.Scan(
		&s.IdMessage,
		&s.IdCamp,
		&s.guardKind,
		&s.isSimple,
	)
	return s, err
}

func ScanMessageSondage(row *sql.Row) (MessageSondage, error) {
	return scanOneMessageSondage(row)
}

func SelectAllMessageSondages(tx DB) (MessageSondages, error) {
	rows, err := tx.Query("SELECT * FROM message_sondages")
	if err != nil {
		return nil, err
	}
	return ScanMessageSondages(rows)
}

type MessageSondages []MessageSondage

func ScanMessageSondages(rs *sql.Rows) (MessageSondages, error) {
	var (
		s   MessageSondage
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MessageSondages, 0, 16)
	for rs.Next() {
		s, err = scanOneMessageSondage(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MessageSondage in the database.
func InsertManyMessageSondages(tx *sql.Tx, items ...MessageSondage) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("message_sondages",
		"id_message", "id_camp",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMessage, item.IdCamp)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MessageSondage in the database.
// Only the 'IdMessage' 'IdCamp' fields are used.
func (item MessageSondage) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM message_sondages WHERE 
	id_message = $1 AND id_camp = $2;`, item.IdMessage, item.IdCamp)
	return err
}

func scanOneMessageView(row scanner) (MessageView, error) {
	var s MessageView
	err := row.Scan(
		&s.IdMessage,
		&s.IdCamp,
		&s.Vu,
		&s.guardKind,
	)
	return s, err
}

func ScanMessageView(row *sql.Row) (MessageView, error) {
	return scanOneMessageView(row)
}

func SelectAllMessageViews(tx DB) (MessageViews, error) {
	rows, err := tx.Query("SELECT * FROM message_views")
	if err != nil {
		return nil, err
	}
	return ScanMessageViews(rows)
}

type MessageViews []MessageView

func ScanMessageViews(rs *sql.Rows) (MessageViews, error) {
	var (
		s   MessageView
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MessageViews, 0, 16)
	for rs.Next() {
		s, err = scanOneMessageView(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MessageView in the database.
func InsertManyMessageViews(tx *sql.Tx, items ...MessageView) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("message_views",
		"id_message", "id_camp", "vu",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMessage, item.IdCamp, item.Vu)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MessageView in the database.
// Only the 'IdMessage' 'IdCamp' fields are used.
func (item MessageView) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM message_views WHERE 
	id_message = $1 AND id_camp = $2;`, item.IdMessage, item.IdCamp)
	return err
}

func scanOneOrganisme(row scanner) (Organisme, error) {
	var s Organisme
	err := row.Scan(
		&s.Id,
		&s.Nom,
		&s.ContactPropre,
		&s.Contact,
		&s.IdContact,
		&s.IdContactDon,
		&s.Exemplaires,
	)
	return s, err
}

func ScanOrganisme(row *sql.Row) (Organisme, error) {
	return scanOneOrganisme(row)
}

func SelectAllOrganismes(tx DB) (Organismes, error) {
	rows, err := tx.Query("SELECT * FROM organismes")
	if err != nil {
		return nil, err
	}
	return ScanOrganismes(rows)
}

// SelectOrganisme returns the entry matching id.
func SelectOrganisme(tx DB, id int64) (Organisme, error) {
	row := tx.QueryRow("SELECT * FROM organismes WHERE id = $1", id)
	return ScanOrganisme(row)
}

// SelectOrganismes returns the entry matching the given ids.
func SelectOrganismes(tx DB, ids ...int64) (Organismes, error) {
	rows, err := tx.Query("SELECT * FROM organismes WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanOrganismes(rows)
}

type Organismes map[int64]Organisme

func (m Organismes) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanOrganismes(rs *sql.Rows) (Organismes, error) {
	var (
		s   Organisme
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Organismes, 16)
	for rs.Next() {
		s, err = scanOneOrganisme(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Organisme in the database and returns the item with id filled.
func (item Organisme) Insert(tx DB) (out Organisme, err error) {
	row := tx.QueryRow(`INSERT INTO organismes (
		nom,contact_propre,contact,id_contact,id_contact_don,exemplaires
		) VALUES (
		$1,$2,$3,$4,$5,$6
		) RETURNING 
		id,nom,contact_propre,contact,id_contact,id_contact_don,exemplaires;
		`, item.Nom, item.ContactPropre, item.Contact, item.IdContact, item.IdContactDon, item.Exemplaires)
	return ScanOrganisme(row)
}

// Update Organisme in the database and returns the new version.
func (item Organisme) Update(tx DB) (out Organisme, err error) {
	row := tx.QueryRow(`UPDATE organismes SET (
		nom,contact_propre,contact,id_contact,id_contact_don,exemplaires
		) = (
		$2,$3,$4,$5,$6,$7
		) WHERE id = $1 RETURNING 
		id,nom,contact_propre,contact,id_contact,id_contact_don,exemplaires;
		`, item.Id, item.Nom, item.ContactPropre, item.Contact, item.IdContact, item.IdContactDon, item.Exemplaires)
	return ScanOrganisme(row)
}

// Deletes the Organisme and returns the item
func DeleteOrganismeById(tx DB, id int64) (Organisme, error) {
	row := tx.QueryRow("DELETE FROM organismes WHERE id = $1 RETURNING *;", id)
	return ScanOrganisme(row)
}

// Deletes the Organisme in the database and returns the ids.
func DeleteOrganismesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM organismes WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOnePaiement(row scanner) (Paiement, error) {
	var s Paiement
	err := row.Scan(
		&s.Id,
		&s.IdFacture,
		&s.IsAcompte,
		&s.IsRemboursement,
		&s.InBordereau,
		&s.LabelPayeur,
		&s.NomBanque,
		&s.ModePaiement,
		&s.Numero,
		&s.Valeur,
		&s.IsInvalide,
		&s.DateReglement,
		&s.Details,
	)
	return s, err
}

func ScanPaiement(row *sql.Row) (Paiement, error) {
	return scanOnePaiement(row)
}

func SelectAllPaiements(tx DB) (Paiements, error) {
	rows, err := tx.Query("SELECT * FROM paiements")
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

// SelectPaiement returns the entry matching id.
func SelectPaiement(tx DB, id int64) (Paiement, error) {
	row := tx.QueryRow("SELECT * FROM paiements WHERE id = $1", id)
	return ScanPaiement(row)
}

// SelectPaiements returns the entry matching the given ids.
func SelectPaiements(tx DB, ids ...int64) (Paiements, error) {
	rows, err := tx.Query("SELECT * FROM paiements WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

type Paiements map[int64]Paiement

func (m Paiements) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanPaiements(rs *sql.Rows) (Paiements, error) {
	var (
		s   Paiement
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Paiements, 16)
	for rs.Next() {
		s, err = scanOnePaiement(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Paiement in the database and returns the item with id filled.
func (item Paiement) Insert(tx DB) (out Paiement, err error) {
	row := tx.QueryRow(`INSERT INTO paiements (
		id_facture,is_acompte,is_remboursement,in_bordereau,label_payeur,nom_banque,mode_paiement,numero,valeur,is_invalide,date_reglement,details
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
		) RETURNING 
		id,id_facture,is_acompte,is_remboursement,in_bordereau,label_payeur,nom_banque,mode_paiement,numero,valeur,is_invalide,date_reglement,details;
		`, item.IdFacture, item.IsAcompte, item.IsRemboursement, item.InBordereau, item.LabelPayeur, item.NomBanque, item.ModePaiement, item.Numero, item.Valeur, item.IsInvalide, item.DateReglement, item.Details)
	return ScanPaiement(row)
}

// Update Paiement in the database and returns the new version.
func (item Paiement) Update(tx DB) (out Paiement, err error) {
	row := tx.QueryRow(`UPDATE paiements SET (
		id_facture,is_acompte,is_remboursement,in_bordereau,label_payeur,nom_banque,mode_paiement,numero,valeur,is_invalide,date_reglement,details
		) = (
		$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13
		) WHERE id = $1 RETURNING 
		id,id_facture,is_acompte,is_remboursement,in_bordereau,label_payeur,nom_banque,mode_paiement,numero,valeur,is_invalide,date_reglement,details;
		`, item.Id, item.IdFacture, item.IsAcompte, item.IsRemboursement, item.InBordereau, item.LabelPayeur, item.NomBanque, item.ModePaiement, item.Numero, item.Valeur, item.IsInvalide, item.DateReglement, item.Details)
	return ScanPaiement(row)
}

// Deletes the Paiement and returns the item
func DeletePaiementById(tx DB, id int64) (Paiement, error) {
	row := tx.QueryRow("DELETE FROM paiements WHERE id = $1 RETURNING *;", id)
	return ScanPaiement(row)
}

// Deletes the Paiement in the database and returns the ids.
func DeletePaiementsByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM paiements WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneParticipant(row scanner) (Participant, error) {
	var s Participant
	err := row.Scan(
		&s.Id,
		&s.IdCamp,
		&s.IdPersonne,
		&s.IdFacture,
		&s.ListeAttente,
		&s.Remises,
		&s.OptionPrix,
		&s.Options,
		&s.DateHeure,
		&s.isSimple,
		&s.QuotientFamilial,
	)
	return s, err
}

func ScanParticipant(row *sql.Row) (Participant, error) {
	return scanOneParticipant(row)
}

func SelectAllParticipants(tx DB) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants")
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

// SelectParticipant returns the entry matching id.
func SelectParticipant(tx DB, id int64) (Participant, error) {
	row := tx.QueryRow("SELECT * FROM participants WHERE id = $1", id)
	return ScanParticipant(row)
}

// SelectParticipants returns the entry matching the given ids.
func SelectParticipants(tx DB, ids ...int64) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

type Participants map[int64]Participant

func (m Participants) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanParticipants(rs *sql.Rows) (Participants, error) {
	var (
		s   Participant
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Participants, 16)
	for rs.Next() {
		s, err = scanOneParticipant(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Participant in the database and returns the item with id filled.
func (item Participant) Insert(tx DB) (out Participant, err error) {
	row := tx.QueryRow(`INSERT INTO participants (
		id_camp,id_personne,id_facture,liste_attente,remises,option_prix,options,date_heure,quotient_familial
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7,$8,$9
		) RETURNING 
		id,id_camp,id_personne,id_facture,liste_attente,remises,option_prix,options,date_heure,isSimple,quotient_familial;
		`, item.IdCamp, item.IdPersonne, item.IdFacture, item.ListeAttente, item.Remises, item.OptionPrix, item.Options, item.DateHeure, item.QuotientFamilial)
	return ScanParticipant(row)
}

// Update Participant in the database and returns the new version.
func (item Participant) Update(tx DB) (out Participant, err error) {
	row := tx.QueryRow(`UPDATE participants SET (
		id_camp,id_personne,id_facture,liste_attente,remises,option_prix,options,date_heure,quotient_familial
		) = (
		$2,$3,$4,$5,$6,$7,$8,$9,$10
		) WHERE id = $1 RETURNING 
		id,id_camp,id_personne,id_facture,liste_attente,remises,option_prix,options,date_heure,isSimple,quotient_familial;
		`, item.Id, item.IdCamp, item.IdPersonne, item.IdFacture, item.ListeAttente, item.Remises, item.OptionPrix, item.Options, item.DateHeure, item.QuotientFamilial)
	return ScanParticipant(row)
}

// Deletes the Participant and returns the item
func DeleteParticipantById(tx DB, id int64) (Participant, error) {
	row := tx.QueryRow("DELETE FROM participants WHERE id = $1 RETURNING *;", id)
	return ScanParticipant(row)
}

// Deletes the Participant in the database and returns the ids.
func DeleteParticipantsByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneParticipantEquipier(row scanner) (ParticipantEquipier, error) {
	var s ParticipantEquipier
	err := row.Scan(
		&s.IdParticipant,
		&s.IdEquipier,
		&s.IdGroupe,
	)
	return s, err
}

func ScanParticipantEquipier(row *sql.Row) (ParticipantEquipier, error) {
	return scanOneParticipantEquipier(row)
}

func SelectAllParticipantEquipiers(tx DB) (ParticipantEquipiers, error) {
	rows, err := tx.Query("SELECT * FROM participant_equipiers")
	if err != nil {
		return nil, err
	}
	return ScanParticipantEquipiers(rows)
}

type ParticipantEquipiers []ParticipantEquipier

func ScanParticipantEquipiers(rs *sql.Rows) (ParticipantEquipiers, error) {
	var (
		s   ParticipantEquipier
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ParticipantEquipiers, 0, 16)
	for rs.Next() {
		s, err = scanOneParticipantEquipier(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links ParticipantEquipier in the database.
func InsertManyParticipantEquipiers(tx *sql.Tx, items ...ParticipantEquipier) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("participant_equipiers",
		"id_participant", "id_equipier", "id_groupe",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdParticipant, item.IdEquipier, item.IdGroupe)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ParticipantEquipier in the database.
// Only the 'IdParticipant' 'IdEquipier' 'IdGroupe' fields are used.
func (item ParticipantEquipier) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM participant_equipiers WHERE 
	id_participant = $1 AND id_equipier = $2 AND id_groupe = $3;`, item.IdParticipant, item.IdEquipier, item.IdGroupe)
	return err
}

func scanOneParticipantsimple(row scanner) (Participantsimple, error) {
	var s Participantsimple
	err := row.Scan(
		&s.Id,
		&s.IdPersonne,
		&s.IdCamp,
		&s.DateHeure,
		&s.Info,
		&s.isSimple,
	)
	return s, err
}

func ScanParticipantsimple(row *sql.Row) (Participantsimple, error) {
	return scanOneParticipantsimple(row)
}

func SelectAllParticipantsimples(tx DB) (Participantsimples, error) {
	rows, err := tx.Query("SELECT * FROM participantsimples")
	if err != nil {
		return nil, err
	}
	return ScanParticipantsimples(rows)
}

// SelectParticipantsimple returns the entry matching id.
func SelectParticipantsimple(tx DB, id int64) (Participantsimple, error) {
	row := tx.QueryRow("SELECT * FROM participantsimples WHERE id = $1", id)
	return ScanParticipantsimple(row)
}

// SelectParticipantsimples returns the entry matching the given ids.
func SelectParticipantsimples(tx DB, ids ...int64) (Participantsimples, error) {
	rows, err := tx.Query("SELECT * FROM participantsimples WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanParticipantsimples(rows)
}

type Participantsimples map[int64]Participantsimple

func (m Participantsimples) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanParticipantsimples(rs *sql.Rows) (Participantsimples, error) {
	var (
		s   Participantsimple
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Participantsimples, 16)
	for rs.Next() {
		s, err = scanOneParticipantsimple(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Participantsimple in the database and returns the item with id filled.
func (item Participantsimple) Insert(tx DB) (out Participantsimple, err error) {
	row := tx.QueryRow(`INSERT INTO participantsimples (
		id_personne,id_camp,date_heure,info
		) VALUES (
		$1,$2,$3,$4
		) RETURNING 
		id,id_personne,id_camp,date_heure,info,isSimple;
		`, item.IdPersonne, item.IdCamp, item.DateHeure, item.Info)
	return ScanParticipantsimple(row)
}

// Update Participantsimple in the database and returns the new version.
func (item Participantsimple) Update(tx DB) (out Participantsimple, err error) {
	row := tx.QueryRow(`UPDATE participantsimples SET (
		id_personne,id_camp,date_heure,info
		) = (
		$2,$3,$4,$5
		) WHERE id = $1 RETURNING 
		id,id_personne,id_camp,date_heure,info,isSimple;
		`, item.Id, item.IdPersonne, item.IdCamp, item.DateHeure, item.Info)
	return ScanParticipantsimple(row)
}

// Deletes the Participantsimple and returns the item
func DeleteParticipantsimpleById(tx DB, id int64) (Participantsimple, error) {
	row := tx.QueryRow("DELETE FROM participantsimples WHERE id = $1 RETURNING *;", id)
	return ScanParticipantsimple(row)
}

// Deletes the Participantsimple in the database and returns the ids.
func DeleteParticipantsimplesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM participantsimples WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOnePersonne(row scanner) (Personne, error) {
	var s Personne
	err := row.Scan(
		&s.Id,
		&s.Nom,
		&s.NomJeuneFille,
		&s.Prenom,
		&s.DateNaissance,
		&s.VilleNaissance,
		&s.DepartementNaissance,
		&s.Sexe,
		&s.Tels,
		&s.Mail,
		&s.Adresse,
		&s.CodePostal,
		&s.Ville,
		&s.Pays,
		&s.SecuriteSociale,
		&s.Profession,
		&s.Etudiant,
		&s.Fonctionnaire,
		&s.VersionPapier,
		&s.PubHiver,
		&s.PubEte,
		&s.EchoRocher,
		&s.RangMembreAsso,
		&s.QuotientFamilial,
		&s.Cotisation,
		&s.Eonews,
		&s.FicheSanitaire,
		&s.IsTemporaire,
	)
	return s, err
}

func ScanPersonne(row *sql.Row) (Personne, error) {
	return scanOnePersonne(row)
}

func SelectAllPersonnes(tx DB) (Personnes, error) {
	rows, err := tx.Query("SELECT * FROM personnes")
	if err != nil {
		return nil, err
	}
	return ScanPersonnes(rows)
}

// SelectPersonne returns the entry matching id.
func SelectPersonne(tx DB, id int64) (Personne, error) {
	row := tx.QueryRow("SELECT * FROM personnes WHERE id = $1", id)
	return ScanPersonne(row)
}

// SelectPersonnes returns the entry matching the given ids.
func SelectPersonnes(tx DB, ids ...int64) (Personnes, error) {
	rows, err := tx.Query("SELECT * FROM personnes WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanPersonnes(rows)
}

type Personnes map[int64]Personne

func (m Personnes) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanPersonnes(rs *sql.Rows) (Personnes, error) {
	var (
		s   Personne
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Personnes, 16)
	for rs.Next() {
		s, err = scanOnePersonne(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Personne in the database and returns the item with id filled.
func (item Personne) Insert(tx DB) (out Personne, err error) {
	row := tx.QueryRow(`INSERT INTO personnes (
		nom,nom_jeune_fille,prenom,date_naissance,ville_naissance,departement_naissance,sexe,tels,mail,adresse,code_postal,ville,pays,securite_sociale,profession,etudiant,fonctionnaire,version_papier,pub_hiver,pub_ete,echo_rocher,rang_membre_asso,quotient_familial,cotisation,eonews,fiche_sanitaire,is_temporaire
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27
		) RETURNING 
		id,nom,nom_jeune_fille,prenom,date_naissance,ville_naissance,departement_naissance,sexe,tels,mail,adresse,code_postal,ville,pays,securite_sociale,profession,etudiant,fonctionnaire,version_papier,pub_hiver,pub_ete,echo_rocher,rang_membre_asso,quotient_familial,cotisation,eonews,fiche_sanitaire,is_temporaire;
		`, item.Nom, item.NomJeuneFille, item.Prenom, item.DateNaissance, item.VilleNaissance, item.DepartementNaissance, item.Sexe, item.Tels, item.Mail, item.Adresse, item.CodePostal, item.Ville, item.Pays, item.SecuriteSociale, item.Profession, item.Etudiant, item.Fonctionnaire, item.VersionPapier, item.PubHiver, item.PubEte, item.EchoRocher, item.RangMembreAsso, item.QuotientFamilial, item.Cotisation, item.Eonews, item.FicheSanitaire, item.IsTemporaire)
	return ScanPersonne(row)
}

// Update Personne in the database and returns the new version.
func (item Personne) Update(tx DB) (out Personne, err error) {
	row := tx.QueryRow(`UPDATE personnes SET (
		nom,nom_jeune_fille,prenom,date_naissance,ville_naissance,departement_naissance,sexe,tels,mail,adresse,code_postal,ville,pays,securite_sociale,profession,etudiant,fonctionnaire,version_papier,pub_hiver,pub_ete,echo_rocher,rang_membre_asso,quotient_familial,cotisation,eonews,fiche_sanitaire,is_temporaire
		) = (
		$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28
		) WHERE id = $1 RETURNING 
		id,nom,nom_jeune_fille,prenom,date_naissance,ville_naissance,departement_naissance,sexe,tels,mail,adresse,code_postal,ville,pays,securite_sociale,profession,etudiant,fonctionnaire,version_papier,pub_hiver,pub_ete,echo_rocher,rang_membre_asso,quotient_familial,cotisation,eonews,fiche_sanitaire,is_temporaire;
		`, item.Id, item.Nom, item.NomJeuneFille, item.Prenom, item.DateNaissance, item.VilleNaissance, item.DepartementNaissance, item.Sexe, item.Tels, item.Mail, item.Adresse, item.CodePostal, item.Ville, item.Pays, item.SecuriteSociale, item.Profession, item.Etudiant, item.Fonctionnaire, item.VersionPapier, item.PubHiver, item.PubEte, item.EchoRocher, item.RangMembreAsso, item.QuotientFamilial, item.Cotisation, item.Eonews, item.FicheSanitaire, item.IsTemporaire)
	return ScanPersonne(row)
}

// Deletes the Personne and returns the item
func DeletePersonneById(tx DB, id int64) (Personne, error) {
	row := tx.QueryRow("DELETE FROM personnes WHERE id = $1 RETURNING *;", id)
	return ScanPersonne(row)
}

// Deletes the Personne in the database and returns the ids.
func DeletePersonnesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM personnes WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneSondage(row scanner) (Sondage, error) {
	var s Sondage
	err := row.Scan(
		&s.Id,
		&s.IdCamp,
		&s.IdFacture,
		&s.Modified,
		&s.InfosAvantSejour,
		&s.InfosPendantSejour,
		&s.Hebergement,
		&s.Activites,
		&s.Theme,
		&s.Nourriture,
		&s.Hygiene,
		&s.Ambiance,
		&s.Ressenti,
		&s.MessageEnfant,
		&s.MessageResponsable,
	)
	return s, err
}

func ScanSondage(row *sql.Row) (Sondage, error) {
	return scanOneSondage(row)
}

func SelectAllSondages(tx DB) (Sondages, error) {
	rows, err := tx.Query("SELECT * FROM sondages")
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

// SelectSondage returns the entry matching id.
func SelectSondage(tx DB, id int64) (Sondage, error) {
	row := tx.QueryRow("SELECT * FROM sondages WHERE id = $1", id)
	return ScanSondage(row)
}

// SelectSondages returns the entry matching the given ids.
func SelectSondages(tx DB, ids ...int64) (Sondages, error) {
	rows, err := tx.Query("SELECT * FROM sondages WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

type Sondages map[int64]Sondage

func (m Sondages) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanSondages(rs *sql.Rows) (Sondages, error) {
	var (
		s   Sondage
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Sondages, 16)
	for rs.Next() {
		s, err = scanOneSondage(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Sondage in the database and returns the item with id filled.
func (item Sondage) Insert(tx DB) (out Sondage, err error) {
	row := tx.QueryRow(`INSERT INTO sondages (
		id_camp,id_facture,modified,infos_avant_sejour,infos_pendant_sejour,hebergement,activites,theme,nourriture,hygiene,ambiance,ressenti,message_enfant,message_responsable
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14
		) RETURNING 
		id,id_camp,id_facture,modified,infos_avant_sejour,infos_pendant_sejour,hebergement,activites,theme,nourriture,hygiene,ambiance,ressenti,message_enfant,message_responsable;
		`, item.IdCamp, item.IdFacture, item.Modified, item.InfosAvantSejour, item.InfosPendantSejour, item.Hebergement, item.Activites, item.Theme, item.Nourriture, item.Hygiene, item.Ambiance, item.Ressenti, item.MessageEnfant, item.MessageResponsable)
	return ScanSondage(row)
}

// Update Sondage in the database and returns the new version.
func (item Sondage) Update(tx DB) (out Sondage, err error) {
	row := tx.QueryRow(`UPDATE sondages SET (
		id_camp,id_facture,modified,infos_avant_sejour,infos_pendant_sejour,hebergement,activites,theme,nourriture,hygiene,ambiance,ressenti,message_enfant,message_responsable
		) = (
		$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15
		) WHERE id = $1 RETURNING 
		id,id_camp,id_facture,modified,infos_avant_sejour,infos_pendant_sejour,hebergement,activites,theme,nourriture,hygiene,ambiance,ressenti,message_enfant,message_responsable;
		`, item.Id, item.IdCamp, item.IdFacture, item.Modified, item.InfosAvantSejour, item.InfosPendantSejour, item.Hebergement, item.Activites, item.Theme, item.Nourriture, item.Hygiene, item.Ambiance, item.Ressenti, item.MessageEnfant, item.MessageResponsable)
	return ScanSondage(row)
}

// Deletes the Sondage and returns the item
func DeleteSondageById(tx DB, id int64) (Sondage, error) {
	row := tx.QueryRow("DELETE FROM sondages WHERE id = $1 RETURNING *;", id)
	return ScanSondage(row)
}

// Deletes the Sondage in the database and returns the ids.
func DeleteSondagesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM sondages WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneStructureaide(row scanner) (Structureaide, error) {
	var s Structureaide
	err := row.Scan(
		&s.Id,
		&s.Nom,
		&s.Immatriculation,
		&s.Adresse,
		&s.CodePostal,
		&s.Ville,
		&s.Telephone,
		&s.Info,
	)
	return s, err
}

func ScanStructureaide(row *sql.Row) (Structureaide, error) {
	return scanOneStructureaide(row)
}

func SelectAllStructureaides(tx DB) (Structureaides, error) {
	rows, err := tx.Query("SELECT * FROM structureaides")
	if err != nil {
		return nil, err
	}
	return ScanStructureaides(rows)
}

// SelectStructureaide returns the entry matching id.
func SelectStructureaide(tx DB, id int64) (Structureaide, error) {
	row := tx.QueryRow("SELECT * FROM structureaides WHERE id = $1", id)
	return ScanStructureaide(row)
}

// SelectStructureaides returns the entry matching the given ids.
func SelectStructureaides(tx DB, ids ...int64) (Structureaides, error) {
	rows, err := tx.Query("SELECT * FROM structureaides WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanStructureaides(rows)
}

type Structureaides map[int64]Structureaide

func (m Structureaides) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanStructureaides(rs *sql.Rows) (Structureaides, error) {
	var (
		s   Structureaide
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Structureaides, 16)
	for rs.Next() {
		s, err = scanOneStructureaide(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Structureaide in the database and returns the item with id filled.
func (item Structureaide) Insert(tx DB) (out Structureaide, err error) {
	row := tx.QueryRow(`INSERT INTO structureaides (
		nom,immatriculation,adresse,code_postal,ville,telephone,info
		) VALUES (
		$1,$2,$3,$4,$5,$6,$7
		) RETURNING 
		id,nom,immatriculation,adresse,code_postal,ville,telephone,info;
		`, item.Nom, item.Immatriculation, item.Adresse, item.CodePostal, item.Ville, item.Telephone, item.Info)
	return ScanStructureaide(row)
}

// Update Structureaide in the database and returns the new version.
func (item Structureaide) Update(tx DB) (out Structureaide, err error) {
	row := tx.QueryRow(`UPDATE structureaides SET (
		nom,immatriculation,adresse,code_postal,ville,telephone,info
		) = (
		$2,$3,$4,$5,$6,$7,$8
		) WHERE id = $1 RETURNING 
		id,nom,immatriculation,adresse,code_postal,ville,telephone,info;
		`, item.Id, item.Nom, item.Immatriculation, item.Adresse, item.CodePostal, item.Ville, item.Telephone, item.Info)
	return ScanStructureaide(row)
}

// Deletes the Structureaide and returns the item
func DeleteStructureaideById(tx DB, id int64) (Structureaide, error) {
	row := tx.QueryRow("DELETE FROM structureaides WHERE id = $1 RETURNING *;", id)
	return ScanStructureaide(row)
}

// Deletes the Structureaide in the database and returns the ids.
func DeleteStructureaidesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM structureaides WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneUser(row scanner) (User, error) {
	var s User
	err := row.Scan(
		&s.Id,
		&s.Label,
		&s.Mdp,
		&s.IsAdmin,
		&s.Modules,
	)
	return s, err
}

func ScanUser(row *sql.Row) (User, error) {
	return scanOneUser(row)
}

func SelectAllUsers(tx DB) (Users, error) {
	rows, err := tx.Query("SELECT * FROM users")
	if err != nil {
		return nil, err
	}
	return ScanUsers(rows)
}

// SelectUser returns the entry matching id.
func SelectUser(tx DB, id int64) (User, error) {
	row := tx.QueryRow("SELECT * FROM users WHERE id = $1", id)
	return ScanUser(row)
}

// SelectUsers returns the entry matching the given ids.
func SelectUsers(tx DB, ids ...int64) (Users, error) {
	rows, err := tx.Query("SELECT * FROM users WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanUsers(rows)
}

type Users map[int64]User

func (m Users) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanUsers(rs *sql.Rows) (Users, error) {
	var (
		s   User
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Users, 16)
	for rs.Next() {
		s, err = scanOneUser(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert User in the database and returns the item with id filled.
func (item User) Insert(tx DB) (out User, err error) {
	row := tx.QueryRow(`INSERT INTO users (
		label,mdp,is_admin,modules
		) VALUES (
		$1,$2,$3,$4
		) RETURNING 
		id,label,mdp,is_admin,modules;
		`, item.Label, item.Mdp, item.IsAdmin, item.Modules)
	return ScanUser(row)
}

// Update User in the database and returns the new version.
func (item User) Update(tx DB) (out User, err error) {
	row := tx.QueryRow(`UPDATE users SET (
		label,mdp,is_admin,modules
		) = (
		$2,$3,$4,$5
		) WHERE id = $1 RETURNING 
		id,label,mdp,is_admin,modules;
		`, item.Id, item.Label, item.Mdp, item.IsAdmin, item.Modules)
	return ScanUser(row)
}

// Deletes the User and returns the item
func DeleteUserById(tx DB, id int64) (User, error) {
	row := tx.QueryRow("DELETE FROM users WHERE id = $1 RETURNING *;", id)
	return ScanUser(row)
}

// Deletes the User in the database and returns the ids.
func DeleteUsersByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM users WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectAidesByIdStructureaides(tx DB, idStructureaides ...int64) (Aides, error) {
	rows, err := tx.Query("SELECT * FROM aides WHERE id_structureaide = ANY($1)", pq.Int64Array(idStructureaides))
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

func DeleteAidesByIdStructureaides(tx DB, idStructureaides ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM aides WHERE id_structureaide = ANY($1) RETURNING id", pq.Int64Array(idStructureaides))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectAidesByIdParticipants(tx DB, idParticipants ...int64) (Aides, error) {
	rows, err := tx.Query("SELECT * FROM aides WHERE id_participant = ANY($1)", pq.Int64Array(idParticipants))
	if err != nil {
		return nil, err
	}
	return ScanAides(rows)
}

func DeleteAidesByIdParticipants(tx DB, idParticipants ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM aides WHERE id_participant = ANY($1) RETURNING id", pq.Int64Array(idParticipants))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectCampContraintesByIdCamps(tx DB, idCamps ...int64) (CampContraintes, error) {
	rows, err := tx.Query("SELECT * FROM camp_contraintes WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanCampContraintes(rows)
}

func DeleteCampContraintesByIdCamps(tx DB, idCamps ...int64) (CampContraintes, error) {
	rows, err := tx.Query("DELETE FROM camp_contraintes WHERE id_camp = ANY($1) RETURNING *", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanCampContraintes(rows)
}

func SelectCampContraintesByIdContraintes(tx DB, idContraintes ...int64) (CampContraintes, error) {
	rows, err := tx.Query("SELECT * FROM camp_contraintes WHERE id_contrainte = ANY($1)", pq.Int64Array(idContraintes))
	if err != nil {
		return nil, err
	}
	return ScanCampContraintes(rows)
}

func DeleteCampContraintesByIdContraintes(tx DB, idContraintes ...int64) (CampContraintes, error) {
	rows, err := tx.Query("DELETE FROM camp_contraintes WHERE id_contrainte = ANY($1) RETURNING *", pq.Int64Array(idContraintes))
	if err != nil {
		return nil, err
	}
	return ScanCampContraintes(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items CampContraintes) ByIdCamp() map[int64]CampContraintes {
	out := make(map[int64]CampContraintes)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// ByIdContrainte returns a map with 'IdContrainte' as keys.
func (items CampContraintes) ByIdContrainte() map[int64]CampContraintes {
	out := make(map[int64]CampContraintes)
	for _, target := range items {
		out[target.IdContrainte] = append(out[target.IdContrainte], target)
	}
	return out
}

// SelectContenuDocumentByIdDocument return zero or one item, thanks to a UNIQUE constraint
func SelectContenuDocumentByIdDocument(tx DB, idDocument int64) (item ContenuDocument, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM contenu_documents WHERE id_document = $1", idDocument)
	item, err = ScanContenuDocument(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectContenuDocumentsByIdDocuments(tx DB, idDocuments ...int64) (ContenuDocuments, error) {
	rows, err := tx.Query("SELECT * FROM contenu_documents WHERE id_document = ANY($1)", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanContenuDocuments(rows)
}

func DeleteContenuDocumentsByIdDocuments(tx DB, idDocuments ...int64) (ContenuDocuments, error) {
	rows, err := tx.Query("DELETE FROM contenu_documents WHERE id_document = ANY($1) RETURNING *", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanContenuDocuments(rows)
}

// ByIdDocument returns a map with 'IdDocument' as keys.
func (items ContenuDocuments) ByIdDocument() map[int64]ContenuDocument {
	out := make(map[int64]ContenuDocument, len(items))
	for _, target := range items {
		out[target.IdDocument] = target
	}
	return out
}

func SelectContraintesByIdPersonnes(tx DB, idPersonnes ...int64) (Contraintes, error) {
	rows, err := tx.Query("SELECT * FROM contraintes WHERE id_personne = ANY($1)", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanContraintes(rows)
}

func DeleteContraintesByIdPersonnes(tx DB, idPersonnes ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM contraintes WHERE id_personne = ANY($1) RETURNING id", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectContraintesByIdDocuments(tx DB, idDocuments ...int64) (Contraintes, error) {
	rows, err := tx.Query("SELECT * FROM contraintes WHERE id_document = ANY($1)", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanContraintes(rows)
}

func DeleteContraintesByIdDocuments(tx DB, idDocuments ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM contraintes WHERE id_document = ANY($1) RETURNING id", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

// SelectDocumentAideByIdDocument return zero or one item, thanks to a UNIQUE constraint
func SelectDocumentAideByIdDocument(tx DB, idDocument int64) (item DocumentAide, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM document_aides WHERE id_document = $1", idDocument)
	item, err = ScanDocumentAide(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectDocumentAidesByIdDocuments(tx DB, idDocuments ...int64) (DocumentAides, error) {
	rows, err := tx.Query("SELECT * FROM document_aides WHERE id_document = ANY($1)", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanDocumentAides(rows)
}

func DeleteDocumentAidesByIdDocuments(tx DB, idDocuments ...int64) (DocumentAides, error) {
	rows, err := tx.Query("DELETE FROM document_aides WHERE id_document = ANY($1) RETURNING *", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanDocumentAides(rows)
}

func SelectDocumentAidesByIdAides(tx DB, idAides ...int64) (DocumentAides, error) {
	rows, err := tx.Query("SELECT * FROM document_aides WHERE id_aide = ANY($1)", pq.Int64Array(idAides))
	if err != nil {
		return nil, err
	}
	return ScanDocumentAides(rows)
}

func DeleteDocumentAidesByIdAides(tx DB, idAides ...int64) (DocumentAides, error) {
	rows, err := tx.Query("DELETE FROM document_aides WHERE id_aide = ANY($1) RETURNING *", pq.Int64Array(idAides))
	if err != nil {
		return nil, err
	}
	return ScanDocumentAides(rows)
}

// ByIdDocument returns a map with 'IdDocument' as keys.
func (items DocumentAides) ByIdDocument() map[int64]DocumentAide {
	out := make(map[int64]DocumentAide, len(items))
	for _, target := range items {
		out[target.IdDocument] = target
	}
	return out
}

// ByIdAide returns a map with 'IdAide' as keys.
func (items DocumentAides) ByIdAide() map[int64]DocumentAides {
	out := make(map[int64]DocumentAides)
	for _, target := range items {
		out[target.IdAide] = append(out[target.IdAide], target)
	}
	return out
}

// SelectDocumentCampByIdDocument return zero or one item, thanks to a UNIQUE constraint
func SelectDocumentCampByIdDocument(tx DB, idDocument int64) (item DocumentCamp, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM document_camps WHERE id_document = $1", idDocument)
	item, err = ScanDocumentCamp(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectDocumentCampsByIdDocuments(tx DB, idDocuments ...int64) (DocumentCamps, error) {
	rows, err := tx.Query("SELECT * FROM document_camps WHERE id_document = ANY($1)", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanDocumentCamps(rows)
}

func DeleteDocumentCampsByIdDocuments(tx DB, idDocuments ...int64) (DocumentCamps, error) {
	rows, err := tx.Query("DELETE FROM document_camps WHERE id_document = ANY($1) RETURNING *", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanDocumentCamps(rows)
}

func SelectDocumentCampsByIdCamps(tx DB, idCamps ...int64) (DocumentCamps, error) {
	rows, err := tx.Query("SELECT * FROM document_camps WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanDocumentCamps(rows)
}

func DeleteDocumentCampsByIdCamps(tx DB, idCamps ...int64) (DocumentCamps, error) {
	rows, err := tx.Query("DELETE FROM document_camps WHERE id_camp = ANY($1) RETURNING *", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanDocumentCamps(rows)
}

// ByIdDocument returns a map with 'IdDocument' as keys.
func (items DocumentCamps) ByIdDocument() map[int64]DocumentCamp {
	out := make(map[int64]DocumentCamp, len(items))
	for _, target := range items {
		out[target.IdDocument] = target
	}
	return out
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items DocumentCamps) ByIdCamp() map[int64]DocumentCamps {
	out := make(map[int64]DocumentCamps)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// SelectDocumentPersonneByIdDocument return zero or one item, thanks to a UNIQUE constraint
func SelectDocumentPersonneByIdDocument(tx DB, idDocument int64) (item DocumentPersonne, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM document_personnes WHERE id_document = $1", idDocument)
	item, err = ScanDocumentPersonne(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectDocumentPersonnesByIdDocuments(tx DB, idDocuments ...int64) (DocumentPersonnes, error) {
	rows, err := tx.Query("SELECT * FROM document_personnes WHERE id_document = ANY($1)", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanDocumentPersonnes(rows)
}

func DeleteDocumentPersonnesByIdDocuments(tx DB, idDocuments ...int64) (DocumentPersonnes, error) {
	rows, err := tx.Query("DELETE FROM document_personnes WHERE id_document = ANY($1) RETURNING *", pq.Int64Array(idDocuments))
	if err != nil {
		return nil, err
	}
	return ScanDocumentPersonnes(rows)
}

func SelectDocumentPersonnesByIdPersonnes(tx DB, idPersonnes ...int64) (DocumentPersonnes, error) {
	rows, err := tx.Query("SELECT * FROM document_personnes WHERE id_personne = ANY($1)", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanDocumentPersonnes(rows)
}

func DeleteDocumentPersonnesByIdPersonnes(tx DB, idPersonnes ...int64) (DocumentPersonnes, error) {
	rows, err := tx.Query("DELETE FROM document_personnes WHERE id_personne = ANY($1) RETURNING *", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanDocumentPersonnes(rows)
}

func SelectDocumentPersonnesByIdContraintes(tx DB, idContraintes ...int64) (DocumentPersonnes, error) {
	rows, err := tx.Query("SELECT * FROM document_personnes WHERE id_contrainte = ANY($1)", pq.Int64Array(idContraintes))
	if err != nil {
		return nil, err
	}
	return ScanDocumentPersonnes(rows)
}

func DeleteDocumentPersonnesByIdContraintes(tx DB, idContraintes ...int64) (DocumentPersonnes, error) {
	rows, err := tx.Query("DELETE FROM document_personnes WHERE id_contrainte = ANY($1) RETURNING *", pq.Int64Array(idContraintes))
	if err != nil {
		return nil, err
	}
	return ScanDocumentPersonnes(rows)
}

// ByIdDocument returns a map with 'IdDocument' as keys.
func (items DocumentPersonnes) ByIdDocument() map[int64]DocumentPersonne {
	out := make(map[int64]DocumentPersonne, len(items))
	for _, target := range items {
		out[target.IdDocument] = target
	}
	return out
}

// ByIdPersonne returns a map with 'IdPersonne' as keys.
func (items DocumentPersonnes) ByIdPersonne() map[int64]DocumentPersonnes {
	out := make(map[int64]DocumentPersonnes)
	for _, target := range items {
		out[target.IdPersonne] = append(out[target.IdPersonne], target)
	}
	return out
}

// ByIdContrainte returns a map with 'IdContrainte' as keys.
func (items DocumentPersonnes) ByIdContrainte() map[int64]DocumentPersonnes {
	out := make(map[int64]DocumentPersonnes)
	for _, target := range items {
		out[target.IdContrainte] = append(out[target.IdContrainte], target)
	}
	return out
}

// SelectDonDonateurByIdDon return zero or one item, thanks to a UNIQUE constraint
func SelectDonDonateurByIdDon(tx DB, idDon int64) (item DonDonateur, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM don_donateurs WHERE id_don = $1", idDon)
	item, err = ScanDonDonateur(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectDonDonateursByIdDons(tx DB, idDons ...int64) (DonDonateurs, error) {
	rows, err := tx.Query("SELECT * FROM don_donateurs WHERE id_don = ANY($1)", pq.Int64Array(idDons))
	if err != nil {
		return nil, err
	}
	return ScanDonDonateurs(rows)
}

func DeleteDonDonateursByIdDons(tx DB, idDons ...int64) (DonDonateurs, error) {
	rows, err := tx.Query("DELETE FROM don_donateurs WHERE id_don = ANY($1) RETURNING *", pq.Int64Array(idDons))
	if err != nil {
		return nil, err
	}
	return ScanDonDonateurs(rows)
}

func SelectDonDonateursByIdPersonnes(tx DB, idPersonnes ...int64) (DonDonateurs, error) {
	rows, err := tx.Query("SELECT * FROM don_donateurs WHERE id_personne = ANY($1)", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanDonDonateurs(rows)
}

func DeleteDonDonateursByIdPersonnes(tx DB, idPersonnes ...int64) (DonDonateurs, error) {
	rows, err := tx.Query("DELETE FROM don_donateurs WHERE id_personne = ANY($1) RETURNING *", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanDonDonateurs(rows)
}

func SelectDonDonateursByIdOrganismes(tx DB, idOrganismes ...int64) (DonDonateurs, error) {
	rows, err := tx.Query("SELECT * FROM don_donateurs WHERE id_organisme = ANY($1)", pq.Int64Array(idOrganismes))
	if err != nil {
		return nil, err
	}
	return ScanDonDonateurs(rows)
}

func DeleteDonDonateursByIdOrganismes(tx DB, idOrganismes ...int64) (DonDonateurs, error) {
	rows, err := tx.Query("DELETE FROM don_donateurs WHERE id_organisme = ANY($1) RETURNING *", pq.Int64Array(idOrganismes))
	if err != nil {
		return nil, err
	}
	return ScanDonDonateurs(rows)
}

// ByIdDon returns a map with 'IdDon' as keys.
func (items DonDonateurs) ByIdDon() map[int64]DonDonateur {
	out := make(map[int64]DonDonateur, len(items))
	for _, target := range items {
		out[target.IdDon] = target
	}
	return out
}

func SelectEquipiersByIdCamps(tx DB, idCamps ...int64) (Equipiers, error) {
	rows, err := tx.Query("SELECT * FROM equipiers WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

func DeleteEquipiersByIdCamps(tx DB, idCamps ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM equipiers WHERE id_camp = ANY($1) RETURNING id", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectEquipiersByIdPersonnes(tx DB, idPersonnes ...int64) (Equipiers, error) {
	rows, err := tx.Query("SELECT * FROM equipiers WHERE id_personne = ANY($1)", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanEquipiers(rows)
}

func DeleteEquipiersByIdPersonnes(tx DB, idPersonnes ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM equipiers WHERE id_personne = ANY($1) RETURNING id", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectEquipierContraintesByIdEquipiers(tx DB, idEquipiers ...int64) (EquipierContraintes, error) {
	rows, err := tx.Query("SELECT * FROM equipier_contraintes WHERE id_equipier = ANY($1)", pq.Int64Array(idEquipiers))
	if err != nil {
		return nil, err
	}
	return ScanEquipierContraintes(rows)
}

func DeleteEquipierContraintesByIdEquipiers(tx DB, idEquipiers ...int64) (EquipierContraintes, error) {
	rows, err := tx.Query("DELETE FROM equipier_contraintes WHERE id_equipier = ANY($1) RETURNING *", pq.Int64Array(idEquipiers))
	if err != nil {
		return nil, err
	}
	return ScanEquipierContraintes(rows)
}

func SelectEquipierContraintesByIdContraintes(tx DB, idContraintes ...int64) (EquipierContraintes, error) {
	rows, err := tx.Query("SELECT * FROM equipier_contraintes WHERE id_contrainte = ANY($1)", pq.Int64Array(idContraintes))
	if err != nil {
		return nil, err
	}
	return ScanEquipierContraintes(rows)
}

func DeleteEquipierContraintesByIdContraintes(tx DB, idContraintes ...int64) (EquipierContraintes, error) {
	rows, err := tx.Query("DELETE FROM equipier_contraintes WHERE id_contrainte = ANY($1) RETURNING *", pq.Int64Array(idContraintes))
	if err != nil {
		return nil, err
	}
	return ScanEquipierContraintes(rows)
}

// ByIdEquipier returns a map with 'IdEquipier' as keys.
func (items EquipierContraintes) ByIdEquipier() map[int64]EquipierContraintes {
	out := make(map[int64]EquipierContraintes)
	for _, target := range items {
		out[target.IdEquipier] = append(out[target.IdEquipier], target)
	}
	return out
}

// ByIdContrainte returns a map with 'IdContrainte' as keys.
func (items EquipierContraintes) ByIdContrainte() map[int64]EquipierContraintes {
	out := make(map[int64]EquipierContraintes)
	for _, target := range items {
		out[target.IdContrainte] = append(out[target.IdContrainte], target)
	}
	return out
}

func SelectFacturesByIdPersonnes(tx DB, idPersonnes ...int64) (Factures, error) {
	rows, err := tx.Query("SELECT * FROM factures WHERE id_personne = ANY($1)", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanFactures(rows)
}

func DeleteFacturesByIdPersonnes(tx DB, idPersonnes ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM factures WHERE id_personne = ANY($1) RETURNING id", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectGroupesByIdCamps(tx DB, idCamps ...int64) (Groupes, error) {
	rows, err := tx.Query("SELECT * FROM groupes WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanGroupes(rows)
}

func DeleteGroupesByIdCamps(tx DB, idCamps ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM groupes WHERE id_camp = ANY($1) RETURNING id", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectGroupeContraintesByIdGroupes(tx DB, idGroupes ...int64) (GroupeContraintes, error) {
	rows, err := tx.Query("SELECT * FROM groupe_contraintes WHERE id_groupe = ANY($1)", pq.Int64Array(idGroupes))
	if err != nil {
		return nil, err
	}
	return ScanGroupeContraintes(rows)
}

func DeleteGroupeContraintesByIdGroupes(tx DB, idGroupes ...int64) (GroupeContraintes, error) {
	rows, err := tx.Query("DELETE FROM groupe_contraintes WHERE id_groupe = ANY($1) RETURNING *", pq.Int64Array(idGroupes))
	if err != nil {
		return nil, err
	}
	return ScanGroupeContraintes(rows)
}

func SelectGroupeContraintesByIdContraintes(tx DB, idContraintes ...int64) (GroupeContraintes, error) {
	rows, err := tx.Query("SELECT * FROM groupe_contraintes WHERE id_contrainte = ANY($1)", pq.Int64Array(idContraintes))
	if err != nil {
		return nil, err
	}
	return ScanGroupeContraintes(rows)
}

func DeleteGroupeContraintesByIdContraintes(tx DB, idContraintes ...int64) (GroupeContraintes, error) {
	rows, err := tx.Query("DELETE FROM groupe_contraintes WHERE id_contrainte = ANY($1) RETURNING *", pq.Int64Array(idContraintes))
	if err != nil {
		return nil, err
	}
	return ScanGroupeContraintes(rows)
}

// ByIdGroupe returns a map with 'IdGroupe' as keys.
func (items GroupeContraintes) ByIdGroupe() map[int64]GroupeContraintes {
	out := make(map[int64]GroupeContraintes)
	for _, target := range items {
		out[target.IdGroupe] = append(out[target.IdGroupe], target)
	}
	return out
}

// ByIdContrainte returns a map with 'IdContrainte' as keys.
func (items GroupeContraintes) ByIdContrainte() map[int64]GroupeContraintes {
	out := make(map[int64]GroupeContraintes)
	for _, target := range items {
		out[target.IdContrainte] = append(out[target.IdContrainte], target)
	}
	return out
}

func SelectGroupeEquipiersByIdGroupes(tx DB, idGroupes ...int64) (GroupeEquipiers, error) {
	rows, err := tx.Query("SELECT * FROM groupe_equipiers WHERE id_groupe = ANY($1)", pq.Int64Array(idGroupes))
	if err != nil {
		return nil, err
	}
	return ScanGroupeEquipiers(rows)
}

func DeleteGroupeEquipiersByIdGroupes(tx DB, idGroupes ...int64) (GroupeEquipiers, error) {
	rows, err := tx.Query("DELETE FROM groupe_equipiers WHERE id_groupe = ANY($1) RETURNING *", pq.Int64Array(idGroupes))
	if err != nil {
		return nil, err
	}
	return ScanGroupeEquipiers(rows)
}

func SelectGroupeEquipiersByIdEquipiers(tx DB, idEquipiers ...int64) (GroupeEquipiers, error) {
	rows, err := tx.Query("SELECT * FROM groupe_equipiers WHERE id_equipier = ANY($1)", pq.Int64Array(idEquipiers))
	if err != nil {
		return nil, err
	}
	return ScanGroupeEquipiers(rows)
}

func DeleteGroupeEquipiersByIdEquipiers(tx DB, idEquipiers ...int64) (GroupeEquipiers, error) {
	rows, err := tx.Query("DELETE FROM groupe_equipiers WHERE id_equipier = ANY($1) RETURNING *", pq.Int64Array(idEquipiers))
	if err != nil {
		return nil, err
	}
	return ScanGroupeEquipiers(rows)
}

func SelectGroupeEquipiersByIdCamps(tx DB, idCamps ...int64) (GroupeEquipiers, error) {
	rows, err := tx.Query("SELECT * FROM groupe_equipiers WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanGroupeEquipiers(rows)
}

func DeleteGroupeEquipiersByIdCamps(tx DB, idCamps ...int64) (GroupeEquipiers, error) {
	rows, err := tx.Query("DELETE FROM groupe_equipiers WHERE id_camp = ANY($1) RETURNING *", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanGroupeEquipiers(rows)
}

// ByIdGroupe returns a map with 'IdGroupe' as keys.
func (items GroupeEquipiers) ByIdGroupe() map[int64]GroupeEquipiers {
	out := make(map[int64]GroupeEquipiers)
	for _, target := range items {
		out[target.IdGroupe] = append(out[target.IdGroupe], target)
	}
	return out
}

// ByIdEquipier returns a map with 'IdEquipier' as keys.
func (items GroupeEquipiers) ByIdEquipier() map[int64]GroupeEquipiers {
	out := make(map[int64]GroupeEquipiers)
	for _, target := range items {
		out[target.IdEquipier] = append(out[target.IdEquipier], target)
	}
	return out
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items GroupeEquipiers) ByIdCamp() map[int64]GroupeEquipiers {
	out := make(map[int64]GroupeEquipiers)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// SelectGroupeParticipantByIdParticipant return zero or one item, thanks to a UNIQUE constraint
func SelectGroupeParticipantByIdParticipant(tx DB, idParticipant int64) (item GroupeParticipant, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM groupe_participants WHERE id_participant = $1", idParticipant)
	item, err = ScanGroupeParticipant(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectGroupeParticipantsByIdParticipants(tx DB, idParticipants ...int64) (GroupeParticipants, error) {
	rows, err := tx.Query("SELECT * FROM groupe_participants WHERE id_participant = ANY($1)", pq.Int64Array(idParticipants))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

func DeleteGroupeParticipantsByIdParticipants(tx DB, idParticipants ...int64) (GroupeParticipants, error) {
	rows, err := tx.Query("DELETE FROM groupe_participants WHERE id_participant = ANY($1) RETURNING *", pq.Int64Array(idParticipants))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

func SelectGroupeParticipantsByIdGroupes(tx DB, idGroupes ...int64) (GroupeParticipants, error) {
	rows, err := tx.Query("SELECT * FROM groupe_participants WHERE id_groupe = ANY($1)", pq.Int64Array(idGroupes))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

func DeleteGroupeParticipantsByIdGroupes(tx DB, idGroupes ...int64) (GroupeParticipants, error) {
	rows, err := tx.Query("DELETE FROM groupe_participants WHERE id_groupe = ANY($1) RETURNING *", pq.Int64Array(idGroupes))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

func SelectGroupeParticipantsByIdCamps(tx DB, idCamps ...int64) (GroupeParticipants, error) {
	rows, err := tx.Query("SELECT * FROM groupe_participants WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

func DeleteGroupeParticipantsByIdCamps(tx DB, idCamps ...int64) (GroupeParticipants, error) {
	rows, err := tx.Query("DELETE FROM groupe_participants WHERE id_camp = ANY($1) RETURNING *", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanGroupeParticipants(rows)
}

// ByIdParticipant returns a map with 'IdParticipant' as keys.
func (items GroupeParticipants) ByIdParticipant() map[int64]GroupeParticipant {
	out := make(map[int64]GroupeParticipant, len(items))
	for _, target := range items {
		out[target.IdParticipant] = target
	}
	return out
}

// ByIdGroupe returns a map with 'IdGroupe' as keys.
func (items GroupeParticipants) ByIdGroupe() map[int64]GroupeParticipants {
	out := make(map[int64]GroupeParticipants)
	for _, target := range items {
		out[target.IdGroupe] = append(out[target.IdGroupe], target)
	}
	return out
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items GroupeParticipants) ByIdCamp() map[int64]GroupeParticipants {
	out := make(map[int64]GroupeParticipants)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

func SelectImageuploadedsByIdCamps(tx DB, idCamps ...int64) (Imageuploadeds, error) {
	rows, err := tx.Query("SELECT * FROM imageuploadeds WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanImageuploadeds(rows)
}

func DeleteImageuploadedsByIdCamps(tx DB, idCamps ...int64) (Imageuploadeds, error) {
	rows, err := tx.Query("DELETE FROM imageuploadeds WHERE id_camp = ANY($1) RETURNING *", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanImageuploadeds(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Imageuploadeds) ByIdCamp() map[int64]Imageuploadeds {
	out := make(map[int64]Imageuploadeds)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// SelectLettredirecteurByIdCamp return zero or one item, thanks to a UNIQUE constraint
func SelectLettredirecteurByIdCamp(tx DB, idCamp int64) (item Lettredirecteur, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM lettredirecteurs WHERE id_camp = $1", idCamp)
	item, err = ScanLettredirecteur(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectLettredirecteursByIdCamps(tx DB, idCamps ...int64) (Lettredirecteurs, error) {
	rows, err := tx.Query("SELECT * FROM lettredirecteurs WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanLettredirecteurs(rows)
}

func DeleteLettredirecteursByIdCamps(tx DB, idCamps ...int64) (Lettredirecteurs, error) {
	rows, err := tx.Query("DELETE FROM lettredirecteurs WHERE id_camp = ANY($1) RETURNING *", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanLettredirecteurs(rows)
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items Lettredirecteurs) ByIdCamp() map[int64]Lettredirecteur {
	out := make(map[int64]Lettredirecteur, len(items))
	for _, target := range items {
		out[target.IdCamp] = target
	}
	return out
}

func SelectMessagesByIdFactures(tx DB, idFactures ...int64) (Messages, error) {
	rows, err := tx.Query("SELECT * FROM messages WHERE id_facture = ANY($1)", pq.Int64Array(idFactures))
	if err != nil {
		return nil, err
	}
	return ScanMessages(rows)
}

func DeleteMessagesByIdFactures(tx DB, idFactures ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM messages WHERE id_facture = ANY($1) RETURNING id", pq.Int64Array(idFactures))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

// SelectMessageAttestationByIdMessage return zero or one item, thanks to a UNIQUE constraint
func SelectMessageAttestationByIdMessage(tx DB, idMessage int64) (item MessageAttestation, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM message_attestations WHERE id_message = $1", idMessage)
	item, err = ScanMessageAttestation(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectMessageAttestationsByIdMessages(tx DB, idMessages ...int64) (MessageAttestations, error) {
	rows, err := tx.Query("SELECT * FROM message_attestations WHERE id_message = ANY($1)", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageAttestations(rows)
}

func DeleteMessageAttestationsByIdMessages(tx DB, idMessages ...int64) (MessageAttestations, error) {
	rows, err := tx.Query("DELETE FROM message_attestations WHERE id_message = ANY($1) RETURNING *", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageAttestations(rows)
}

// ByIdMessage returns a map with 'IdMessage' as keys.
func (items MessageAttestations) ByIdMessage() map[int64]MessageAttestation {
	out := make(map[int64]MessageAttestation, len(items))
	for _, target := range items {
		out[target.IdMessage] = target
	}
	return out
}

// SelectMessageDocumentByIdMessage return zero or one item, thanks to a UNIQUE constraint
func SelectMessageDocumentByIdMessage(tx DB, idMessage int64) (item MessageDocument, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM message_documents WHERE id_message = $1", idMessage)
	item, err = ScanMessageDocument(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectMessageDocumentsByIdMessages(tx DB, idMessages ...int64) (MessageDocuments, error) {
	rows, err := tx.Query("SELECT * FROM message_documents WHERE id_message = ANY($1)", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageDocuments(rows)
}

func DeleteMessageDocumentsByIdMessages(tx DB, idMessages ...int64) (MessageDocuments, error) {
	rows, err := tx.Query("DELETE FROM message_documents WHERE id_message = ANY($1) RETURNING *", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageDocuments(rows)
}

func SelectMessageDocumentsByIdCamps(tx DB, idCamps ...int64) (MessageDocuments, error) {
	rows, err := tx.Query("SELECT * FROM message_documents WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanMessageDocuments(rows)
}

func DeleteMessageDocumentsByIdCamps(tx DB, idCamps ...int64) (MessageDocuments, error) {
	rows, err := tx.Query("DELETE FROM message_documents WHERE id_camp = ANY($1) RETURNING *", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanMessageDocuments(rows)
}

// ByIdMessage returns a map with 'IdMessage' as keys.
func (items MessageDocuments) ByIdMessage() map[int64]MessageDocument {
	out := make(map[int64]MessageDocument, len(items))
	for _, target := range items {
		out[target.IdMessage] = target
	}
	return out
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items MessageDocuments) ByIdCamp() map[int64]MessageDocuments {
	out := make(map[int64]MessageDocuments)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

// SelectMessageMessageByIdMessage return zero or one item, thanks to a UNIQUE constraint
func SelectMessageMessageByIdMessage(tx DB, idMessage int64) (item MessageMessage, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM message_messages WHERE id_message = $1", idMessage)
	item, err = ScanMessageMessage(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectMessageMessagesByIdMessages(tx DB, idMessages ...int64) (MessageMessages, error) {
	rows, err := tx.Query("SELECT * FROM message_messages WHERE id_message = ANY($1)", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageMessages(rows)
}

func DeleteMessageMessagesByIdMessages(tx DB, idMessages ...int64) (MessageMessages, error) {
	rows, err := tx.Query("DELETE FROM message_messages WHERE id_message = ANY($1) RETURNING *", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageMessages(rows)
}

// ByIdMessage returns a map with 'IdMessage' as keys.
func (items MessageMessages) ByIdMessage() map[int64]MessageMessage {
	out := make(map[int64]MessageMessage, len(items))
	for _, target := range items {
		out[target.IdMessage] = target
	}
	return out
}

// SelectMessagePlacelibereByIdMessage return zero or one item, thanks to a UNIQUE constraint
func SelectMessagePlacelibereByIdMessage(tx DB, idMessage int64) (item MessagePlacelibere, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM message_placeliberes WHERE id_message = $1", idMessage)
	item, err = ScanMessagePlacelibere(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectMessagePlaceliberesByIdMessages(tx DB, idMessages ...int64) (MessagePlaceliberes, error) {
	rows, err := tx.Query("SELECT * FROM message_placeliberes WHERE id_message = ANY($1)", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessagePlaceliberes(rows)
}

func DeleteMessagePlaceliberesByIdMessages(tx DB, idMessages ...int64) (MessagePlaceliberes, error) {
	rows, err := tx.Query("DELETE FROM message_placeliberes WHERE id_message = ANY($1) RETURNING *", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessagePlaceliberes(rows)
}

func SelectMessagePlaceliberesByIdParticipants(tx DB, idParticipants ...int64) (MessagePlaceliberes, error) {
	rows, err := tx.Query("SELECT * FROM message_placeliberes WHERE id_participant = ANY($1)", pq.Int64Array(idParticipants))
	if err != nil {
		return nil, err
	}
	return ScanMessagePlaceliberes(rows)
}

func DeleteMessagePlaceliberesByIdParticipants(tx DB, idParticipants ...int64) (MessagePlaceliberes, error) {
	rows, err := tx.Query("DELETE FROM message_placeliberes WHERE id_participant = ANY($1) RETURNING *", pq.Int64Array(idParticipants))
	if err != nil {
		return nil, err
	}
	return ScanMessagePlaceliberes(rows)
}

// ByIdMessage returns a map with 'IdMessage' as keys.
func (items MessagePlaceliberes) ByIdMessage() map[int64]MessagePlacelibere {
	out := make(map[int64]MessagePlacelibere, len(items))
	for _, target := range items {
		out[target.IdMessage] = target
	}
	return out
}

// ByIdParticipant returns a map with 'IdParticipant' as keys.
func (items MessagePlaceliberes) ByIdParticipant() map[int64]MessagePlaceliberes {
	out := make(map[int64]MessagePlaceliberes)
	for _, target := range items {
		out[target.IdParticipant] = append(out[target.IdParticipant], target)
	}
	return out
}

// SelectMessageSondageByIdMessage return zero or one item, thanks to a UNIQUE constraint
func SelectMessageSondageByIdMessage(tx DB, idMessage int64) (item MessageSondage, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM message_sondages WHERE id_message = $1", idMessage)
	item, err = ScanMessageSondage(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectMessageSondagesByIdMessages(tx DB, idMessages ...int64) (MessageSondages, error) {
	rows, err := tx.Query("SELECT * FROM message_sondages WHERE id_message = ANY($1)", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageSondages(rows)
}

func DeleteMessageSondagesByIdMessages(tx DB, idMessages ...int64) (MessageSondages, error) {
	rows, err := tx.Query("DELETE FROM message_sondages WHERE id_message = ANY($1) RETURNING *", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageSondages(rows)
}

func SelectMessageSondagesByIdCamps(tx DB, idCamps ...int64) (MessageSondages, error) {
	rows, err := tx.Query("SELECT * FROM message_sondages WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanMessageSondages(rows)
}

func DeleteMessageSondagesByIdCamps(tx DB, idCamps ...int64) (MessageSondages, error) {
	rows, err := tx.Query("DELETE FROM message_sondages WHERE id_camp = ANY($1) RETURNING *", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanMessageSondages(rows)
}

// ByIdMessage returns a map with 'IdMessage' as keys.
func (items MessageSondages) ByIdMessage() map[int64]MessageSondage {
	out := make(map[int64]MessageSondage, len(items))
	for _, target := range items {
		out[target.IdMessage] = target
	}
	return out
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items MessageSondages) ByIdCamp() map[int64]MessageSondages {
	out := make(map[int64]MessageSondages)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

func SelectMessageViewsByIdMessages(tx DB, idMessages ...int64) (MessageViews, error) {
	rows, err := tx.Query("SELECT * FROM message_views WHERE id_message = ANY($1)", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageViews(rows)
}

func DeleteMessageViewsByIdMessages(tx DB, idMessages ...int64) (MessageViews, error) {
	rows, err := tx.Query("DELETE FROM message_views WHERE id_message = ANY($1) RETURNING *", pq.Int64Array(idMessages))
	if err != nil {
		return nil, err
	}
	return ScanMessageViews(rows)
}

func SelectMessageViewsByIdCamps(tx DB, idCamps ...int64) (MessageViews, error) {
	rows, err := tx.Query("SELECT * FROM message_views WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanMessageViews(rows)
}

func DeleteMessageViewsByIdCamps(tx DB, idCamps ...int64) (MessageViews, error) {
	rows, err := tx.Query("DELETE FROM message_views WHERE id_camp = ANY($1) RETURNING *", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanMessageViews(rows)
}

// ByIdMessage returns a map with 'IdMessage' as keys.
func (items MessageViews) ByIdMessage() map[int64]MessageViews {
	out := make(map[int64]MessageViews)
	for _, target := range items {
		out[target.IdMessage] = append(out[target.IdMessage], target)
	}
	return out
}

// ByIdCamp returns a map with 'IdCamp' as keys.
func (items MessageViews) ByIdCamp() map[int64]MessageViews {
	out := make(map[int64]MessageViews)
	for _, target := range items {
		out[target.IdCamp] = append(out[target.IdCamp], target)
	}
	return out
}

func SelectOrganismesByIdContacts(tx DB, idContacts ...int64) (Organismes, error) {
	rows, err := tx.Query("SELECT * FROM organismes WHERE id_contact = ANY($1)", pq.Int64Array(idContacts))
	if err != nil {
		return nil, err
	}
	return ScanOrganismes(rows)
}

func DeleteOrganismesByIdContacts(tx DB, idContacts ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM organismes WHERE id_contact = ANY($1) RETURNING id", pq.Int64Array(idContacts))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectOrganismesByIdContactDons(tx DB, idContactDons ...int64) (Organismes, error) {
	rows, err := tx.Query("SELECT * FROM organismes WHERE id_contact_don = ANY($1)", pq.Int64Array(idContactDons))
	if err != nil {
		return nil, err
	}
	return ScanOrganismes(rows)
}

func DeleteOrganismesByIdContactDons(tx DB, idContactDons ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM organismes WHERE id_contact_don = ANY($1) RETURNING id", pq.Int64Array(idContactDons))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectPaiementsByIdFactures(tx DB, idFactures ...int64) (Paiements, error) {
	rows, err := tx.Query("SELECT * FROM paiements WHERE id_facture = ANY($1)", pq.Int64Array(idFactures))
	if err != nil {
		return nil, err
	}
	return ScanPaiements(rows)
}

func DeletePaiementsByIdFactures(tx DB, idFactures ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM paiements WHERE id_facture = ANY($1) RETURNING id", pq.Int64Array(idFactures))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectParticipantsByIdCamps(tx DB, idCamps ...int64) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdCamps(tx DB, idCamps ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE id_camp = ANY($1) RETURNING id", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectParticipantsByIdPersonnes(tx DB, idPersonnes ...int64) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE id_personne = ANY($1)", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdPersonnes(tx DB, idPersonnes ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE id_personne = ANY($1) RETURNING id", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectParticipantsByIdFactures(tx DB, idFactures ...int64) (Participants, error) {
	rows, err := tx.Query("SELECT * FROM participants WHERE id_facture = ANY($1)", pq.Int64Array(idFactures))
	if err != nil {
		return nil, err
	}
	return ScanParticipants(rows)
}

func DeleteParticipantsByIdFactures(tx DB, idFactures ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM participants WHERE id_facture = ANY($1) RETURNING id", pq.Int64Array(idFactures))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

// SelectParticipantEquipierByIdParticipant return zero or one item, thanks to a UNIQUE constraint
func SelectParticipantEquipierByIdParticipant(tx DB, idParticipant int64) (item ParticipantEquipier, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM participant_equipiers WHERE id_participant = $1", idParticipant)
	item, err = ScanParticipantEquipier(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectParticipantEquipiersByIdParticipants(tx DB, idParticipants ...int64) (ParticipantEquipiers, error) {
	rows, err := tx.Query("SELECT * FROM participant_equipiers WHERE id_participant = ANY($1)", pq.Int64Array(idParticipants))
	if err != nil {
		return nil, err
	}
	return ScanParticipantEquipiers(rows)
}

func DeleteParticipantEquipiersByIdParticipants(tx DB, idParticipants ...int64) (ParticipantEquipiers, error) {
	rows, err := tx.Query("DELETE FROM participant_equipiers WHERE id_participant = ANY($1) RETURNING *", pq.Int64Array(idParticipants))
	if err != nil {
		return nil, err
	}
	return ScanParticipantEquipiers(rows)
}

func SelectParticipantEquipiersByIdEquipiers(tx DB, idEquipiers ...int64) (ParticipantEquipiers, error) {
	rows, err := tx.Query("SELECT * FROM participant_equipiers WHERE id_equipier = ANY($1)", pq.Int64Array(idEquipiers))
	if err != nil {
		return nil, err
	}
	return ScanParticipantEquipiers(rows)
}

func DeleteParticipantEquipiersByIdEquipiers(tx DB, idEquipiers ...int64) (ParticipantEquipiers, error) {
	rows, err := tx.Query("DELETE FROM participant_equipiers WHERE id_equipier = ANY($1) RETURNING *", pq.Int64Array(idEquipiers))
	if err != nil {
		return nil, err
	}
	return ScanParticipantEquipiers(rows)
}

func SelectParticipantEquipiersByIdGroupes(tx DB, idGroupes ...int64) (ParticipantEquipiers, error) {
	rows, err := tx.Query("SELECT * FROM participant_equipiers WHERE id_groupe = ANY($1)", pq.Int64Array(idGroupes))
	if err != nil {
		return nil, err
	}
	return ScanParticipantEquipiers(rows)
}

func DeleteParticipantEquipiersByIdGroupes(tx DB, idGroupes ...int64) (ParticipantEquipiers, error) {
	rows, err := tx.Query("DELETE FROM participant_equipiers WHERE id_groupe = ANY($1) RETURNING *", pq.Int64Array(idGroupes))
	if err != nil {
		return nil, err
	}
	return ScanParticipantEquipiers(rows)
}

// ByIdParticipant returns a map with 'IdParticipant' as keys.
func (items ParticipantEquipiers) ByIdParticipant() map[int64]ParticipantEquipier {
	out := make(map[int64]ParticipantEquipier, len(items))
	for _, target := range items {
		out[target.IdParticipant] = target
	}
	return out
}

// ByIdEquipier returns a map with 'IdEquipier' as keys.
func (items ParticipantEquipiers) ByIdEquipier() map[int64]ParticipantEquipiers {
	out := make(map[int64]ParticipantEquipiers)
	for _, target := range items {
		out[target.IdEquipier] = append(out[target.IdEquipier], target)
	}
	return out
}

// ByIdGroupe returns a map with 'IdGroupe' as keys.
func (items ParticipantEquipiers) ByIdGroupe() map[int64]ParticipantEquipiers {
	out := make(map[int64]ParticipantEquipiers)
	for _, target := range items {
		out[target.IdGroupe] = append(out[target.IdGroupe], target)
	}
	return out
}

func SelectParticipantsimplesByIdPersonnes(tx DB, idPersonnes ...int64) (Participantsimples, error) {
	rows, err := tx.Query("SELECT * FROM participantsimples WHERE id_personne = ANY($1)", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanParticipantsimples(rows)
}

func DeleteParticipantsimplesByIdPersonnes(tx DB, idPersonnes ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM participantsimples WHERE id_personne = ANY($1) RETURNING id", pq.Int64Array(idPersonnes))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectParticipantsimplesByIdCamps(tx DB, idCamps ...int64) (Participantsimples, error) {
	rows, err := tx.Query("SELECT * FROM participantsimples WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanParticipantsimples(rows)
}

func DeleteParticipantsimplesByIdCamps(tx DB, idCamps ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM participantsimples WHERE id_camp = ANY($1) RETURNING id", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectSondagesByIdCamps(tx DB, idCamps ...int64) (Sondages, error) {
	rows, err := tx.Query("SELECT * FROM sondages WHERE id_camp = ANY($1)", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

func DeleteSondagesByIdCamps(tx DB, idCamps ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM sondages WHERE id_camp = ANY($1) RETURNING id", pq.Int64Array(idCamps))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectSondagesByIdFactures(tx DB, idFactures ...int64) (Sondages, error) {
	rows, err := tx.Query("SELECT * FROM sondages WHERE id_facture = ANY($1)", pq.Int64Array(idFactures))
	if err != nil {
		return nil, err
	}
	return ScanSondages(rows)
}

func DeleteSondagesByIdFactures(tx DB, idFactures ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM sondages WHERE id_facture = ANY($1) RETURNING id", pq.Int64Array(idFactures))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}
