// This script is a small helper to split an SQL file into
// 3 parts : tables, json functions and constraints
//
// go run make_sql.go
package main

import (
	"bytes"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strings"
)

type statement struct {
	content string
	kind    uint8
}

const (
	createType uint8 = iota
	table
	jsonFunc
	constraint
)

func newStatement(s string) statement {
	out := statement{content: s}
	switch {
	case strings.HasPrefix(s, "CREATE TYPE"):
		out.kind = createType
	case strings.HasPrefix(s, "CREATE TABLE"):
		out.kind = table
	case strings.HasPrefix(s, "CREATE OR REPLACE FUNCTION"):
		out.kind = jsonFunc
	case strings.HasPrefix(s, "ALTER TABLE") || strings.HasPrefix(s, "CREATE UNIQUE INDEX"):
		out.kind = constraint
	default:
		panic(s)
	}
	return out
}

// remove comments
func removeComments(s string) string {
	var builder strings.Builder
	lines := strings.Split(s, "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "--") {
			continue
		}
		builder.WriteString(line + "\n")
	}
	return builder.String()
}

func splitStatements(s []byte) []statement {
	tmp := bytes.Split(s, []byte{'\n', '\n'})
	out := make([]statement, 0, len(tmp))
	for _, st := range tmp {
		str := removeComments(string(st))
		str = strings.TrimSpace(str)
		if str == "" {
			continue
		}
		out = append(out, newStatement(str))
	}
	return out
}

func fetchSQLFiles() (out []statement) {
	err := filepath.WalkDir("../sql", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil // recurse
		}

		if !strings.HasSuffix(path, "gen_create.sql") {
			return nil // continue
		}

		by, err := os.ReadFile(path)
		check(err)

		out = append(out, splitStatements(by)...)

		return nil
	})
	check(err)

	// sort so that create type are written first
	slices.SortFunc(out, func(a, b statement) int { return int(a.kind) - int(b.kind) })

	return out
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func main() {
	statements := fetchSQLFiles()

	f0, err := os.Create("create_1_tables.sql")
	check(err)
	f1, err := os.Create("create_2_json_funcs.sql")
	check(err)
	f2, err := os.Create("create_3_constraints.sql")
	check(err)
	defer f0.Close()
	defer f1.Close()
	defer f2.Close()

	_, err = f0.WriteString("-- generated by make_sql.go DO NOT EDIT.\n\n")
	check(err)
	_, err = f1.WriteString("-- generated by make_sql.go DO NOT EDIT.\n\n")
	check(err)
	_, err = f2.WriteString("-- generated by make_sql.go DO NOT EDIT.\n\n")
	check(err)

	// outputs
	files := [...]*os.File{
		createType: f0,
		table:      f0,
		jsonFunc:   f1,
		constraint: f2,
	}
	for _, st := range statements {
		_, err = files[st.kind].WriteString(st.content + "\n\n")
		check(err)
	}
}
